<!DOCTYPE html>
<html>
<head>
  <title>relay-compiler</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules/.bin/relay-compiler";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="background highlight"></div>
<table cellpadding="0" cellspacing="0">
  <tbody>
    
      <tr>
        <td class="docs">
          <h1>relay-compiler</h1>
        </td>
        <td class="code highlight"></td>
      </tr>
    
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-1" id="section-1"></a>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-meta">#!/usr/bin/env node</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-2" id="section-2"></a>
</div>
<div class="dox">
<div class="summary">
<p>Relay v10.1.0</p>
</div>
<div class="body">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-built_in">module</span>.exports =
<span class="hljs-comment">/******/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modules</span>) </span>{ <span class="hljs-comment">// webpackBootstrap</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// The module cache</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-keyword">var</span> installedModules = {};
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// The require function</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) </span>{
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 		<span class="hljs-comment">// Check if module is in cache</span>
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">if</span>(installedModules[moduleId]) {
<span class="hljs-comment">/******/</span> 			<span class="hljs-keyword">return</span> installedModules[moduleId].exports;
<span class="hljs-comment">/******/</span> 		}
<span class="hljs-comment">/******/</span> 		<span class="hljs-comment">// Create a new module (and put it into the cache)</span>
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = installedModules[moduleId] = {
<span class="hljs-comment">/******/</span> 			i: moduleId,
<span class="hljs-comment">/******/</span> 			l: <span class="hljs-literal">false</span>,
<span class="hljs-comment">/******/</span> 			exports: {}
<span class="hljs-comment">/******/</span> 		};
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 		<span class="hljs-comment">// Execute the module function</span>
<span class="hljs-comment">/******/</span> 		modules[moduleId].call(<span class="hljs-built_in">module</span>.exports, <span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports, __webpack_require__);
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 		<span class="hljs-comment">// Flag the module as loaded</span>
<span class="hljs-comment">/******/</span> 		<span class="hljs-built_in">module</span>.l = <span class="hljs-literal">true</span>;
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 		<span class="hljs-comment">// Return the exports of the module</span>
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;
<span class="hljs-comment">/******/</span> 	}
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// expose the modules object (__webpack_modules__)</span>
<span class="hljs-comment">/******/</span> 	__webpack_require__.m = modules;
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// expose the module cache</span>
<span class="hljs-comment">/******/</span> 	__webpack_require__.c = installedModules;
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// define getter function for harmony exports</span>
<span class="hljs-comment">/******/</span> 	__webpack_require__.d = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">exports, name, getter</span>) </span>{
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">if</span>(!__webpack_require__.o(exports, name)) {
<span class="hljs-comment">/******/</span> 			<span class="hljs-built_in">Object</span>.defineProperty(exports, name, { <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">get</span>: getter });
<span class="hljs-comment">/******/</span> 		}
<span class="hljs-comment">/******/</span> 	};
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// define __esModule on exports</span>
<span class="hljs-comment">/******/</span> 	__webpack_require__.r = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">exports</span>) </span>{
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; <span class="hljs-built_in">Symbol</span>.toStringTag) {
<span class="hljs-comment">/******/</span> 			<span class="hljs-built_in">Object</span>.defineProperty(exports, <span class="hljs-built_in">Symbol</span>.toStringTag, { <span class="hljs-attr">value</span>: <span class="hljs-string">'Module'</span> });
<span class="hljs-comment">/******/</span> 		}
<span class="hljs-comment">/******/</span> 		<span class="hljs-built_in">Object</span>.defineProperty(exports, <span class="hljs-string">'__esModule'</span>, { <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> });
<span class="hljs-comment">/******/</span> 	};
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// create a fake namespace object</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// mode &amp; 1: value is a module id, require it</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// mode &amp; 2: merge all properties of value into the ns</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// mode &amp; 4: return value when already ns object</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// mode &amp; 8|1: behave like require</span>
<span class="hljs-comment">/******/</span> 	__webpack_require__.t = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, mode</span>) </span>{
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">if</span>(mode &amp; <span class="hljs-number">1</span>) value = __webpack_require__(value);
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">if</span>(mode &amp; <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> value;
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">if</span>((mode &amp; <span class="hljs-number">4</span>) &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; value &amp;&amp; value.__esModule) <span class="hljs-keyword">return</span> value;
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">var</span> ns = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);
<span class="hljs-comment">/******/</span> 		__webpack_require__.r(ns);
<span class="hljs-comment">/******/</span> 		<span class="hljs-built_in">Object</span>.defineProperty(ns, <span class="hljs-string">'default'</span>, { <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: value });
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">if</span>(mode &amp; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value != <span class="hljs-string">'string'</span>) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> value) __webpack_require__.d(ns, key, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{ <span class="hljs-keyword">return</span> value[key]; }.bind(<span class="hljs-literal">null</span>, key));
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">return</span> ns;
<span class="hljs-comment">/******/</span> 	};
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// getDefaultExport function for compatibility with non-harmony modules</span>
<span class="hljs-comment">/******/</span> 	__webpack_require__.n = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module</span>) </span>{
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">var</span> getter = <span class="hljs-built_in">module</span> &amp;&amp; <span class="hljs-built_in">module</span>.__esModule ?
<span class="hljs-comment">/******/</span> 			<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDefault</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>[<span class="hljs-string">'default'</span>]; } :
<span class="hljs-comment">/******/</span> 			<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getModuleExports</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>; };
<span class="hljs-comment">/******/</span> 		__webpack_require__.d(getter, <span class="hljs-string">'a'</span>, getter);
<span class="hljs-comment">/******/</span> 		<span class="hljs-keyword">return</span> getter;
<span class="hljs-comment">/******/</span> 	};
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// Object.prototype.hasOwnProperty.call</span>
<span class="hljs-comment">/******/</span> 	__webpack_require__.o = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">object, property</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(object, property); };
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// __webpack_public_path__</span>
<span class="hljs-comment">/******/</span> 	__webpack_require__.p = <span class="hljs-string">""</span>;
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-comment">// Load entry module and return exports</span>
<span class="hljs-comment">/******/</span> 	<span class="hljs-keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="hljs-number">50</span>);
<span class="hljs-comment">/******/</span> })
<span class="hljs-comment">/************************************************************************/</span>
<span class="hljs-comment">/******/</span> ([
<span class="hljs-comment">/* 0 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/runtime/helpers/interopRequireDefault"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 1 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-3" id="section-3"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">7</span>),
    GraphQLError = _require.GraphQLError;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-4" id="section-4"></a>
</div>
<div class="dox">
<div class="summary">
<p>Creates an error describing invalid application code (GraphQL/Schema)
that must be fixed by the end developer. This should only be used
for local errors that don't affect processing of other user code.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createUserError</span>(<span class="hljs-params">message, locations, nodes</span>) </span>{
  <span class="hljs-keyword">var</span> messageWithLocations = message;

  <span class="hljs-keyword">if</span> (locations != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> printedLocations = printLocations(locations);
    messageWithLocations = printedLocations.length === <span class="hljs-number">0</span> ? message : [message].concat(printedLocations).join(<span class="hljs-string">'\n\n'</span>) + <span class="hljs-string">'\n'</span>;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GraphQLError(messageWithLocations, nodes !== <span class="hljs-literal">null</span> &amp;&amp; nodes !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? nodes : []);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-5" id="section-5"></a>
</div>
<div class="dox">
<div class="summary">
<p>Similar to createUserError but for errors that are <em>not</em> recoverable:
the compiler should not continue to process other inputs because their
validity can't be determined.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createNonRecoverableUserError</span>(<span class="hljs-params">message, locations, nodes</span>) </span>{
  <span class="hljs-keyword">var</span> messageWithLocations = message;

  <span class="hljs-keyword">if</span> (locations != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> printedLocations = printLocations(locations);
    messageWithLocations = printedLocations.length === <span class="hljs-number">0</span> ? message : [message].concat(printedLocations).join(<span class="hljs-string">'\n\n'</span>) + <span class="hljs-string">'\n'</span>;
  }

  <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> GraphQLError(messageWithLocations, nodes !== <span class="hljs-literal">null</span> &amp;&amp; nodes !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? nodes : []);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(error.message);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-6" id="section-6"></a>
</div>
<div class="dox">
<div class="summary">
<p>Creates an error describing a problem with the compiler itself - such
as a broken invariant - that must be fixed within the compiler.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCompilerError</span>(<span class="hljs-params">message, locations, nodes</span>) </span>{
  <span class="hljs-keyword">var</span> messageWithLocations = message;

  <span class="hljs-keyword">if</span> (locations != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> printedLocations = printLocations(locations);
    messageWithLocations = printedLocations.length === <span class="hljs-number">0</span> ? message : [message].concat(printedLocations).join(<span class="hljs-string">'\n\n'</span>) + <span class="hljs-string">'\n'</span>;
  }

  <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">new</span> GraphQLError(<span class="hljs-string">"Internal Error: "</span>.concat(messageWithLocations), nodes !== <span class="hljs-literal">null</span> &amp;&amp; nodes !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? nodes : []);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(error.message);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-7" id="section-7"></a>
</div>
<div class="dox">
<div class="summary">
<p>Iterates over the elements of some iterable value, calling the
supplied callback for each item with a guard for user errors.</p>
</div>
<div class="body">
<p>Non-user errors abort the iteration and are instantly rethrown.
User errors are collected and rethrown at the end, if multiple user errors
occur, a combined error is thrown.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eachWithCombinedError</span>(<span class="hljs-params">iterable, fn</span>) </span>{
  <span class="hljs-keyword">var</span> errors = [];

  <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(iterable),
      _step;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
      <span class="hljs-keyword">var</span> item = _step.value;

      <span class="hljs-keyword">try</span> {
        fn(item);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> GraphQLError) {
          errors.push(error);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">throw</span> error;
        }
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator.f();
  }

  <span class="hljs-keyword">if</span> (errors.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span> (errors.length === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">throw</span> errors[<span class="hljs-number">0</span>];
    }

    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Encountered "</span>.concat(errors.length, <span class="hljs-string">" errors:\n"</span>) + errors.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(error).split(<span class="hljs-string">'\n'</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">line, index</span>) </span>{
        <span class="hljs-keyword">return</span> index === <span class="hljs-number">0</span> ? <span class="hljs-string">"- "</span>.concat(line) : <span class="hljs-string">"  "</span>.concat(line);
      }).join(<span class="hljs-string">'\n'</span>);
    }).join(<span class="hljs-string">'\n'</span>));
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printLocations</span>(<span class="hljs-params">locations</span>) </span>{
  <span class="hljs-keyword">var</span> printedLocations = [];

  <span class="hljs-keyword">var</span> _iterator2 = _createForOfIteratorHelper(locations),
      _step2;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      <span class="hljs-keyword">var</span> location = _step2.value;
      <span class="hljs-keyword">var</span> sourceLocation = location;

      <span class="hljs-keyword">while</span> (sourceLocation.kind === <span class="hljs-string">'Derived'</span>) {
        sourceLocation = sourceLocation.source;
      }

      <span class="hljs-keyword">switch</span> (sourceLocation.kind) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'Source'</span>:
          {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-8" id="section-8"></a>
</div>
<p>source location</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">var</span> prefix = sourceLocation === location ? <span class="hljs-string">'Source: '</span> : <span class="hljs-string">'Source (derived): '</span>;
            printedLocations.push(prefix + highlightSourceAtLocation(sourceLocation.source, getLocation(sourceLocation.source, sourceLocation.start)));
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">'Generated'</span>:
          {
            printedLocations.push(<span class="hljs-string">'Source: (generated)'</span>);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">'Unknown'</span>:
          {
            printedLocations.push(<span class="hljs-string">'Source: (unknown)'</span>);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-attr">default</span>:
          {
            sourceLocation;
            <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"CompilerError: cannot print location '"</span>.concat(<span class="hljs-built_in">String</span>(sourceLocation), <span class="hljs-string">"'."</span>));
          }
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator2.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator2.f();
  }

  <span class="hljs-keyword">return</span> printedLocations;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-9" id="section-9"></a>
</div>
<div class="dox">
<div class="summary">
<p>Render a helpful description of the location of the error in the GraphQL
Source document.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">highlightSourceAtLocation</span>(<span class="hljs-params">source, location</span>) </span>{
  <span class="hljs-keyword">var</span> firstLineColumnOffset = source.locationOffset.column - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> body = whitespace(firstLineColumnOffset) + source.body;
  <span class="hljs-keyword">var</span> lineIndex = location.line - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> lineOffset = source.locationOffset.line - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> lineNum = location.line + lineOffset;
  <span class="hljs-keyword">var</span> columnOffset = location.line === <span class="hljs-number">1</span> ? firstLineColumnOffset : <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> columnNum = location.column + columnOffset;
  <span class="hljs-keyword">var</span> lines = body.split(<span class="hljs-regexp">/\r\n|[\n\r]/g</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.concat(source.name, <span class="hljs-string">" ("</span>).concat(lineNum, <span class="hljs-string">":"</span>).concat(columnNum, <span class="hljs-string">")\n"</span>) + printPrefixedLines([<span class="hljs-comment">// Lines specified like this: ["prefix", "string"],</span>
  [<span class="hljs-string">""</span>.concat(lineNum - <span class="hljs-number">1</span>, <span class="hljs-string">": "</span>), lines[lineIndex - <span class="hljs-number">1</span>]], [<span class="hljs-string">""</span>.concat(lineNum, <span class="hljs-string">": "</span>), lines[lineIndex]], [<span class="hljs-string">''</span>, whitespace(columnNum - <span class="hljs-number">1</span>) + <span class="hljs-string">'^'</span>], [<span class="hljs-string">""</span>.concat(lineNum + <span class="hljs-number">1</span>, <span class="hljs-string">": "</span>), lines[lineIndex + <span class="hljs-number">1</span>]]]);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printPrefixedLines</span>(<span class="hljs-params">lines</span>) </span>{
  <span class="hljs-keyword">var</span> existingLines = lines.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref</span>) </span>{
    <span class="hljs-keyword">var</span> _ = _ref[<span class="hljs-number">0</span>],
        line = _ref[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">return</span> line !== <span class="hljs-literal">undefined</span>;
  });
  <span class="hljs-keyword">var</span> padLen = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">var</span> _iterator3 = _createForOfIteratorHelper(existingLines),
      _step3;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      <span class="hljs-keyword">var</span> _step3$value = _step3.value,
          prefix = _step3$value[<span class="hljs-number">0</span>];
      padLen = <span class="hljs-built_in">Math</span>.max(padLen, prefix.length);
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator3.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator3.f();
  }

  <span class="hljs-keyword">return</span> existingLines.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref2</span>) </span>{
    <span class="hljs-keyword">var</span> prefix = _ref2[<span class="hljs-number">0</span>],
        line = _ref2[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">return</span> lpad(padLen, prefix) + line;
  }).join(<span class="hljs-string">'\n'</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">whitespace</span>(<span class="hljs-params">len</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(len + <span class="hljs-number">1</span>).join(<span class="hljs-string">' '</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lpad</span>(<span class="hljs-params">len, str</span>) </span>{
  <span class="hljs-keyword">return</span> whitespace(len - str.length) + str;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLocation</span>(<span class="hljs-params">source, position</span>) </span>{
  <span class="hljs-keyword">var</span> lineRegexp = <span class="hljs-regexp">/\r\n|[\n\r]/g</span>;
  <span class="hljs-keyword">var</span> line = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> column = position + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> match;

  <span class="hljs-keyword">while</span> ((match = lineRegexp.exec(source.body)) &amp;&amp; match.index &lt; position) {
    line += <span class="hljs-number">1</span>;
    column = position + <span class="hljs-number">1</span> - (match.index + match[<span class="hljs-number">0</span>].length);
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">line</span>: line,
    <span class="hljs-attr">column</span>: column
  };
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">createCompilerError</span>: createCompilerError,
  <span class="hljs-attr">createNonRecoverableUserError</span>: createNonRecoverableUserError,
  <span class="hljs-attr">createUserError</span>: createUserError,
  <span class="hljs-attr">eachWithCombinedError</span>: eachWithCombinedError
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 2 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/runtime/helpers/defineProperty"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 3 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-10" id="section-10"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    eachWithCombinedError = _require.eachWithCombinedError;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-11" id="section-11"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transform</span>(<span class="hljs-params">context, visitor, stateInitializer</span>) </span>{
  <span class="hljs-keyword">var</span> transformer = <span class="hljs-keyword">new</span> Transformer(context, visitor);
  <span class="hljs-keyword">return</span> context.withMutations(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctx</span>) </span>{
    <span class="hljs-keyword">var</span> nextContext = ctx;
    eachWithCombinedError(context.documents(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prevNode</span>) </span>{
      <span class="hljs-keyword">var</span> nextNode;

      <span class="hljs-keyword">if</span> (stateInitializer === <span class="hljs-literal">undefined</span>) {
        nextNode = transformer.visit(prevNode, <span class="hljs-literal">undefined</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> _state = stateInitializer(prevNode);

        <span class="hljs-keyword">if</span> (_state != <span class="hljs-literal">null</span>) {
          nextNode = transformer.visit(prevNode, _state);
        }
      }

      <span class="hljs-keyword">if</span> (!nextNode) {
        nextContext = nextContext.remove(prevNode.name);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextNode !== prevNode) {
        nextContext = nextContext.replace(nextNode);
      }
    });
    <span class="hljs-keyword">return</span> nextContext;
  });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-12" id="section-12"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> Transformer = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Transformer</span>(<span class="hljs-params">context, visitor</span>) </span>{
    <span class="hljs-keyword">this</span>._context = context;
    <span class="hljs-keyword">this</span>._states = [];
    <span class="hljs-keyword">this</span>._visitor = visitor;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-13" id="section-13"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">var</span> _proto = Transformer.prototype;

  _proto.getContext = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContext</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._context;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-14" id="section-14"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  ;

  _proto.visit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span>(<span class="hljs-params">node, state</span>) </span>{
    <span class="hljs-keyword">this</span>._states.push(state);

    <span class="hljs-keyword">var</span> nextNode = <span class="hljs-keyword">this</span>._visit(node);

    <span class="hljs-keyword">this</span>._states.pop();

    <span class="hljs-keyword">return</span> nextNode;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-15" id="section-15"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  ;

  _proto.traverse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">node, state</span>) </span>{
    <span class="hljs-keyword">this</span>._states.push(state);

    <span class="hljs-keyword">var</span> nextNode = <span class="hljs-keyword">this</span>._traverse(node);

    <span class="hljs-keyword">this</span>._states.pop();

    <span class="hljs-keyword">return</span> nextNode;
  };

  _proto._visit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_visit</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">var</span> nodeVisitor = <span class="hljs-keyword">this</span>._visitor[node.kind];

    <span class="hljs-keyword">if</span> (nodeVisitor) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-16" id="section-16"></a>
</div>
<p>If a handler for the kind is defined, it is responsible for calling
<code>traverse</code> to transform children as necessary.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> _state2 = <span class="hljs-keyword">this</span>._getState();

      <span class="hljs-keyword">var</span> nextNode = nodeVisitor.call(<span class="hljs-keyword">this</span>, node, _state2);
      <span class="hljs-keyword">return</span> nextNode;
    } <span class="hljs-comment">// Otherwise traverse is called automatically.</span>


    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._traverse(node);
  };

  _proto._traverse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverse</span>(<span class="hljs-params">prevNode</span>) </span>{
    <span class="hljs-keyword">var</span> nextNode;

    <span class="hljs-keyword">switch</span> (prevNode.kind) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Argument'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, <span class="hljs-literal">null</span>, [<span class="hljs-string">'value'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Literal'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'LocalArgumentDefinition'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'RootArgumentDefinition'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Variable'</span>:
        nextNode = prevNode;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Defer'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'selections'</span>], [<span class="hljs-string">'if'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Stream'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'selections'</span>], [<span class="hljs-string">'if'</span>, <span class="hljs-string">'initialCount'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ClientExtension'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'selections'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Directive'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'args'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ModuleImport'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'selections'</span>]);

        <span class="hljs-keyword">if</span> (!nextNode.selections.length) {
          nextNode = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'FragmentSpread'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'ScalarField'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'args'</span>, <span class="hljs-string">'directives'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineDataFragmentSpread'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'selections'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'LinkedField'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'args'</span>, <span class="hljs-string">'directives'</span>, <span class="hljs-string">'selections'</span>]);

        <span class="hljs-keyword">if</span> (!nextNode.selections.length) {
          nextNode = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ListValue'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'items'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ObjectFieldValue'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, <span class="hljs-literal">null</span>, [<span class="hljs-string">'value'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ObjectValue'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'fields'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Condition'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'directives'</span>, <span class="hljs-string">'selections'</span>], [<span class="hljs-string">'condition'</span>]);

        <span class="hljs-keyword">if</span> (!nextNode.selections.length) {
          nextNode = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineFragment'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'directives'</span>, <span class="hljs-string">'selections'</span>]);

        <span class="hljs-keyword">if</span> (!nextNode.selections.length) {
          nextNode = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Fragment'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Root'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'argumentDefinitions'</span>, <span class="hljs-string">'directives'</span>, <span class="hljs-string">'selections'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Request'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, <span class="hljs-literal">null</span>, [<span class="hljs-string">'fragment'</span>, <span class="hljs-string">'root'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'SplitOperation'</span>:
        nextNode = <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'selections'</span>]);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">default</span>:
        prevNode;
         <span class="hljs-literal">true</span> ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRTransformer: Unknown kind `%s`.'</span>, prevNode.kind) : <span class="hljs-literal">undefined</span> : <span class="hljs-literal">undefined</span>;
    }

    <span class="hljs-keyword">return</span> nextNode;
  };

  _proto._traverseChildren = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverseChildren</span>(<span class="hljs-params">prevNode, pluralKeys, singularKeys</span>) </span>{
    <span class="hljs-keyword">var</span> _this = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> nextNode;
    pluralKeys &amp;&amp; pluralKeys.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
      <span class="hljs-keyword">var</span> prevItems = prevNode[key];

      <span class="hljs-keyword">if</span> (!prevItems) {
        <span class="hljs-keyword">return</span>;
      }

      !<span class="hljs-built_in">Array</span>.isArray(prevItems) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRTransformer: Expected data for `%s` to be an array, got `%s`.'</span>, key, prevItems) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;

      <span class="hljs-keyword">var</span> nextItems = _this._map(prevItems);

      <span class="hljs-keyword">if</span> (nextNode || nextItems !== prevItems) {
        nextNode = nextNode || _objectSpread({}, prevNode);
        nextNode[key] = nextItems;
      }
    });
    singularKeys &amp;&amp; singularKeys.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
      <span class="hljs-keyword">var</span> prevItem = prevNode[key];

      <span class="hljs-keyword">if</span> (!prevItem) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> nextItem = _this._visit(prevItem);

      <span class="hljs-keyword">if</span> (nextNode || nextItem !== prevItem) {
        nextNode = nextNode || _objectSpread({}, prevNode);
        nextNode[key] = nextItem;
      }
    });
    <span class="hljs-keyword">return</span> nextNode || prevNode;
  };

  _proto._map = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_map</span>(<span class="hljs-params">prevItems</span>) </span>{
    <span class="hljs-keyword">var</span> _this2 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> nextItems;
    prevItems.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prevItem, index</span>) </span>{
      <span class="hljs-keyword">var</span> nextItem = _this2._visit(prevItem);

      <span class="hljs-keyword">if</span> (nextItems || nextItem !== prevItem) {
        nextItems = nextItems || prevItems.slice(<span class="hljs-number">0</span>, index);

        <span class="hljs-keyword">if</span> (nextItem) {
          nextItems.push(nextItem);
        }
      }
    });
    <span class="hljs-keyword">return</span> nextItems || prevItems;
  };

  _proto._getState = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_getState</span>(<span class="hljs-params"></span>) </span>{
    !<span class="hljs-keyword">this</span>._states.length ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRTransformer: Expected a current state to be set but found none. '</span> + <span class="hljs-string">'This is usually the result of mismatched number of pushState()/popState() '</span> + <span class="hljs-string">'calls.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._states[<span class="hljs-keyword">this</span>._states.length - <span class="hljs-number">1</span>];
  };

  <span class="hljs-keyword">return</span> Transformer;
}();

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: transform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 4 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/runtime/helpers/toConsumableArray"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 5 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fbjs/lib/invariant"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 6 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-17" id="section-17"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _asyncToGenerator = __webpack_require__(<span class="hljs-number">11</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-18" id="section-18"></a>
</div>
<div class="dox">
<div class="summary">
<p>The compiler profiler builds a &quot;call graph&quot; of high level operations as a
means of tracking time spent over the course of running the compiler.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> enabled = <span class="hljs-literal">false</span>;
<span class="hljs-keyword">var</span> traces = [{
  <span class="hljs-attr">ph</span>: <span class="hljs-string">'M'</span>,
  <span class="hljs-attr">pid</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">tid</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'process_name'</span>,
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'relay-compiler'</span>
  }
}, {
  <span class="hljs-attr">ph</span>: <span class="hljs-string">'M'</span>,
  <span class="hljs-attr">pid</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">tid</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'thread_name'</span>,
  <span class="hljs-attr">args</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'relay-compiler'</span>
  }
}];
<span class="hljs-keyword">var</span> stack = [];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enable</span>(<span class="hljs-params"></span>) </span>{
  enabled = <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTraces</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> traces;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-19" id="section-19"></a>
</div>
<div class="dox">
<div class="summary">
<p>Run the provided function as part of a stack profile.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">name, fn</span>) </span>{
  <span class="hljs-keyword">return</span> instrument(fn, name)();
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-20" id="section-20"></a>
</div>
<div class="dox">
<div class="summary">
<p>Run the provided async function as part context in a stack profile.
See instrumentAsyncContext() for limitations and usage notes.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncContext</span>(<span class="hljs-params">name, fn</span>) </span>{
  <span class="hljs-keyword">return</span> instrumentAsyncContext(fn, name)();
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-21" id="section-21"></a>
</div>
<div class="dox">
<div class="summary">
<p>Wait for the provided async operation as an async profile.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitFor</span>(<span class="hljs-params">name, fn</span>) </span>{
  <span class="hljs-keyword">return</span> instrumentWait(fn, name)();
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-22" id="section-22"></a>
</div>
<div class="dox">
<div class="summary">
<p>Return a new instrumented sync function to be part of a stack profile.</p>
</div>
<div class="body">
<p>This instruments synchronous functions to be displayed in a stack
visualization. To instrument async functions, see instrumentAsyncContext()
and instrumentWait().</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instrument</span>(<span class="hljs-params">fn, name</span>) </span>{
  <span class="hljs-keyword">var</span> _ref;

  <span class="hljs-keyword">if</span> (!enabled) {
    <span class="hljs-keyword">return</span> fn;
  }

  <span class="hljs-keyword">var</span> profileName = (_ref = name !== <span class="hljs-literal">null</span> &amp;&amp; name !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? name : <span class="hljs-comment">// $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any</span>
  fn.displayName) !== <span class="hljs-literal">null</span> &amp;&amp; _ref !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _ref : fn.name;

  <span class="hljs-keyword">var</span> instrumented = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instrumented</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> traceId = start(profileName);

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    } <span class="hljs-keyword">finally</span> {
      end(traceId);
    }
  };

  instrumented.displayName = profileName;
  <span class="hljs-keyword">return</span> instrumented;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-23" id="section-23"></a>
</div>
<div class="dox">
<div class="summary">
<p>Return a new instrumented async function which provides context for a stack.</p>
</div>
<div class="body">
<p>Because the resulting profiling information will be incorporated into a
stack visualization, the instrumented function must represent a distinct
region of time which does not overlap with any other async context.</p>
<p>In other words, functions instrumented with instrumentAsyncContext must not
run in parallel via Promise.all().</p>
<p>To instrument functions which will run in parallel, use instrumentWait().</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instrumentAsyncContext</span>(<span class="hljs-params">fn, name</span>) </span>{
  <span class="hljs-keyword">var</span> _ref2;

  <span class="hljs-keyword">if</span> (!enabled) {
    <span class="hljs-keyword">return</span> fn;
  }

  <span class="hljs-keyword">var</span> profileName = (_ref2 = name !== <span class="hljs-literal">null</span> &amp;&amp; name !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? name : <span class="hljs-comment">// $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any</span>
  fn.displayName) !== <span class="hljs-literal">null</span> &amp;&amp; _ref2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _ref2 : fn.name;

  <span class="hljs-keyword">var</span> instrumented = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _instrumented = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> traceId = start(profileName);

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span> fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      } <span class="hljs-keyword">finally</span> {
        end(traceId);
      }
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instrumented</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> _instrumented.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    <span class="hljs-keyword">return</span> instrumented;
  }();

  instrumented.displayName = profileName;
  <span class="hljs-keyword">return</span> instrumented;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-24" id="section-24"></a>
</div>
<div class="dox">
<div class="summary">
<p>Return a new instrumented function which performs an awaited async operation.</p>
</div>
<div class="body">
<p>The instrumented function is not included in the overall run time of the
compiler, instead it captures the time waiting on some asynchronous external
resource such as network or filesystem which are often run in parallel.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instrumentWait</span>(<span class="hljs-params">fn, name</span>) </span>{
  <span class="hljs-keyword">var</span> _ref3;

  <span class="hljs-keyword">if</span> (!enabled) {
    <span class="hljs-keyword">return</span> fn;
  }

  <span class="hljs-keyword">var</span> profileName = (_ref3 = name !== <span class="hljs-literal">null</span> &amp;&amp; name !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? name : <span class="hljs-comment">// $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any</span>
  fn.displayName) !== <span class="hljs-literal">null</span> &amp;&amp; _ref3 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _ref3 : fn.name;

  <span class="hljs-keyword">var</span> instrumented = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _instrumented2 = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> traceId = startWait(profileName);

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span> fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      } <span class="hljs-keyword">finally</span> {
        end(traceId);
      }
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instrumented</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> _instrumented2.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    <span class="hljs-keyword">return</span> instrumented;
  }();

  instrumented.displayName = profileName;
  <span class="hljs-keyword">return</span> instrumented;
}

<span class="hljs-keyword">var</span> T_ZERO = process.hrtime(); <span class="hljs-comment">// Return a Uint32 of microtime duration since program start.</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">microtime</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> hrtime = process.hrtime(T_ZERO); <span class="hljs-comment">// eslint-disable-next-line no-bitwise</span>

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> | hrtime[<span class="hljs-number">0</span>] * <span class="hljs-number">1e6</span> + <span class="hljs-built_in">Math</span>.round(hrtime[<span class="hljs-number">1</span>] / <span class="hljs-number">1e3</span>);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-25" id="section-25"></a>
</div>
<div class="dox">
<div class="summary">
<p>Start a stack profile with a particular name, returns an ID to pass to end().</p>
</div>
<div class="body">
<p>Other profiles may start before this one ends, which will be represented as
nested operations, however all nested operations must end before this ends.</p>
<p>In particular, be careful to end after errors.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">var</span> beginTrace = {
    <span class="hljs-attr">ph</span>: <span class="hljs-string">'B'</span>,
    <span class="hljs-attr">name</span>: name,
    <span class="hljs-attr">pid</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">tid</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">ts</span>: microtime()
  };
  traces.push(beginTrace);
  stack.push(beginTrace);
  <span class="hljs-keyword">return</span> traces.length - <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">var</span> asyncID = <span class="hljs-number">0</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-26" id="section-26"></a>
</div>
<div class="dox">
<div class="summary">
<p>Start an async wait profile with a particular name, returns an ID to pass
to end().</p>
</div>
<div class="body">
<p>Other profiles may start before this one ends, which will be represented as
nested operations, however all nested operations must end before this ends.</p>
<p>In particular, be careful to end after errors.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startWait</span>(<span class="hljs-params">name</span>) </span>{
  traces.push({
    <span class="hljs-attr">ph</span>: <span class="hljs-string">'b'</span>,
    <span class="hljs-attr">name</span>: name,
    <span class="hljs-attr">cat</span>: <span class="hljs-string">'wait'</span>,
    <span class="hljs-attr">id</span>: asyncID++,
    <span class="hljs-attr">pid</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">tid</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">ts</span>: microtime()
  });
  <span class="hljs-keyword">return</span> traces.length - <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">end</span>(<span class="hljs-params">traceIdx</span>) </span>{
  <span class="hljs-keyword">var</span> trace = traces[traceIdx];

  <span class="hljs-keyword">if</span> (trace.ph === <span class="hljs-string">'b'</span>) {
    traces.push({
      <span class="hljs-attr">ph</span>: <span class="hljs-string">'e'</span>,
      <span class="hljs-attr">cat</span>: trace.cat,
      <span class="hljs-attr">name</span>: trace.name,
      <span class="hljs-attr">id</span>: trace.id,
      <span class="hljs-attr">pid</span>: trace.pid,
      <span class="hljs-attr">tid</span>: trace.tid,
      <span class="hljs-attr">ts</span>: microtime()
    });
    <span class="hljs-keyword">return</span>;
  }

  !(trace.ph === <span class="hljs-string">'B'</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'Begin trace phase'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  !(stack.pop() === trace) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'GraphQLCompilerProfiler: The profile trace %s ended before nested traces. '</span> + <span class="hljs-string">'If it is async, try using Profile.waitFor or Profile.profileWait.'</span>, trace.name) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> prevTrace = traces[traces.length - <span class="hljs-number">1</span>];

  <span class="hljs-keyword">if</span> (trace === prevTrace) {
    traces[traceIdx] = {
      <span class="hljs-attr">ph</span>: <span class="hljs-string">'X'</span>,
      <span class="hljs-attr">name</span>: trace.name,
      <span class="hljs-attr">pid</span>: trace.pid,
      <span class="hljs-attr">tid</span>: trace.tid,
      <span class="hljs-attr">ts</span>: trace.ts,
      <span class="hljs-attr">dur</span>: microtime() - trace.ts
    };
    <span class="hljs-keyword">return</span>;
  }

  traces.push({
    <span class="hljs-attr">ph</span>: <span class="hljs-string">'E'</span>,
    <span class="hljs-attr">name</span>: trace.name,
    <span class="hljs-attr">pid</span>: trace.pid,
    <span class="hljs-attr">tid</span>: trace.tid,
    <span class="hljs-attr">ts</span>: microtime()
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">enable</span>: enable,
  <span class="hljs-attr">getTraces</span>: getTraces,
  <span class="hljs-attr">run</span>: run,
  <span class="hljs-attr">asyncContext</span>: asyncContext,
  <span class="hljs-attr">waitFor</span>: waitFor,
  <span class="hljs-attr">instrument</span>: instrument,
  <span class="hljs-attr">instrumentAsyncContext</span>: instrumentAsyncContext,
  <span class="hljs-attr">instrumentWait</span>: instrumentWait,
  <span class="hljs-attr">start</span>: start,
  <span class="hljs-attr">startWait</span>: startWait,
  <span class="hljs-attr">end</span>: end
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 7 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"graphql"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 8 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 9 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-27" id="section-27"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError;

<span class="hljs-keyword">var</span> ID = <span class="hljs-string">'id'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-28" id="section-28"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isExecutableDefinitionAST</span>(<span class="hljs-params">ast</span>) </span>{
  <span class="hljs-keyword">return</span> ast.kind === <span class="hljs-string">'FragmentDefinition'</span> || ast.kind === <span class="hljs-string">'OperationDefinition'</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-29" id="section-29"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSchemaDefinitionAST</span>(<span class="hljs-params">ast</span>) </span>{
  <span class="hljs-keyword">return</span> ast.kind === <span class="hljs-string">'SchemaDefinition'</span> || ast.kind === <span class="hljs-string">'ScalarTypeDefinition'</span> || ast.kind === <span class="hljs-string">'ObjectTypeDefinition'</span> || ast.kind === <span class="hljs-string">'InterfaceTypeDefinition'</span> || ast.kind === <span class="hljs-string">'UnionTypeDefinition'</span> || ast.kind === <span class="hljs-string">'EnumTypeDefinition'</span> || ast.kind === <span class="hljs-string">'InputObjectTypeDefinition'</span> || ast.kind === <span class="hljs-string">'DirectiveDefinition'</span> || ast.kind === <span class="hljs-string">'ScalarTypeExtension'</span> || ast.kind === <span class="hljs-string">'ObjectTypeExtension'</span> || ast.kind === <span class="hljs-string">'InterfaceTypeExtension'</span> || ast.kind === <span class="hljs-string">'UnionTypeExtension'</span> || ast.kind === <span class="hljs-string">'EnumTypeExtension'</span> || ast.kind === <span class="hljs-string">'InputObjectTypeExtension'</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-30" id="section-30"></a>
</div>
<div class="dox">
<div class="summary">
<p>Generates an id field on the given type.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateIDField</span>(<span class="hljs-params">schema, type</span>) </span>{
  <span class="hljs-keyword">var</span> idField = schema.getFieldByName(type, <span class="hljs-string">'id'</span>);

  <span class="hljs-keyword">if</span> (idField == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> createCompilerError(<span class="hljs-string">"Expected an 'id' field on type '"</span>.concat(schema.getTypeString(type), <span class="hljs-string">"'."</span>));
  }

  <span class="hljs-keyword">var</span> idType = schema.assertScalarFieldType(schema.getFieldType(idField));
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'ScalarField'</span>,
    <span class="hljs-attr">alias</span>: ID,
    <span class="hljs-attr">args</span>: [],
    <span class="hljs-attr">directives</span>: [],
    <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">loc</span>: {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Generated'</span>
    },
    <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">name</span>: ID,
    <span class="hljs-attr">type</span>: idType
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNullableBooleanInput</span>(<span class="hljs-params">schema</span>) </span>{
  <span class="hljs-keyword">return</span> schema.assertInputType(schema.expectBooleanType());
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNonNullBooleanInput</span>(<span class="hljs-params">schema</span>) </span>{
  <span class="hljs-keyword">return</span> schema.assertInputType(schema.getNonNullType(schema.expectBooleanType()));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNullableStringInput</span>(<span class="hljs-params">schema</span>) </span>{
  <span class="hljs-keyword">return</span> schema.assertInputType(schema.expectStringType());
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNonNullStringInput</span>(<span class="hljs-params">schema</span>) </span>{
  <span class="hljs-keyword">return</span> schema.assertInputType(schema.getNonNullType(schema.expectStringType()));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNullableIdInput</span>(<span class="hljs-params">schema</span>) </span>{
  <span class="hljs-keyword">return</span> schema.assertInputType(schema.expectIdType());
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNonNullIdInput</span>(<span class="hljs-params">schema</span>) </span>{
  <span class="hljs-keyword">return</span> schema.assertInputType(schema.getNonNullType(schema.expectIdType()));
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">generateIDField</span>: generateIDField,
  <span class="hljs-attr">isExecutableDefinitionAST</span>: isExecutableDefinitionAST,
  <span class="hljs-attr">isSchemaDefinitionAST</span>: isSchemaDefinitionAST,
  <span class="hljs-attr">getNullableBooleanInput</span>: getNullableBooleanInput,
  <span class="hljs-attr">getNonNullBooleanInput</span>: getNonNullBooleanInput,
  <span class="hljs-attr">getNullableStringInput</span>: getNullableStringInput,
  <span class="hljs-attr">getNonNullStringInput</span>: getNonNullStringInput,
  <span class="hljs-attr">getNullableIdInput</span>: getNullableIdInput,
  <span class="hljs-attr">getNonNullIdInput</span>: getNonNullIdInput
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 10 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"relay-runtime"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 11 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/runtime/helpers/asyncToGenerator"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 12 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 13 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"crypto"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 14 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"immutable"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 15 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-31" id="section-31"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-32" id="section-32"></a>
</div>
<div class="dox">
<div class="summary">
<p>Partitions an array given a predicate. All elements satisfying the predicate
are part of the first returned array, and all elements that don't are in the
second.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partitionArray</span>(<span class="hljs-params">array, predicate</span>) </span>{
  <span class="hljs-keyword">var</span> first = [];
  <span class="hljs-keyword">var</span> second = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) {
    <span class="hljs-keyword">var</span> item = array[i];

    <span class="hljs-keyword">if</span> (predicate(item)) {
      first.push(item);
    } <span class="hljs-keyword">else</span> {
      second.push(item);
    }
  }

  <span class="hljs-keyword">return</span> [first, second];
}

<span class="hljs-built_in">module</span>.exports = partitionArray;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 16 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"nullthrows"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 17 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-33" id="section-33"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateAbstractTypeRefinementKey</span>(<span class="hljs-params">schema, type</span>) </span>{
  <span class="hljs-keyword">if</span> (!schema.isAbstractType(type)) {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Expected an abstract type'</span>);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-string">"__is"</span>.concat(schema.getTypeString(type));
}

<span class="hljs-built_in">module</span>.exports = generateAbstractTypeRefinementKey;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 18 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-34" id="section-34"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">7</span>),
    visit = _require.visit;

<span class="hljs-keyword">var</span> NodeKeys = {
  <span class="hljs-attr">Argument</span>: [<span class="hljs-string">'value'</span>],
  <span class="hljs-attr">ClientExtension</span>: [<span class="hljs-string">'selections'</span>],
  <span class="hljs-attr">Condition</span>: [<span class="hljs-string">'condition'</span>, <span class="hljs-string">'selections'</span>],
  <span class="hljs-attr">Defer</span>: [<span class="hljs-string">'selections'</span>, <span class="hljs-string">'if'</span>],
  <span class="hljs-attr">Directive</span>: [<span class="hljs-string">'args'</span>],
  <span class="hljs-attr">Fragment</span>: [<span class="hljs-string">'argumentDefinitions'</span>, <span class="hljs-string">'directives'</span>, <span class="hljs-string">'selections'</span>],
  <span class="hljs-attr">FragmentSpread</span>: [<span class="hljs-string">'args'</span>, <span class="hljs-string">'directives'</span>],
  <span class="hljs-attr">InlineDataFragmentSpread</span>: [<span class="hljs-string">'selections'</span>],
  <span class="hljs-attr">InlineFragment</span>: [<span class="hljs-string">'directives'</span>, <span class="hljs-string">'selections'</span>],
  <span class="hljs-attr">LinkedField</span>: [<span class="hljs-string">'args'</span>, <span class="hljs-string">'directives'</span>, <span class="hljs-string">'selections'</span>],
  <span class="hljs-attr">Literal</span>: [],
  <span class="hljs-attr">LocalArgumentDefinition</span>: [],
  <span class="hljs-attr">ModuleImport</span>: [<span class="hljs-string">'selections'</span>],
  <span class="hljs-attr">Request</span>: [<span class="hljs-string">'fragment'</span>, <span class="hljs-string">'root'</span>],
  <span class="hljs-attr">Root</span>: [<span class="hljs-string">'argumentDefinitions'</span>, <span class="hljs-string">'directives'</span>, <span class="hljs-string">'selections'</span>],
  <span class="hljs-attr">RootArgumentDefinition</span>: [],
  <span class="hljs-attr">ScalarField</span>: [<span class="hljs-string">'args'</span>, <span class="hljs-string">'directives'</span>],
  <span class="hljs-attr">SplitOperation</span>: [<span class="hljs-string">'selections'</span>],
  <span class="hljs-attr">Stream</span>: [<span class="hljs-string">'selections'</span>, <span class="hljs-string">'if'</span>, <span class="hljs-string">'initialCount'</span>],
  <span class="hljs-attr">Variable</span>: []
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitIR</span>(<span class="hljs-params">root, visitor</span>) </span>{
  <span class="hljs-keyword">return</span> visit(root, visitor, NodeKeys);
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">visit</span>: visitIR
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 19 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-35" id="section-35"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-36" id="section-36"></a>
</div>
<p>Copy of Variables type from '../../../react-relay/classic/tools/RelayTypes'
Duplicating here rather than importing it since we can't take on a dependency
outside of relay-compiler.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLiteralArgumentValues</span>(<span class="hljs-params">args</span>) </span>{
  <span class="hljs-keyword">var</span> values = {};
  args.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">if</span> (arg.value.kind === <span class="hljs-string">'Literal'</span>) {
      values[arg.name] = arg.value.value;
    }
  });
  <span class="hljs-keyword">return</span> values;
}

<span class="hljs-built_in">module</span>.exports = getLiteralArgumentValues;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 20 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-37" id="section-37"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> CompilerContext = __webpack_require__(<span class="hljs-number">23</span>);

<span class="hljs-keyword">var</span> IRVisitor = __webpack_require__(<span class="hljs-number">18</span>);

<span class="hljs-keyword">var</span> SchemaUtils = __webpack_require__(<span class="hljs-number">9</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-38" id="section-38"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns a transformed version of the input context where each document's
argument definitions are updated to accurately describe the root variables
used (or reachable) from that document:</p>
<ul>
<li>Fragment argument definitions are updated to include local argument
definitions and any root variables that are referenced
by the fragment (or any fragments it transitively spreads).</li>
<li>Root argument definitions are updated to reflect the variables
referenced locally and all root variables referenced by any
fragments it (transitively) spreads.</li>
</ul>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inferRootArgumentDefinitions</span>(<span class="hljs-params">context</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-39" id="section-39"></a>
</div>
<p>This transform does two main tasks:</p>
<ul>
<li>Determine the set of root variables referenced locally in each
fragment. Note that RootArgumentDefinitions in the fragment's
argumentDefinitions can contain spurious entries for legacy
reasons. Instead of using those the fragment is traversed
to reanalyze variable usage.</li>
<li>Determine the set of root variables that are transitively referenced
by each fragment, ie the union of all root variables used in the
fragment and any fragments it transitively spreads.
Cache fragments as they are transformed to avoid duplicate processing.
Because @argument values don't matter (only variable names/types),
each reachable fragment only has to be checked once.</li>
</ul>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> transformed = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">var</span> nextContext = <span class="hljs-keyword">new</span> CompilerContext(context.getSchema());
  <span class="hljs-keyword">return</span> nextContext.addAll(<span class="hljs-built_in">Array</span>.from(context.documents(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">switch</span> (node.kind) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Fragment'</span>:
        {
          <span class="hljs-keyword">var</span> argumentDefinitions = transformFragmentArguments(context, transformed, node);
          <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, node), {}, {
            <span class="hljs-attr">argumentDefinitions</span>: <span class="hljs-built_in">Array</span>.from(argumentDefinitions.values())
          });
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Root'</span>:
        {
          <span class="hljs-keyword">return</span> transformRoot(context, transformed, node);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">'SplitOperation'</span>:
        {
          <span class="hljs-keyword">return</span> node;
        }

      <span class="hljs-attr">default</span>:
        {
          node;
          <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"inferRootArgumentDefinitions: Unsupported kind '"</span>.concat(node.kind, <span class="hljs-string">"'."</span>));
        }
    }
  }));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformRoot</span>(<span class="hljs-params">context, transformed, root</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-40" id="section-40"></a>
</div>
<p>Ignore argument definitions, determine what root variables are
transitively referenced</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> argumentDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">var</span> localArgumentDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(root.argumentDefinitions.entries()),
      _step;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
      <span class="hljs-keyword">var</span> _step$value = _step.value,
          name = _step$value[<span class="hljs-number">0</span>],
          argDef = _step$value[<span class="hljs-number">1</span>];

      <span class="hljs-keyword">if</span> (argDef.kind === <span class="hljs-string">'LocalArgumentDefinition'</span>) {
        localArgumentDefinitions.set(name, argDef);
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator.f();
  }

  visit(context, transformed, argumentDefinitions, root);
  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, root), {}, {
    <span class="hljs-attr">argumentDefinitions</span>: <span class="hljs-built_in">Array</span>.from(argumentDefinitions.values(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argDef</span>) </span>{
      <span class="hljs-keyword">var</span> _localDefinition$type, _localDefinition$defa;

      <span class="hljs-keyword">if</span> (argDef.kind !== <span class="hljs-string">'RootArgumentDefinition'</span>) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"inferRootArgumentDefinitions: Expected inferred variable '$"</span>.concat(argDef.name, <span class="hljs-string">"' to be a root variables."</span>), [argDef.loc]);
      }

      <span class="hljs-keyword">var</span> localDefinition = localArgumentDefinitions.get(argDef.name);
      <span class="hljs-keyword">var</span> type = (_localDefinition$type = localDefinition === <span class="hljs-literal">null</span> || localDefinition === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : localDefinition.type) !== <span class="hljs-literal">null</span> &amp;&amp; _localDefinition$type !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _localDefinition$type : argDef.type;
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">defaultValue</span>: (_localDefinition$defa = localDefinition === <span class="hljs-literal">null</span> || localDefinition === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : localDefinition.defaultValue) !== <span class="hljs-literal">null</span> &amp;&amp; _localDefinition$defa !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _localDefinition$defa : <span class="hljs-literal">null</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'LocalArgumentDefinition'</span>,
        <span class="hljs-attr">loc</span>: argDef.loc,
        <span class="hljs-attr">name</span>: argDef.name,
        <span class="hljs-attr">type</span>: type
      };
    })
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformFragmentArguments</span>(<span class="hljs-params">context, transformed, fragment</span>) </span>{
  <span class="hljs-keyword">var</span> name = fragment.name;
  <span class="hljs-keyword">var</span> transformedArguments = transformed.get(name);

  <span class="hljs-keyword">if</span> (transformedArguments != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> transformedArguments;
  } <span class="hljs-comment">// Start with only the explicitly defined local arguments, recover the</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-41" id="section-41"></a>
</div>
<p>correct set of root variables excluding invalid @arguments values.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">var</span> argumentDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  fragment.argumentDefinitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argDef</span>) </span>{
    <span class="hljs-keyword">if</span> (argDef.kind === <span class="hljs-string">'LocalArgumentDefinition'</span>) {
      argumentDefinitions.set(argDef.name, argDef);
    }
  }); <span class="hljs-comment">// Break cycles by initially caching a version that only has local</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-42" id="section-42"></a>
</div>
<p>arguments. If the current fragment is reached again, it won't have
any root variables to add to its parents. The traversal below will
find any root variables and update the cached version of the
fragment.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  transformed.set(name, argumentDefinitions);
  visit(context, transformed, argumentDefinitions, fragment);
  transformed.set(name, argumentDefinitions);
  <span class="hljs-keyword">return</span> argumentDefinitions;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span>(<span class="hljs-params">context, transformed, argumentDefinitions, node</span>) </span>{
  IRVisitor.visit(node, {
    <span class="hljs-attr">FragmentSpread</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FragmentSpread</span>(<span class="hljs-params">fragmentSpread</span>) </span>{
      <span class="hljs-keyword">var</span> fragment = context.getFragment(fragmentSpread.name, fragmentSpread.loc);
      <span class="hljs-keyword">var</span> referencedFragmentArguments = transformFragmentArguments(context, transformed, fragment); <span class="hljs-comment">// Detect root variables being passed as the value of @arguments;</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-43" id="section-43"></a>
</div>
<p>recover the expected type from the corresponding argument definitions.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      fragmentSpread.args.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
        <span class="hljs-keyword">var</span> argDef = referencedFragmentArguments.get(arg.name);

        <span class="hljs-keyword">if</span> (argDef != <span class="hljs-literal">null</span> &amp;&amp; arg.value.kind === <span class="hljs-string">'Variable'</span> &amp;&amp; !argumentDefinitions.has(arg.value.variableName)) {
          argumentDefinitions.set(arg.value.variableName, {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'RootArgumentDefinition'</span>,
            <span class="hljs-attr">loc</span>: {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
              <span class="hljs-attr">source</span>: arg.loc
            },
            <span class="hljs-attr">name</span>: arg.value.variableName,
            <span class="hljs-attr">type</span>: argDef.type
          });
        }
      }); <span class="hljs-comment">// Merge any root variables referenced by the spread fragment</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-44" id="section-44"></a>
</div>
<p>into this (parent) fragment's arguments.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">var</span> _iterator2 = _createForOfIteratorHelper(referencedFragmentArguments.values()),
          _step2;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">for</span> (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          <span class="hljs-keyword">var</span> argDef = _step2.value;

          <span class="hljs-keyword">if</span> (argDef.kind === <span class="hljs-string">'RootArgumentDefinition'</span>) {
            argumentDefinitions.set(argDef.name, argDef);
          }
        }
      } <span class="hljs-keyword">catch</span> (err) {
        _iterator2.e(err);
      } <span class="hljs-keyword">finally</span> {
        _iterator2.f();
      }
    },
    <span class="hljs-attr">Argument</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Argument</span>(<span class="hljs-params">argument</span>) </span>{
      <span class="hljs-keyword">if</span> (argument.value.kind === <span class="hljs-string">'Literal'</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">var</span> values = [argument.value];

      <span class="hljs-keyword">while</span> (values.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> currentValue = values.pop();

        <span class="hljs-keyword">if</span> (currentValue.kind === <span class="hljs-string">'Variable'</span>) {
          <span class="hljs-keyword">var</span> _currentValue$type;

          <span class="hljs-keyword">var</span> type = (_currentValue$type = currentValue.type) !== <span class="hljs-literal">null</span> &amp;&amp; _currentValue$type !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _currentValue$type : argument.type;

          <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">continue</span>;
          }

          <span class="hljs-keyword">if</span> (!argumentDefinitions.has(currentValue.variableName)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-45" id="section-45"></a>
</div>
<p>root variable</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            argumentDefinitions.set(currentValue.variableName, {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">'RootArgumentDefinition'</span>,
              <span class="hljs-attr">loc</span>: {
                <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
                <span class="hljs-attr">source</span>: argument.loc
              },
              <span class="hljs-attr">name</span>: currentValue.variableName,
              <span class="hljs-attr">type</span>: type
            });
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentValue.kind === <span class="hljs-string">'ObjectValue'</span>) {
          currentValue.fields.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fieldValue</span>) </span>{
            <span class="hljs-keyword">if</span> (fieldValue.value.kind !== <span class="hljs-string">'Literal'</span>) {
              values.push(fieldValue.value);
            }
          });
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentValue.kind === <span class="hljs-string">'ListValue'</span>) {
          currentValue.items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">listValue</span>) </span>{
            <span class="hljs-keyword">if</span> (listValue.kind !== <span class="hljs-string">'Literal'</span>) {
              values.push(listValue);
            }
          });
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    },
    <span class="hljs-attr">Condition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Condition</span>(<span class="hljs-params">condition</span>) </span>{
      <span class="hljs-keyword">var</span> _variable$type;

      <span class="hljs-keyword">var</span> variable = condition.condition;

      <span class="hljs-keyword">if</span> (variable.kind !== <span class="hljs-string">'Variable'</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> type = (_variable$type = variable.type) !== <span class="hljs-literal">null</span> &amp;&amp; _variable$type !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _variable$type : SchemaUtils.getNonNullBooleanInput(context.getSchema());

      <span class="hljs-keyword">if</span> (!argumentDefinitions.has(variable.variableName)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-46" id="section-46"></a>
</div>
<p>root variable</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        argumentDefinitions.set(variable.variableName, {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'RootArgumentDefinition'</span>,
          <span class="hljs-attr">loc</span>: {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
            <span class="hljs-attr">source</span>: variable.loc
          },
          <span class="hljs-attr">name</span>: variable.variableName,
          <span class="hljs-attr">type</span>: type
        });
      }
    },
    <span class="hljs-attr">Defer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Defer</span>(<span class="hljs-params">defer</span>) </span>{
      <span class="hljs-keyword">var</span> _variable$type2;

      <span class="hljs-keyword">var</span> variable = defer[<span class="hljs-string">"if"</span>];

      <span class="hljs-keyword">if</span> (variable == <span class="hljs-literal">null</span> || variable.kind !== <span class="hljs-string">'Variable'</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> type = (_variable$type2 = variable.type) !== <span class="hljs-literal">null</span> &amp;&amp; _variable$type2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _variable$type2 : SchemaUtils.getNonNullBooleanInput(context.getSchema());

      <span class="hljs-keyword">if</span> (!argumentDefinitions.has(variable.variableName)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-47" id="section-47"></a>
</div>
<p>root variable</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        argumentDefinitions.set(variable.variableName, {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'RootArgumentDefinition'</span>,
          <span class="hljs-attr">loc</span>: {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
            <span class="hljs-attr">source</span>: variable.loc
          },
          <span class="hljs-attr">name</span>: variable.variableName,
          <span class="hljs-attr">type</span>: type
        });
      }
    },
    <span class="hljs-attr">Stream</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stream</span>(<span class="hljs-params">stream</span>) </span>{
      [stream[<span class="hljs-string">"if"</span>], stream.initialCount].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">variable</span>) </span>{
        <span class="hljs-keyword">var</span> _variable$type3;

        <span class="hljs-keyword">if</span> (variable == <span class="hljs-literal">null</span> || variable.kind !== <span class="hljs-string">'Variable'</span>) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> type = (_variable$type3 = variable.type) !== <span class="hljs-literal">null</span> &amp;&amp; _variable$type3 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _variable$type3 : SchemaUtils.getNonNullBooleanInput(context.getSchema());

        <span class="hljs-keyword">if</span> (!argumentDefinitions.has(variable.variableName)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-48" id="section-48"></a>
</div>
<p>root variable</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          argumentDefinitions.set(variable.variableName, {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'RootArgumentDefinition'</span>,
            <span class="hljs-attr">loc</span>: {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
              <span class="hljs-attr">source</span>: variable.loc
            },
            <span class="hljs-attr">name</span>: variable.variableName,
            <span class="hljs-attr">type</span>: type
          });
        }
      });
    },
    <span class="hljs-attr">LinkedField</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LinkedField</span>(<span class="hljs-params">field</span>) </span>{
      <span class="hljs-keyword">if</span> (!field.handles) {
        <span class="hljs-keyword">return</span>;
      }

      field.handles.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">handle</span>) </span>{
        <span class="hljs-keyword">var</span> _variable$type4;

        <span class="hljs-keyword">var</span> variable = handle.dynamicKey;

        <span class="hljs-keyword">if</span> (variable == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> type = (_variable$type4 = variable.type) !== <span class="hljs-literal">null</span> &amp;&amp; _variable$type4 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _variable$type4 : SchemaUtils.getNullableStringInput(context.getSchema());

        <span class="hljs-keyword">if</span> (!argumentDefinitions.has(variable.variableName)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-49" id="section-49"></a>
</div>
<p>root variable</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          argumentDefinitions.set(variable.variableName, {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'RootArgumentDefinition'</span>,
            <span class="hljs-attr">loc</span>: {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
              <span class="hljs-attr">source</span>: variable.loc
            },
            <span class="hljs-attr">name</span>: variable.variableName,
            <span class="hljs-attr">type</span>: type
          });
        }
      });
    }
  });
}

<span class="hljs-built_in">module</span>.exports = inferRootArgumentDefinitions;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 21 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-50" id="section-50"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildFragmentSpread</span>(<span class="hljs-params">fragment</span>) </span>{
  <span class="hljs-keyword">var</span> args = [];

  <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(fragment.argumentDefinitions),
      _step;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
      <span class="hljs-keyword">var</span> argDef = _step.value;

      <span class="hljs-keyword">if</span> (argDef.kind !== <span class="hljs-string">'LocalArgumentDefinition'</span>) {
        <span class="hljs-keyword">continue</span>;
      }

      args.push({
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
        <span class="hljs-attr">loc</span>: {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
          <span class="hljs-attr">source</span>: argDef.loc
        },
        <span class="hljs-attr">name</span>: argDef.name,
        <span class="hljs-attr">type</span>: argDef.type,
        <span class="hljs-attr">value</span>: {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Variable'</span>,
          <span class="hljs-attr">loc</span>: {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
            <span class="hljs-attr">source</span>: argDef.loc
          },
          <span class="hljs-attr">variableName</span>: argDef.name,
          <span class="hljs-attr">type</span>: argDef.type
        }
      });
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator.f();
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">args</span>: args,
    <span class="hljs-attr">directives</span>: [],
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'FragmentSpread'</span>,
    <span class="hljs-attr">loc</span>: {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
      <span class="hljs-attr">source</span>: fragment.loc
    },
    <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">name</span>: fragment.name
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildOperationArgumentDefinitions</span>(<span class="hljs-params">argumentDefinitions</span>) </span>{
  <span class="hljs-keyword">var</span> localArgumentDefinitions = argumentDefinitions.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argDef</span>) </span>{
    <span class="hljs-keyword">if</span> (argDef.kind === <span class="hljs-string">'LocalArgumentDefinition'</span>) {
      <span class="hljs-keyword">return</span> argDef;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'LocalArgumentDefinition'</span>,
        <span class="hljs-attr">name</span>: argDef.name,
        <span class="hljs-attr">type</span>: argDef.type,
        <span class="hljs-attr">defaultValue</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">loc</span>: argDef.loc
      };
    }
  });
  localArgumentDefinitions.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> a.name &lt; b.name ? <span class="hljs-number">-1</span> : a.name &gt; b.name ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
  });
  <span class="hljs-keyword">return</span> localArgumentDefinitions;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">buildFragmentSpread</span>: buildFragmentSpread,
  <span class="hljs-attr">buildOperationArgumentDefinitions</span>: buildOperationArgumentDefinitions
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 22 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-51" id="section-51"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _asyncToGenerator = __webpack_require__(<span class="hljs-number">11</span>);

<span class="hljs-keyword">var</span> childProcess = __webpack_require__(<span class="hljs-number">55</span>);

<span class="hljs-keyword">var</span> watchman = __webpack_require__(<span class="hljs-number">56</span>);

<span class="hljs-keyword">var</span> MAX_ATTEMPT_LIMIT = <span class="hljs-number">5</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">delayMs</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
    <span class="hljs-keyword">return</span> setTimeout(resolve, delayMs);
  });
}

<span class="hljs-keyword">var</span> GraphQLWatchmanClient = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  GraphQLWatchmanClient.isAvailable = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAvailable</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-52" id="section-52"></a>
</div>
<p>This command not only will verify that watchman CLI is available
More than that <code>watchman version</code> is a command that runs on the server.
And it can tell us that watchman is up and running
Also <code>watchman version</code> check <code>relative_root</code> capability
under the covers</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> proc = childProcess.spawn(<span class="hljs-string">'watchman'</span>, [<span class="hljs-string">'version'</span>]);
      proc.on(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        resolve(<span class="hljs-literal">false</span>);
      });
      proc.on(<span class="hljs-string">'close'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">code</span>) </span>{
        resolve(code === <span class="hljs-number">0</span>);
      });
    });
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GraphQLWatchmanClient</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> attemptLimit = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>._client = <span class="hljs-keyword">new</span> watchman.Client();
    <span class="hljs-keyword">this</span>._attemptLimit = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.min(MAX_ATTEMPT_LIMIT, attemptLimit), <span class="hljs-number">0</span>);
  }

  <span class="hljs-keyword">var</span> _proto = GraphQLWatchmanClient.prototype;

  _proto._command = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_command</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _this = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">arguments</span>.length, args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(_len), _key = <span class="hljs-number">0</span>; _key &lt; _len; _key++) {
      args[_key] = <span class="hljs-built_in">arguments</span>[_key];
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
      _this._client.command(args, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error, response</span>) </span>{
        <span class="hljs-keyword">if</span> (error) {
          reject(error);
        } <span class="hljs-keyword">else</span> {
          resolve(response);
        }
      });
    });
  };

  _proto.command = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _command2 = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> attempt = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _len2 = <span class="hljs-built_in">arguments</span>.length, args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(_len2), _key2 = <span class="hljs-number">0</span>; _key2 &lt; _len2; _key2++) {
        args[_key2] = <span class="hljs-built_in">arguments</span>[_key2];
      }

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">try</span> {
          attempt++;
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>._command.apply(<span class="hljs-keyword">this</span>, args);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-keyword">if</span> (attempt &gt; <span class="hljs-keyword">this</span>._attemptLimit) {
            <span class="hljs-keyword">throw</span> error;
          }

          <span class="hljs-keyword">yield</span> delay(<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, attempt) * <span class="hljs-number">500</span>);

          <span class="hljs-keyword">this</span>._client.end();

          <span class="hljs-keyword">this</span>._client = <span class="hljs-keyword">new</span> watchman.Client();
        }
      }
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">command</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> _command2.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    <span class="hljs-keyword">return</span> command;
  }();

  _proto.hasCapability = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _hasCapability = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">capability</span>) </span>{
      <span class="hljs-keyword">var</span> resp = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.command(<span class="hljs-string">'list-capabilities'</span>);
      <span class="hljs-keyword">return</span> resp.capabilities.includes(capability);
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasCapability</span>(<span class="hljs-params">_x</span>) </span>{
      <span class="hljs-keyword">return</span> _hasCapability.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    <span class="hljs-keyword">return</span> hasCapability;
  }();

  _proto.watchProject = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _watchProject = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">baseDir</span>) </span>{
      <span class="hljs-keyword">var</span> resp = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.command(<span class="hljs-string">'watch-project'</span>, baseDir);

      <span class="hljs-keyword">if</span> (<span class="hljs-string">'warning'</span> <span class="hljs-keyword">in</span> resp) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Warning:'</span>, resp.warning);
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">root</span>: resp.watch,
        <span class="hljs-attr">relativePath</span>: resp.relative_path
      };
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watchProject</span>(<span class="hljs-params">_x2</span>) </span>{
      <span class="hljs-keyword">return</span> _watchProject.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    <span class="hljs-keyword">return</span> watchProject;
  }();

  _proto.on = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">on</span>(<span class="hljs-params">event, callback</span>) </span>{
    <span class="hljs-keyword">this</span>._client.on(event, callback);
  };

  _proto.end = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">end</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>._client.end();
  };

  <span class="hljs-keyword">return</span> GraphQLWatchmanClient;
}();

<span class="hljs-built_in">module</span>.exports = GraphQLWatchmanClient;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 23 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-53" id="section-53"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError; <span class="hljs-comment">// $FlowFixMe[untyped-import] - immutable.js is not flow-typed</span>


<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">14</span>),
    ImmutableOrderedMap = _require2.OrderedMap;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-54" id="section-54"></a>
</div>
<div class="dox">
<div class="summary">
<p>An immutable representation of a corpus of documents being compiled together.
For each document, the context stores the IR and any validation errors.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> CompilerContext = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-55" id="section-55"></a>
</div>
<p>$FlowFixMe[value-as-type]</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CompilerContext</span>(<span class="hljs-params">schema</span>) </span>{
    <span class="hljs-keyword">this</span>._isMutable = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>._documents = <span class="hljs-keyword">new</span> ImmutableOrderedMap();
    <span class="hljs-keyword">this</span>._withTransform = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
    <span class="hljs-keyword">this</span>._schema = schema;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-56" id="section-56"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns the documents for the context in the order they were added.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">var</span> _proto = CompilerContext.prototype;

  _proto.documents = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">documents</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._documents.toArray();
  };

  _proto.forEachDocument = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachDocument</span>(<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-keyword">this</span>._documents.forEach(fn);
  };

  _proto.replace = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replace</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._update(<span class="hljs-keyword">this</span>._documents.update(node.name, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">existing</span>) </span>{
      !existing ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'CompilerContext: Expected to replace existing node %s, but '</span> + <span class="hljs-string">'one was not found in the context.'</span>, node.name) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> node;
    }));
  };

  _proto.add = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._update(<span class="hljs-keyword">this</span>._documents.update(node.name, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">existing</span>) </span>{
      !!existing ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'CompilerContext: Duplicate document named `%s`. GraphQL '</span> + <span class="hljs-string">'fragments and roots must have unique names.'</span>, node.name) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> node;
    }));
  };

  _proto.addAll = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAll</span>(<span class="hljs-params">nodes</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.withMutations(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mutable</span>) </span>{
      <span class="hljs-keyword">return</span> nodes.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, definition</span>) </span>{
        <span class="hljs-keyword">return</span> ctx.add(definition);
      }, mutable);
    });
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-57" id="section-57"></a>
</div>
<div class="dox">
<div class="summary">
<p>Apply a list of compiler transforms and return a new compiler context.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  ;

  _proto.applyTransforms = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyTransforms</span>(<span class="hljs-params">transforms, reporter</span>) </span>{
    <span class="hljs-keyword">var</span> _this = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">return</span> Profiler.run(<span class="hljs-string">'applyTransforms'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> transforms.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, transform</span>) </span>{
        <span class="hljs-keyword">return</span> ctx.applyTransform(transform, reporter);
      }, _this);
    });
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-58" id="section-58"></a>
</div>
<div class="dox">
<div class="summary">
<p>Applies a transform to this context, returning a new context.</p>
</div>
<div class="body">
<p>This is memoized such that applying the same sequence of transforms will
not result in duplicated work.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  ;

  _proto.applyTransform = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyTransform</span>(<span class="hljs-params">transform, reporter</span>) </span>{
    <span class="hljs-keyword">var</span> transformed = <span class="hljs-keyword">this</span>._withTransform.get(transform);

    <span class="hljs-keyword">if</span> (!transformed) {
      <span class="hljs-keyword">var</span> start = process.hrtime();
      transformed = Profiler.instrument(transform)(<span class="hljs-keyword">this</span>);
      <span class="hljs-keyword">var</span> delta = process.hrtime(start);
      <span class="hljs-keyword">var</span> deltaMs = <span class="hljs-built_in">Math</span>.round((delta[<span class="hljs-number">0</span>] * <span class="hljs-number">1e9</span> + delta[<span class="hljs-number">1</span>]) / <span class="hljs-number">1e6</span>);
      reporter &amp;&amp; reporter.reportTime(transform.name, deltaMs);

      <span class="hljs-keyword">this</span>._withTransform.set(transform, transformed);
    }

    <span class="hljs-keyword">return</span> transformed;
  };

  _proto.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._documents.get(name);
  };

  _proto.getFragment = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFragment</span>(<span class="hljs-params">name, referencedFrom</span>) </span>{
    <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._documents.get(name);

    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Cannot find fragment '"</span>.concat(name, <span class="hljs-string">"'."</span>), referencedFrom != <span class="hljs-literal">null</span> ? [referencedFrom] : <span class="hljs-literal">null</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.kind !== <span class="hljs-string">'Fragment'</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Cannot find fragment '"</span>.concat(name, <span class="hljs-string">"', a document with this name exists "</span>) + <span class="hljs-string">'but is not a fragment.'</span>, [node.loc, referencedFrom].filter(<span class="hljs-built_in">Boolean</span>));
    }

    <span class="hljs-keyword">return</span> node;
  };

  _proto.getRoot = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRoot</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">this</span>._documents.get(name);

    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Cannot find root '"</span>.concat(name, <span class="hljs-string">"'."</span>));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.kind !== <span class="hljs-string">'Root'</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Cannot find root '"</span>.concat(name, <span class="hljs-string">"', a document with this name exists but "</span>) + <span class="hljs-string">'is not a root.'</span>, [node.loc]);
    }

    <span class="hljs-keyword">return</span> node;
  };

  _proto.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._update(<span class="hljs-keyword">this</span>._documents[<span class="hljs-string">"delete"</span>](name));
  };

  _proto.withMutations = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withMutations</span>(<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-keyword">var</span> mutableCopy = <span class="hljs-keyword">this</span>._update(<span class="hljs-keyword">this</span>._documents.asMutable());

    mutableCopy._isMutable = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> result = fn(mutableCopy);
    result._isMutable = <span class="hljs-literal">false</span>;
    result._documents = result._documents.asImmutable();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._documents === result._documents ? <span class="hljs-keyword">this</span> : result;
  };

  _proto._update = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_update</span>(<span class="hljs-params">documents</span>) </span>{
    <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>._isMutable ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> CompilerContext(<span class="hljs-keyword">this</span>.getSchema());
    context._documents = documents;
    <span class="hljs-keyword">return</span> context;
  };

  _proto.getSchema = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSchema</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._schema;
  };

  <span class="hljs-keyword">return</span> CompilerContext;
}();

<span class="hljs-built_in">module</span>.exports = CompilerContext;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 24 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-59" id="section-59"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">md5</span>(<span class="hljs-params">str</span>) </span>{
  <span class="hljs-keyword">return</span> __webpack_require__(<span class="hljs-number">13</span>).createHash(<span class="hljs-string">'md5'</span>).update(str, <span class="hljs-string">'utf8'</span>).digest(<span class="hljs-string">'hex'</span>);
}

<span class="hljs-built_in">module</span>.exports = md5;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 25 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/types"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 26 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-60" id="section-60"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _asyncToGenerator = __webpack_require__(<span class="hljs-number">11</span>);

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>);

<span class="hljs-keyword">var</span> crypto = __webpack_require__(<span class="hljs-number">13</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> path = __webpack_require__(<span class="hljs-number">8</span>); <span class="hljs-comment">// flowlint nonstrict-import:warn</span>


<span class="hljs-keyword">var</span> CodegenDirectory = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CodegenDirectory</span>(<span class="hljs-params">dir, options</span>) </span>{
    <span class="hljs-keyword">var</span> _this = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> _options$filesystem, _options$shards;

    <span class="hljs-keyword">this</span>._filesystem = (_options$filesystem = options.filesystem) !== <span class="hljs-literal">null</span> &amp;&amp; _options$filesystem !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _options$filesystem : __webpack_require__(<span class="hljs-number">12</span>);
    <span class="hljs-keyword">this</span>.onlyValidate = options.onlyValidate;
    <span class="hljs-keyword">this</span>._shards = (_options$shards = options.shards) !== <span class="hljs-literal">null</span> &amp;&amp; _options$shards !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _options$shards : <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._filesystem.existsSync(dir)) {
      !<span class="hljs-keyword">this</span>._filesystem.statSync(dir).isDirectory() ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'Expected `%s` to be a directory.'</span>, dir) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.onlyValidate) {
      <span class="hljs-keyword">var</span> dirs = [];
      <span class="hljs-keyword">var</span> parent = dir;

      <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>._filesystem.existsSync(parent)) {
        dirs.unshift(parent);
        parent = path.dirname(parent);
      }

      dirs.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) </span>{
        <span class="hljs-keyword">return</span> _this._filesystem.mkdirSync(d);
      });

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._shards &gt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> shard = <span class="hljs-number">0</span>; shard &lt; <span class="hljs-keyword">this</span>._shards; shard++) {
          <span class="hljs-keyword">var</span> shardDir = path.join(dir, <span class="hljs-keyword">this</span>._getShardName(shard));

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._filesystem.existsSync(shardDir)) {
            !<span class="hljs-keyword">this</span>._filesystem.statSync(dir).isDirectory() ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'Expected `%s` to be a directory.'</span>, dir) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>._filesystem.mkdirSync(shardDir);
          }
        }
      }
    }

    <span class="hljs-keyword">this</span>._files = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">this</span>.changes = {
      <span class="hljs-attr">deleted</span>: [],
      <span class="hljs-attr">updated</span>: [],
      <span class="hljs-attr">created</span>: [],
      <span class="hljs-attr">unchanged</span>: []
    };
    <span class="hljs-keyword">this</span>._dir = dir;
  }

  CodegenDirectory.combineChanges = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combineChanges</span>(<span class="hljs-params">dirs</span>) </span>{
    <span class="hljs-keyword">var</span> changes = {
      <span class="hljs-attr">deleted</span>: [],
      <span class="hljs-attr">updated</span>: [],
      <span class="hljs-attr">created</span>: [],
      <span class="hljs-attr">unchanged</span>: []
    };
    dirs.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dir</span>) </span>{
      <span class="hljs-keyword">var</span> _changes$deleted, _changes$updated, _changes$created, _changes$unchanged;

      (_changes$deleted = changes.deleted).push.apply(_changes$deleted, (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(dir.changes.deleted));

      (_changes$updated = changes.updated).push.apply(_changes$updated, (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(dir.changes.updated));

      (_changes$created = changes.created).push.apply(_changes$created, (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(dir.changes.created));

      (_changes$unchanged = changes.unchanged).push.apply(_changes$unchanged, (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(dir.changes.unchanged));
    });
    <span class="hljs-keyword">return</span> changes;
  };

  CodegenDirectory.hasChanges = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasChanges</span>(<span class="hljs-params">changes</span>) </span>{
    <span class="hljs-keyword">return</span> changes.created.length &gt; <span class="hljs-number">0</span> || changes.updated.length &gt; <span class="hljs-number">0</span> || changes.deleted.length &gt; <span class="hljs-number">0</span>;
  };

  CodegenDirectory.formatChanges = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatChanges</span>(<span class="hljs-params">changes, options</span>) </span>{
    <span class="hljs-keyword">var</span> output = [];

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatFiles</span>(<span class="hljs-params">label, files</span>) </span>{
      <span class="hljs-keyword">if</span> (files.length &gt; <span class="hljs-number">0</span>) {
        output.push(label + <span class="hljs-string">':'</span>);
        files.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">file</span>) </span>{
          output.push(<span class="hljs-string">' - '</span> + file);
        });
      }
    }

    <span class="hljs-keyword">if</span> (options.onlyValidate) {
      formatFiles(<span class="hljs-string">'Missing'</span>, changes.created);
      formatFiles(<span class="hljs-string">'Out of date'</span>, changes.updated);
      formatFiles(<span class="hljs-string">'Extra'</span>, changes.deleted);
    } <span class="hljs-keyword">else</span> {
      formatFiles(<span class="hljs-string">'Created'</span>, changes.created);
      formatFiles(<span class="hljs-string">'Updated'</span>, changes.updated);
      formatFiles(<span class="hljs-string">'Deleted'</span>, changes.deleted);
      output.push(<span class="hljs-string">"Unchanged: "</span>.concat(changes.unchanged.length, <span class="hljs-string">" files"</span>));
    }

    <span class="hljs-keyword">return</span> output.join(<span class="hljs-string">'\n'</span>);
  };

  CodegenDirectory.printChanges = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printChanges</span>(<span class="hljs-params">changes, options</span>) </span>{
    Profiler.run(<span class="hljs-string">'CodegenDirectory.printChanges'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> output = CodegenDirectory.formatChanges(changes, options); <span class="hljs-comment">// eslint-disable-next-line no-console</span>

      <span class="hljs-built_in">console</span>.log(output);
    });
  };

  CodegenDirectory.getAddedRemovedFiles = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAddedRemovedFiles</span>(<span class="hljs-params">dirs</span>) </span>{
    <span class="hljs-keyword">var</span> added = [];
    <span class="hljs-keyword">var</span> removed = [];
    dirs.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dir</span>) </span>{
      dir.changes.created.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        added.push(dir.getPath(name));
      });
      dir.changes.deleted.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        removed.push(dir.getPath(name));
      });
    });
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">added</span>: added,
      <span class="hljs-attr">removed</span>: removed
    };
  };

  CodegenDirectory.sourceControlAddRemove = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _sourceControlAddRemove = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">sourceControl, dirs</span>) </span>{
      <span class="hljs-keyword">var</span> _CodegenDirectory$<span class="hljs-keyword">get</span> = CodegenDirectory.getAddedRemovedFiles(dirs),
          added = _CodegenDirectory$<span class="hljs-keyword">get</span>.added,
          removed = _CodegenDirectory$<span class="hljs-keyword">get</span>.removed;

      sourceControl.addRemove(added, removed);
    });

    function sourceControlAddRemove(_x, _x2) {
      <span class="hljs-keyword">return</span> _sourceControlAddRemove.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    <span class="hljs-keyword">return</span> sourceControlAddRemove;
  }();

  <span class="hljs-keyword">var</span> _proto = CodegenDirectory.prototype;

  _proto.printChanges = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printChanges</span>(<span class="hljs-params"></span>) </span>{
    CodegenDirectory.printChanges(<span class="hljs-keyword">this</span>.changes, {
      <span class="hljs-attr">onlyValidate</span>: <span class="hljs-keyword">this</span>.onlyValidate
    });
  };

  _proto.read = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span>(<span class="hljs-params">filename</span>) </span>{
    <span class="hljs-keyword">var</span> filePath = path.join(<span class="hljs-keyword">this</span>._dir, filename);

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._filesystem.existsSync(filePath)) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._filesystem.readFileSync(filePath, <span class="hljs-string">'utf8'</span>);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  };

  _proto.markUnchanged = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markUnchanged</span>(<span class="hljs-params">filename</span>) </span>{
    <span class="hljs-keyword">this</span>._addGenerated(filename);

    <span class="hljs-keyword">this</span>.changes.unchanged.push(filename);
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-61" id="section-61"></a>
</div>
<div class="dox">
<div class="summary">
<p>Marks a files as updated or out of date without actually writing the file.
This is probably only be useful when doing validation without intention to
actually write to disk.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  ;

  _proto.markUpdated = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markUpdated</span>(<span class="hljs-params">filename</span>) </span>{
    <span class="hljs-keyword">this</span>._addGenerated(filename);

    <span class="hljs-keyword">this</span>.changes.updated.push(filename);
  };

  _proto.writeFile = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeFile</span>(<span class="hljs-params">filename, content</span>) </span>{
    <span class="hljs-keyword">var</span> _this2 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> shouldRepersist = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>] : <span class="hljs-literal">false</span>;
    Profiler.run(<span class="hljs-string">'CodegenDirectory.writeFile'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      _this2._addGenerated(filename);

      <span class="hljs-keyword">var</span> filePath = _this2.getPath(filename);

      <span class="hljs-keyword">if</span> (_this2._filesystem.existsSync(filePath)) {
        <span class="hljs-keyword">var</span> existingContent = _this2._filesystem.readFileSync(filePath, <span class="hljs-string">'utf8'</span>);

        <span class="hljs-keyword">if</span> (existingContent === content &amp;&amp; !shouldRepersist) {
          _this2.changes.unchanged.push(filename);
        } <span class="hljs-keyword">else</span> {
          _this2._writeFile(filePath, content);

          _this2.changes.updated.push(filename);
        }
      } <span class="hljs-keyword">else</span> {
        _this2._writeFile(filePath, content);

        _this2.changes.created.push(filename);
      }
    });
  };

  _proto._writeFile = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_writeFile</span>(<span class="hljs-params">filePath, content</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.onlyValidate) {
      <span class="hljs-keyword">this</span>._filesystem.writeFileSync(filePath, content, <span class="hljs-string">'utf8'</span>);
    }
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-62" id="section-62"></a>
</div>
<div class="dox">
<div class="summary">
<p>Deletes all non-generated files, except for invisible &quot;dot&quot; files (ie.
files with names starting with &quot;.&quot;).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  ;

  _proto.deleteExtraFiles = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteExtraFiles</span>(<span class="hljs-params">keepExtraFile</span>) </span>{
    <span class="hljs-keyword">var</span> _this3 = <span class="hljs-keyword">this</span>;

    Profiler.run(<span class="hljs-string">'CodegenDirectory.deleteExtraFiles'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (_this3._shards &gt; <span class="hljs-number">1</span>) {
        _this3._filesystem.readdirSync(_this3._dir).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">firstLevel</span>) </span>{
          <span class="hljs-keyword">if</span> (firstLevel.startsWith(<span class="hljs-string">'.'</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-63" id="section-63"></a>
</div>
<p>allow hidden files on the first level of the codegen directory</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">var</span> firstLevelPath = path.join(_this3._dir, firstLevel);

          <span class="hljs-keyword">if</span> (!_this3._filesystem.statSync(firstLevelPath).isDirectory()) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-64" id="section-64"></a>
</div>
<p>Delete all files on the top level, all files need to be in a
shard directory.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            _this3._filesystem.unlinkSync(firstLevelPath);

            <span class="hljs-keyword">return</span>;
          }

          _this3._filesystem.readdirSync(firstLevelPath).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">actualFile</span>) </span>{
            <span class="hljs-keyword">if</span> (keepExtraFile &amp;&amp; keepExtraFile(actualFile)) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (_this3._files.has(actualFile)) {
              <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-keyword">if</span> (!_this3.onlyValidate) {
              <span class="hljs-keyword">try</span> {
                _this3._filesystem.unlinkSync(path.join(firstLevelPath, actualFile));
              } <span class="hljs-keyword">catch</span> (_unused) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'CodegenDirectory: Failed to delete `'</span> + actualFile + <span class="hljs-string">'` in `'</span> + _this3._dir + <span class="hljs-string">'`.'</span>);
              }
            }

            _this3.changes.deleted.push(actualFile);
          });
        });
      } <span class="hljs-keyword">else</span> {
        _this3._filesystem.readdirSync(_this3._dir).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">actualFile</span>) </span>{
          <span class="hljs-keyword">if</span> (keepExtraFile &amp;&amp; keepExtraFile(actualFile)) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (actualFile.startsWith(<span class="hljs-string">'.'</span>) || _this3._files.has(actualFile)) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (!_this3.onlyValidate) {
            <span class="hljs-keyword">try</span> {
              _this3._filesystem.unlinkSync(path.join(_this3._dir, actualFile));
            } <span class="hljs-keyword">catch</span> (_unused2) {
              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'CodegenDirectory: Failed to delete `'</span> + actualFile + <span class="hljs-string">'` in `'</span> + _this3._dir + <span class="hljs-string">'`.'</span>);
            }
          }

          _this3.changes.deleted.push(actualFile);
        });
      }
    });
  };

  _proto.getPath = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPath</span>(<span class="hljs-params">filename</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._shards &gt; <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">var</span> hasher = crypto.createHash(<span class="hljs-string">'md5'</span>);
      hasher.update(filename, <span class="hljs-string">'utf8'</span>);

      <span class="hljs-keyword">var</span> shard = hasher.digest().readUInt32BE(<span class="hljs-number">0</span>) % <span class="hljs-keyword">this</span>._shards;

      <span class="hljs-keyword">return</span> path.join(<span class="hljs-keyword">this</span>._dir, <span class="hljs-keyword">this</span>._getShardName(shard), filename);
    }

    <span class="hljs-keyword">return</span> path.join(<span class="hljs-keyword">this</span>._dir, filename);
  };

  _proto._getShardName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_getShardName</span>(<span class="hljs-params">shardNumber</span>) </span>{
    <span class="hljs-keyword">var</span> base16length = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.log2(<span class="hljs-number">256</span>) / <span class="hljs-number">4</span>);
    <span class="hljs-keyword">return</span> shardNumber.toString(<span class="hljs-number">16</span>).padStart(base16length, <span class="hljs-string">'0'</span>);
  };

  _proto._addGenerated = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_addGenerated</span>(<span class="hljs-params">filename</span>) </span>{
    !!<span class="hljs-keyword">this</span>._files.has(filename) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'CodegenDirectory: Tried to generate `%s` twice in `%s`.'</span>, filename, <span class="hljs-keyword">this</span>._dir) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">this</span>._files.add(filename);
  };

  <span class="hljs-keyword">return</span> CodegenDirectory;
}();

<span class="hljs-built_in">module</span>.exports = CodegenDirectory;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 27 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-65" id="section-65"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>); <span class="hljs-comment">// $FlowFixMe[untyped-import] : Immutable is not typed</span>


<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">14</span>),
    ImmutableMap = _require.Map;

<span class="hljs-keyword">var</span> ASTCache = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ASTCache</span>(<span class="hljs-params">config</span>) </span>{
    <span class="hljs-keyword">this</span>._documents = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">this</span>._baseDir = config.baseDir;
    <span class="hljs-keyword">this</span>._parse = Profiler.instrument(config.parse, <span class="hljs-string">'ASTCache.parseFn'</span>);
  } <span class="hljs-comment">// Short-term: we don't do subscriptions/delta updates, instead always use all definitions</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-66" id="section-66"></a>
</div>
<p>$FlowFixMe[value-as-type]</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">var</span> _proto = ASTCache.prototype;

  _proto.documents = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">documents</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> ImmutableMap(<span class="hljs-keyword">this</span>._documents);
  } <span class="hljs-comment">// parse should return the set of changes</span>
  ;

  _proto.parseFiles = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseFiles</span>(<span class="hljs-params">files</span>) </span>{
    <span class="hljs-keyword">var</span> _this = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> documents = ImmutableMap();
    files.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">file</span>) </span>{
      <span class="hljs-keyword">if</span> (!file.exists) {
        _this._documents[<span class="hljs-string">"delete"</span>](file.relPath);

        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> doc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> _this._parse(_this._baseDir, file);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Parse error: "</span>.concat(error, <span class="hljs-string">" in \""</span>).concat(file.relPath, <span class="hljs-string">"\""</span>));
        }
      }();

      <span class="hljs-keyword">if</span> (!doc) {
        _this._documents[<span class="hljs-string">"delete"</span>](file.relPath);

        <span class="hljs-keyword">return</span>;
      }

      documents = documents.set(file.relPath, doc);

      _this._documents.set(file.relPath, doc);
    });
    <span class="hljs-keyword">return</span> documents;
  };

  <span class="hljs-keyword">return</span> ASTCache;
}();

<span class="hljs-built_in">module</span>.exports = ASTCache;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 28 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-67" id="section-67"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>);

<span class="hljs-keyword">var</span> orList = __webpack_require__(<span class="hljs-number">64</span>);

<span class="hljs-keyword">var</span> partitionArray = __webpack_require__(<span class="hljs-number">15</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">29</span>),
    DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require2.createCompilerError,
    createUserError = _require2.createUserError,
    eachWithCombinedError = _require2.eachWithCombinedError;

<span class="hljs-keyword">var</span> _require3 = __webpack_require__(<span class="hljs-number">9</span>),
    isExecutableDefinitionAST = _require3.isExecutableDefinitionAST;

<span class="hljs-keyword">var</span> _require4 = __webpack_require__(<span class="hljs-number">30</span>),
    getFieldDefinitionLegacy = _require4.getFieldDefinitionLegacy;

<span class="hljs-keyword">var</span> _require5 = __webpack_require__(<span class="hljs-number">7</span>),
    parseGraphQL = _require5.parse,
    parseType = _require5.parseType,
    print = _require5.print,
    Source = _require5.Source;

<span class="hljs-keyword">var</span> ARGUMENT_DEFINITIONS = <span class="hljs-string">'argumentDefinitions'</span>;
<span class="hljs-keyword">var</span> ARGUMENTS = <span class="hljs-string">'arguments'</span>;
<span class="hljs-keyword">var</span> DEPRECATED_UNCHECKED_ARGUMENTS = <span class="hljs-string">'uncheckedArguments_DEPRECATED'</span>;
<span class="hljs-keyword">var</span> DIRECTIVE_WHITELIST = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([ARGUMENT_DEFINITIONS, DEPRECATED_UNCHECKED_ARGUMENTS, ARGUMENTS]);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-68" id="section-68"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-keyword">var</span> CLIENT_FIELD = <span class="hljs-string">'__clientField'</span>;
<span class="hljs-keyword">var</span> CLIENT_FIELD_HANDLE = <span class="hljs-string">'handle'</span>;
<span class="hljs-keyword">var</span> CLIENT_FIELD_KEY = <span class="hljs-string">'key'</span>;
<span class="hljs-keyword">var</span> CLIENT_FIELD_FILTERS = <span class="hljs-string">'filters'</span>;
<span class="hljs-keyword">var</span> INCLUDE = <span class="hljs-string">'include'</span>;
<span class="hljs-keyword">var</span> SKIP = <span class="hljs-string">'skip'</span>;
<span class="hljs-keyword">var</span> IF = <span class="hljs-string">'if'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-69" id="section-69"></a>
</div>
<div class="dox">
<div class="summary">
<p>Transforms GraphQL text into Relay Compiler's internal, strongly-typed
intermediate representation (IR).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">schema, text, filename</span>) </span>{
  <span class="hljs-keyword">var</span> ast = parseGraphQL(<span class="hljs-keyword">new</span> Source(text, filename));
  <span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> RelayParser(schema.extend(ast), ast.definitions);
  <span class="hljs-keyword">return</span> parser.transform();
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-70" id="section-70"></a>
</div>
<div class="dox">
<div class="summary">
<p>Transforms untyped GraphQL parse trees (ASTs) into Relay Compiler's
internal, strongly-typed intermediate representation (IR).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transform</span>(<span class="hljs-params">schema, definitions</span>) </span>{
  <span class="hljs-keyword">return</span> Profiler.run(<span class="hljs-string">'RelayParser.transform'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> RelayParser(schema, definitions);
    <span class="hljs-keyword">return</span> parser.transform();
  });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-71" id="section-71"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> RelayParser = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RelayParser</span>(<span class="hljs-params">schema, definitions</span>) </span>{
    <span class="hljs-keyword">var</span> _this = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">this</span>._definitions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// leaving this configurable to make it easy to experiment w changing later</span>

    <span class="hljs-keyword">this</span>._getFieldDefinition = getFieldDefinitionLegacy;
    <span class="hljs-keyword">this</span>._schema = schema;
    <span class="hljs-keyword">var</span> duplicated = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">def</span>) </span>{
      <span class="hljs-keyword">if</span> (isExecutableDefinitionAST(def)) {
        <span class="hljs-keyword">var</span> name = getName(def);

        <span class="hljs-keyword">if</span> (_this._definitions.has(name)) {
          duplicated.add(name);
          <span class="hljs-keyword">return</span>;
        }

        _this._definitions.set(name, def);
      }
    });

    <span class="hljs-keyword">if</span> (duplicated.size) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'RelayParser: Encountered duplicate definitions for one or more '</span> + <span class="hljs-string">'documents: each document must have a unique name. Duplicated documents:\n'</span> + <span class="hljs-built_in">Array</span>.from(duplicated, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"- "</span>.concat(name);
      }).join(<span class="hljs-string">'\n'</span>));
    }
  }

  <span class="hljs-keyword">var</span> _proto = RelayParser.prototype;

  _proto.transform = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transform</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _this2 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> nodes = [];
    <span class="hljs-keyword">var</span> entries = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// Construct a mapping of name to definition ast + variable definitions.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-72" id="section-72"></a>
</div>
<p>This allows the subsequent AST -&gt; IR tranformation to reference the
defined arguments of referenced fragments.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    eachWithCombinedError(<span class="hljs-keyword">this</span>._definitions, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref</span>) </span>{
      <span class="hljs-keyword">var</span> name = _ref[<span class="hljs-number">0</span>],
          definition = _ref[<span class="hljs-number">1</span>];

      <span class="hljs-keyword">var</span> variableDefinitions = _this2._buildArgumentDefinitions(definition);

      entries.set(name, {
        <span class="hljs-attr">definition</span>: definition,
        <span class="hljs-attr">variableDefinitions</span>: variableDefinitions
      });
    }); <span class="hljs-comment">// Convert the ASTs to IR.</span>

    eachWithCombinedError(entries.values(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref2</span>) </span>{
      <span class="hljs-keyword">var</span> definition = _ref2.definition,
          variableDefinitions = _ref2.variableDefinitions;
      <span class="hljs-keyword">var</span> node = parseDefinition(_this2._schema, _this2._getFieldDefinition, entries, definition, variableDefinitions);
      nodes.push(node);
    });
    <span class="hljs-keyword">return</span> nodes;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-73" id="section-73"></a>
</div>
<div class="dox">
<div class="summary">
<p>Constructs a mapping of variable names to definitions for the given
operation/fragment definition.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  ;

  _proto._buildArgumentDefinitions = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_buildArgumentDefinitions</span>(<span class="hljs-params">definition</span>) </span>{
    <span class="hljs-keyword">switch</span> (definition.kind) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'OperationDefinition'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._buildOperationArgumentDefinitions(definition);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'FragmentDefinition'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._buildFragmentArgumentDefinitions(definition);

      <span class="hljs-keyword">default</span>:
        definition;
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unexpected ast kind '"</span>.concat(definition.kind, <span class="hljs-string">"'."</span>), [definition]);
    }
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-74" id="section-74"></a>
</div>
<div class="dox">
<div class="summary">
<p>Constructs a mapping of variable names to definitions using the
variables defined in <code>@argumentDefinitions</code>.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  ;

  _proto._buildFragmentArgumentDefinitions = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_buildFragmentArgumentDefinitions</span>(<span class="hljs-params">fragment</span>) </span>{
    <span class="hljs-keyword">var</span> _this3 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> variableDirectives = (fragment.directives || []).filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> getName(directive) === ARGUMENT_DEFINITIONS;
    });

    <span class="hljs-keyword">if</span> (!variableDirectives.length) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    }

    <span class="hljs-keyword">if</span> (variableDirectives.length !== <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Directive @"</span>.concat(ARGUMENT_DEFINITIONS, <span class="hljs-string">" may be defined at most once per "</span>) + <span class="hljs-string">'fragment.'</span>, <span class="hljs-literal">null</span>, variableDirectives);
    }

    <span class="hljs-keyword">var</span> variableDirective = variableDirectives[<span class="hljs-number">0</span>]; <span class="hljs-comment">// work, below accesses all report arguments could still be null/undefined.</span>

    <span class="hljs-keyword">var</span> args = variableDirective.arguments;

    <span class="hljs-keyword">if</span> (variableDirective == <span class="hljs-literal">null</span> || !<span class="hljs-built_in">Array</span>.isArray(args)) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    }

    <span class="hljs-keyword">if</span> (!args.length) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Directive @"</span>.concat(ARGUMENT_DEFINITIONS, <span class="hljs-string">" requires arguments: remove the "</span>) + <span class="hljs-string">'directive to skip defining local variables for this fragment.'</span>, <span class="hljs-literal">null</span>, [variableDirective]);
    }

    <span class="hljs-keyword">var</span> variables = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    args.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">var</span> _defaultValue$value;

      <span class="hljs-keyword">var</span> argName = getName(arg);
      <span class="hljs-keyword">var</span> previousVariable = variables.get(argName);

      <span class="hljs-keyword">if</span> (previousVariable != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Duplicate definition for variable '$"</span>.concat(argName, <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [previousVariable.ast, arg]);
      }

      <span class="hljs-keyword">if</span> (arg.value.kind !== <span class="hljs-string">'ObjectValue'</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected definition for variable '$"</span>.concat(argName, <span class="hljs-string">"' to be an object "</span>) + <span class="hljs-string">"with the shape: '{type: string, defaultValue?: mixed}."</span>, <span class="hljs-literal">null</span>, [arg.value]);
      }

      <span class="hljs-keyword">var</span> defaultValueNode;
      <span class="hljs-keyword">var</span> typeString;
      arg.value.fields.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field</span>) </span>{
        <span class="hljs-keyword">var</span> name = getName(field);

        <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'type'</span>) {
          typeString = transformLiteralValue(field.value, field);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'defaultValue'</span>) {
          defaultValueNode = field.value;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected definition for variable '$"</span>.concat(argName, <span class="hljs-string">"' to be an object "</span>) + <span class="hljs-string">"with the shape: '{type: string, defaultValue?: mixed}."</span>, <span class="hljs-literal">null</span>, [arg.value]);
        }
      });

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> typeString !== <span class="hljs-string">'string'</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected definition for variable '$"</span>.concat(argName, <span class="hljs-string">"' to be an object "</span>) + <span class="hljs-string">"with the shape: '{type: string, defaultValue?: mixed}."</span>, <span class="hljs-literal">null</span>, [arg.value]);
      }

      <span class="hljs-keyword">var</span> typeFromAST = _this3._schema.getTypeFromAST(parseType(typeString));

      <span class="hljs-keyword">if</span> (typeFromAST == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unknown type \""</span>.concat(typeString, <span class="hljs-string">"\" referenced in the argument definitions."</span>), <span class="hljs-literal">null</span>, [arg]);
      }

      <span class="hljs-keyword">var</span> type = _this3._schema.asInputType(typeFromAST);

      <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected type \""</span>.concat(typeString, <span class="hljs-string">"\" to be an input type in the \""</span>).concat(arg.name.value, <span class="hljs-string">"\" argument definitions."</span>), <span class="hljs-literal">null</span>, [arg.value]);
      }

      <span class="hljs-keyword">var</span> defaultValue = defaultValueNode != <span class="hljs-literal">null</span> ? transformValue(_this3._schema, defaultValueNode, type, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">variableAst</span>) </span>{
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected 'defaultValue' to be a literal, got a variable."</span>, <span class="hljs-literal">null</span>, [variableAst]);
      }) : <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (defaultValue != <span class="hljs-literal">null</span> &amp;&amp; defaultValue.kind !== <span class="hljs-string">'Literal'</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected 'defaultValue' to be a literal, got a variable."</span>, [defaultValue.loc]);
      }

      variables.set(argName, {
        <span class="hljs-attr">ast</span>: arg,
        <span class="hljs-attr">defaultValue</span>: (_defaultValue$value = defaultValue === <span class="hljs-literal">null</span> || defaultValue === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : defaultValue.value) !== <span class="hljs-literal">null</span> &amp;&amp; _defaultValue$value !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _defaultValue$value : <span class="hljs-literal">null</span>,
        <span class="hljs-attr">defined</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">name</span>: argName,
        <span class="hljs-attr">type</span>: type
      });
    });
    <span class="hljs-keyword">return</span> variables;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-75" id="section-75"></a>
</div>
<div class="dox">
<div class="summary">
<p>Constructs a mapping of variable names to definitions using the
standard GraphQL syntax for variable definitions.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  ;

  _proto._buildOperationArgumentDefinitions = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_buildOperationArgumentDefinitions</span>(<span class="hljs-params">operation</span>) </span>{
    <span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">this</span>._schema;
    <span class="hljs-keyword">var</span> variableDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    (operation.variableDefinitions || []).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">def</span>) </span>{
      <span class="hljs-keyword">var</span> name = getName(def.variable);
      <span class="hljs-keyword">var</span> typeFromAST = schema.getTypeFromAST(def.type);

      <span class="hljs-keyword">if</span> (typeFromAST == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unknown type: '"</span>.concat(getTypeName(def.type), <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [def.type]);
      }

      <span class="hljs-keyword">var</span> type = schema.asInputType(typeFromAST);

      <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected type \""</span>.concat(getTypeName(def.type), <span class="hljs-string">"\" to be an input type."</span>), <span class="hljs-literal">null</span>, [def.type]);
      }

      <span class="hljs-keyword">var</span> defaultValue = def.defaultValue ? transformLiteralValue(def.defaultValue, def) : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> previousDefinition = variableDefinitions.get(name);

      <span class="hljs-keyword">if</span> (previousDefinition != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Duplicate definition for variable '$"</span>.concat(name, <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [previousDefinition.ast, def]);
      }

      variableDefinitions.set(name, {
        <span class="hljs-attr">ast</span>: def,
        <span class="hljs-attr">defaultValue</span>: defaultValue,
        <span class="hljs-attr">defined</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">name</span>: name,
        <span class="hljs-attr">type</span>: type
      });
    });
    <span class="hljs-keyword">return</span> variableDefinitions;
  };

  <span class="hljs-keyword">return</span> RelayParser;
}();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-76" id="section-76"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseDefinition</span>(<span class="hljs-params">schema, getFieldDefinition, entries, definition, variableDefinitions</span>) </span>{
  <span class="hljs-keyword">var</span> parser = <span class="hljs-keyword">new</span> GraphQLDefinitionParser(schema, getFieldDefinition, entries, definition, variableDefinitions);
  <span class="hljs-keyword">return</span> parser.transform();
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-77" id="section-77"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> GraphQLDefinitionParser = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GraphQLDefinitionParser</span>(<span class="hljs-params">schema, getFieldDefinition, entries, definition, variableDefinitions</span>) </span>{
    <span class="hljs-keyword">this</span>._definition = definition;
    <span class="hljs-keyword">this</span>._entries = entries;
    <span class="hljs-keyword">this</span>._getFieldDefinition = getFieldDefinition;
    <span class="hljs-keyword">this</span>._schema = schema;
    <span class="hljs-keyword">this</span>._variableDefinitions = variableDefinitions;
    <span class="hljs-keyword">this</span>._unknownVariables = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  }

  <span class="hljs-keyword">var</span> _proto2 = GraphQLDefinitionParser.prototype;

  _proto2.transform = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transform</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> definition = <span class="hljs-keyword">this</span>._definition;

    <span class="hljs-keyword">switch</span> (definition.kind) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'OperationDefinition'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._transformOperation(definition);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'FragmentDefinition'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._transformFragment(definition);

      <span class="hljs-keyword">default</span>:
        definition;
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unsupported definition type "</span>.concat(definition.kind), [definition]);
    }
  };

  _proto2._recordAndVerifyVariableReference = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_recordAndVerifyVariableReference</span>(<span class="hljs-params">variable, name, usedAsType</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-78" id="section-78"></a>
</div>
<p>Special case for variables used in @arguments where we currently
aren't guaranteed to be able to resolve the type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (usedAsType == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._variableDefinitions.has(name) &amp;&amp; !<span class="hljs-keyword">this</span>._unknownVariables.has(name)) {
        <span class="hljs-keyword">this</span>._unknownVariables.set(name, {
          <span class="hljs-attr">ast</span>: variable,
          <span class="hljs-attr">type</span>: <span class="hljs-literal">null</span>
        });
      }

      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> variableDefinition = <span class="hljs-keyword">this</span>._variableDefinitions.get(name);

    <span class="hljs-keyword">if</span> (variableDefinition != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-79" id="section-79"></a>
</div>
<p>If the variable is defined, all usages must be compatible</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> effectiveType = variableDefinition.type;

      <span class="hljs-keyword">if</span> (variableDefinition.defaultValue != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-80" id="section-80"></a>
</div>
<p>If a default value is defined then it is guaranteed to be used
at runtime such that the effective type of the variable is non-null</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        effectiveType = <span class="hljs-keyword">this</span>._schema.getNonNullType(<span class="hljs-keyword">this</span>._schema.getNullableType(effectiveType));
      }

      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._schema.isTypeSubTypeOf(effectiveType, usedAsType)) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Variable '$"</span>.concat(name, <span class="hljs-string">"' was defined as type '"</span>).concat(<span class="hljs-built_in">String</span>(variableDefinition.type), <span class="hljs-string">"' but used in a location expecting the type '"</span>).concat(<span class="hljs-built_in">String</span>(usedAsType), <span class="hljs-string">"'"</span>), <span class="hljs-literal">null</span>, [variableDefinition.ast, variable]);
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> previous = <span class="hljs-keyword">this</span>._unknownVariables.get(name);

      <span class="hljs-keyword">if</span> (!previous || !previous.type) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-81" id="section-81"></a>
</div>
<p>No previous usage, current type is strongest</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">this</span>._unknownVariables.set(name, {
          <span class="hljs-attr">ast</span>: variable,
          <span class="hljs-attr">type</span>: usedAsType
        });
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> previousVariable = previous.ast,
            previousType = previous.type;

        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span>._schema.isTypeSubTypeOf(usedAsType, previousType) || <span class="hljs-keyword">this</span>._schema.isTypeSubTypeOf(previousType, usedAsType))) {
          <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Variable '$"</span>.concat(name, <span class="hljs-string">"' was used in locations expecting the conflicting types '"</span>).concat(<span class="hljs-built_in">String</span>(previousType), <span class="hljs-string">"' and '"</span>).concat(<span class="hljs-built_in">String</span>(usedAsType), <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [previousVariable, variable]);
        } <span class="hljs-comment">// If the new used type has stronger requirements, use that type as reference,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-82" id="section-82"></a>
</div>
<p>otherwise keep referencing the previous type</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._schema.isTypeSubTypeOf(usedAsType, previousType)) {
          <span class="hljs-keyword">this</span>._unknownVariables.set(name, {
            <span class="hljs-attr">ast</span>: variable,
            <span class="hljs-attr">type</span>: usedAsType
          });
        }
      }
    }
  };

  _proto2._getDirectiveLocations = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_getDirectiveLocations</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._directiveLocations) {
      <span class="hljs-keyword">var</span> directiveDefs = <span class="hljs-keyword">this</span>._schema.getDirectives();

      <span class="hljs-keyword">this</span>._directiveLocations = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

      <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(directiveDefs),
          _step;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
          <span class="hljs-keyword">var</span> def = _step.value;

          <span class="hljs-keyword">this</span>._directiveLocations.set(def.name, def.locations);
        }
      } <span class="hljs-keyword">catch</span> (err) {
        _iterator.e(err);
      } <span class="hljs-keyword">finally</span> {
        _iterator.f();
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._directiveLocations;
  };

  _proto2._validateDirectivesLocation = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_validateDirectivesLocation</span>(<span class="hljs-params">directives, allowedLocaction</span>) </span>{
    <span class="hljs-keyword">if</span> (!directives || !directives.length) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> directiveLocs = <span class="hljs-keyword">this</span>._getDirectiveLocations();

    <span class="hljs-keyword">var</span> mismatches = directives.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">var</span> name = getName(directive);

      <span class="hljs-keyword">if</span> (DIRECTIVE_WHITELIST.has(name)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">var</span> locs = directiveLocs.get(name);

      <span class="hljs-keyword">if</span> (locs == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unknown directive '"</span>.concat(name, <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [directive]);
      }

      <span class="hljs-keyword">return</span> !locs.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">loc</span>) </span>{
        <span class="hljs-keyword">return</span> loc === allowedLocaction;
      });
    });

    <span class="hljs-keyword">if</span> (mismatches.length) {
      <span class="hljs-keyword">var</span> invalidDirectives = mismatches.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'@'</span> + getName(directive);
      }).join(<span class="hljs-string">', '</span>);
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid directives "</span>.concat(invalidDirectives, <span class="hljs-string">" found on "</span>).concat(allowedLocaction, <span class="hljs-string">"."</span>), <span class="hljs-literal">null</span>, mismatches);
    }
  };

  _proto2._transformFragment = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_transformFragment</span>(<span class="hljs-params">fragment</span>) </span>{
    <span class="hljs-keyword">var</span> directives = <span class="hljs-keyword">this</span>._transformDirectives((fragment.directives || []).filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> getName(directive) !== ARGUMENT_DEFINITIONS;
    }), <span class="hljs-string">'FRAGMENT_DEFINITION'</span>);

    <span class="hljs-keyword">var</span> typeFromAST = <span class="hljs-keyword">this</span>._schema.getTypeFromAST(fragment.typeCondition);

    <span class="hljs-keyword">if</span> (typeFromAST == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Fragment \""</span>.concat(fragment.name.value, <span class="hljs-string">"\" cannot condition on unknown "</span>) + <span class="hljs-string">"type \""</span>.concat(<span class="hljs-built_in">String</span>(fragment.typeCondition.name.value), <span class="hljs-string">"\"."</span>), <span class="hljs-literal">null</span>, [fragment.typeCondition]);
    }

    <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">this</span>._schema.asCompositeType(typeFromAST);

    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Fragment \""</span>.concat(fragment.name.value, <span class="hljs-string">"\" cannot condition on non composite "</span>) + <span class="hljs-string">"type \""</span>.concat(<span class="hljs-built_in">String</span>(type), <span class="hljs-string">"\"."</span>), <span class="hljs-literal">null</span>, [fragment.typeCondition]);
    }

    <span class="hljs-keyword">var</span> selections = <span class="hljs-keyword">this</span>._transformSelections(fragment.selectionSet, type, fragment.typeCondition);

    <span class="hljs-keyword">var</span> argumentDefinitions = (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(buildArgumentDefinitions(<span class="hljs-keyword">this</span>._variableDefinitions));

    <span class="hljs-keyword">var</span> _iterator2 = _createForOfIteratorHelper(<span class="hljs-keyword">this</span>._unknownVariables),
        _step2;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">for</span> (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        <span class="hljs-keyword">var</span> _step2$value = _step2.value,
            name = _step2$value[<span class="hljs-number">0</span>],
            variableReference = _step2$value[<span class="hljs-number">1</span>];
        argumentDefinitions.push({
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'RootArgumentDefinition'</span>,
          <span class="hljs-attr">loc</span>: buildLocation(variableReference.ast.loc),
          <span class="hljs-attr">name</span>: name,
          <span class="hljs-attr">type</span>: variableReference.type
        });
      }
    } <span class="hljs-keyword">catch</span> (err) {
      _iterator2.e(err);
    } <span class="hljs-keyword">finally</span> {
      _iterator2.f();
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Fragment'</span>,
      <span class="hljs-attr">directives</span>: directives,
      <span class="hljs-attr">loc</span>: buildLocation(fragment.loc),
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">name</span>: getName(fragment),
      <span class="hljs-attr">selections</span>: selections,
      <span class="hljs-attr">type</span>: type,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-83" id="section-83"></a>
</div>
<p>$FlowFixMe[incompatible-return] - could be null</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      argumentDefinitions: argumentDefinitions
    };
  };

  _proto2._getLocationFromOperation = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_getLocationFromOperation</span>(<span class="hljs-params">definition</span>) </span>{
    <span class="hljs-keyword">switch</span> (definition.operation) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'query'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'QUERY'</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'mutation'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'MUTATION'</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'subscription'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'SUBSCRIPTION'</span>;

      <span class="hljs-keyword">default</span>:
        definition.operation;
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unknown operation type '"</span>.concat(definition.operation, <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [definition]);
    }
  };

  _proto2._transformOperation = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_transformOperation</span>(<span class="hljs-params">definition</span>) </span>{
    <span class="hljs-keyword">var</span> name = getName(definition);

    <span class="hljs-keyword">var</span> directives = <span class="hljs-keyword">this</span>._transformDirectives(definition.directives || [], <span class="hljs-keyword">this</span>._getLocationFromOperation(definition));

    <span class="hljs-keyword">var</span> type;
    <span class="hljs-keyword">var</span> operation;
    <span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">this</span>._schema;

    <span class="hljs-keyword">switch</span> (definition.operation) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'query'</span>:
        operation = <span class="hljs-string">'query'</span>;
        type = schema.expectQueryType();
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'mutation'</span>:
        operation = <span class="hljs-string">'mutation'</span>;
        type = schema.expectMutationType();
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'subscription'</span>:
        operation = <span class="hljs-string">'subscription'</span>;
        type = schema.expectSubscriptionType();
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">default</span>:
        definition.operation;
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unknown operation type '"</span>.concat(definition.operation, <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [definition]);
    }

    <span class="hljs-keyword">if</span> (!definition.selectionSet) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Expected operation to have selections.'</span>, <span class="hljs-literal">null</span>, [definition]);
    }

    <span class="hljs-keyword">var</span> selections = <span class="hljs-keyword">this</span>._transformSelections(definition.selectionSet, type);

    <span class="hljs-keyword">var</span> argumentDefinitions = buildArgumentDefinitions(<span class="hljs-keyword">this</span>._variableDefinitions);

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._unknownVariables.size !== <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Query '"</span>.concat(name, <span class="hljs-string">"' references undefined variables."</span>), <span class="hljs-literal">null</span>, <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">this</span>._unknownVariables.values(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">variableReference</span>) </span>{
        <span class="hljs-keyword">return</span> variableReference.ast;
      }));
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Root'</span>,
      <span class="hljs-attr">operation</span>: operation,
      <span class="hljs-attr">loc</span>: buildLocation(definition.loc),
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">name</span>: name,
      <span class="hljs-attr">argumentDefinitions</span>: argumentDefinitions,
      <span class="hljs-attr">directives</span>: directives,
      <span class="hljs-attr">selections</span>: selections,
      <span class="hljs-attr">type</span>: type
    };
  };

  _proto2._transformSelections = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_transformSelections</span>(<span class="hljs-params">selectionSet, parentType, parentTypeAST</span>) </span>{
    <span class="hljs-keyword">var</span> _this4 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">return</span> selectionSet.selections.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
      <span class="hljs-keyword">var</span> node;

      <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'Field'</span>) {
        node = _this4._transformField(selection, parentType);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'FragmentSpread'</span>) {
        node = _this4._transformFragmentSpread(selection, parentType, parentTypeAST);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'InlineFragment'</span>) {
        node = _this4._transformInlineFragment(selection, parentType, parentTypeAST);
      } <span class="hljs-keyword">else</span> {
        selection.kind;
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unknown ast kind '"</span>.concat(selection.kind, <span class="hljs-string">"'."</span>), [selection]);
      }

      <span class="hljs-keyword">var</span> _this4$_splitConditio = _this4._splitConditions(node.directives),
          conditions = _this4$_splitConditio[<span class="hljs-number">0</span>],
          directives = _this4$_splitConditio[<span class="hljs-number">1</span>];

      <span class="hljs-keyword">var</span> conditionalNodes = applyConditions(conditions, <span class="hljs-comment">// $FlowFixMe[incompatible-call]</span>
      [_objectSpread(_objectSpread({}, node), {}, {
        <span class="hljs-attr">directives</span>: directives
      })]);

      <span class="hljs-keyword">if</span> (conditionalNodes.length !== <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Expected exactly one condition node.'</span>, <span class="hljs-literal">null</span>, selection.directives);
      }

      <span class="hljs-keyword">return</span> conditionalNodes[<span class="hljs-number">0</span>];
    });
  };

  _proto2._transformInlineFragment = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_transformInlineFragment</span>(<span class="hljs-params">fragment, parentType, parentTypeAST</span>) </span>{
    <span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">this</span>._schema;
    <span class="hljs-keyword">var</span> typeCondition = fragment.typeCondition != <span class="hljs-literal">null</span> ? schema.getTypeFromAST(fragment.typeCondition) : parentType;

    <span class="hljs-keyword">if</span> (typeCondition == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> _fragment$typeConditi;

      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Inline fragments can only be on object, interface or union types'</span> + <span class="hljs-string">", got unknown type '"</span>.concat(getTypeName(fragment.typeCondition), <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [(_fragment$typeConditi = fragment.typeCondition) !== <span class="hljs-literal">null</span> &amp;&amp; _fragment$typeConditi !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _fragment$typeConditi : fragment]);
    }

    <span class="hljs-keyword">var</span> typeConditionName = schema.getTypeString(typeCondition);
    typeCondition = schema.asCompositeType(typeCondition);

    <span class="hljs-keyword">if</span> (typeCondition == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> _fragment$typeConditi2;

      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Inline fragments can only be on object, interface or union types'</span> + <span class="hljs-string">", got '"</span>.concat(typeConditionName, <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [(_fragment$typeConditi2 = fragment.typeCondition) !== <span class="hljs-literal">null</span> &amp;&amp; _fragment$typeConditi2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _fragment$typeConditi2 : fragment]);
    }

    <span class="hljs-keyword">var</span> rawParentType = <span class="hljs-keyword">this</span>._schema.assertCompositeType(<span class="hljs-keyword">this</span>._schema.getRawType(parentType));

    checkFragmentSpreadTypeCompatibility(<span class="hljs-keyword">this</span>._schema, typeCondition, rawParentType, <span class="hljs-literal">null</span>, fragment.typeCondition, parentTypeAST);

    <span class="hljs-keyword">var</span> directives = <span class="hljs-keyword">this</span>._transformDirectives(fragment.directives || [], <span class="hljs-string">'INLINE_FRAGMENT'</span>);

    <span class="hljs-keyword">var</span> selections = <span class="hljs-keyword">this</span>._transformSelections(fragment.selectionSet, typeCondition, fragment.typeCondition);

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineFragment'</span>,
      <span class="hljs-attr">directives</span>: directives,
      <span class="hljs-attr">loc</span>: buildLocation(fragment.loc),
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">selections</span>: selections,
      <span class="hljs-attr">typeCondition</span>: typeCondition
    };
  };

  _proto2._transformFragmentSpread = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_transformFragmentSpread</span>(<span class="hljs-params">fragmentSpread, parentType, parentTypeAST</span>) </span>{
    <span class="hljs-keyword">var</span> _this5 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> fragmentName = getName(fragmentSpread);

    <span class="hljs-keyword">var</span> _partitionArray = partitionArray(fragmentSpread.directives || [], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">var</span> name = getName(directive);
      <span class="hljs-keyword">return</span> name === ARGUMENTS || name === DEPRECATED_UNCHECKED_ARGUMENTS;
    }),
        argumentDirectives = _partitionArray[<span class="hljs-number">0</span>],
        otherDirectives = _partitionArray[<span class="hljs-number">1</span>];

    <span class="hljs-keyword">if</span> (argumentDirectives.length &gt; <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Directive @"</span>.concat(ARGUMENTS, <span class="hljs-string">" may be used at most once per a fragment spread."</span>), <span class="hljs-literal">null</span>, argumentDirectives);
    }

    <span class="hljs-keyword">var</span> fragmentDefinition = <span class="hljs-keyword">this</span>._entries.get(fragmentName);

    <span class="hljs-keyword">if</span> (fragmentDefinition == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unknown fragment '"</span>.concat(fragmentName, <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [fragmentSpread.name]);
    }

    <span class="hljs-keyword">var</span> fragmentTypeNode = getFragmentType(fragmentDefinition.definition);

    <span class="hljs-keyword">var</span> fragmentType = <span class="hljs-keyword">this</span>._schema.assertCompositeType(<span class="hljs-keyword">this</span>._schema.expectTypeFromAST(fragmentTypeNode));

    <span class="hljs-keyword">var</span> rawParentType = <span class="hljs-keyword">this</span>._schema.assertCompositeType(<span class="hljs-keyword">this</span>._schema.getRawType(parentType));

    checkFragmentSpreadTypeCompatibility(<span class="hljs-keyword">this</span>._schema, fragmentType, rawParentType, fragmentSpread.name.value, fragmentSpread, parentTypeAST);
    <span class="hljs-keyword">var</span> fragmentArgumentDefinitions = fragmentDefinition.variableDefinitions;
    <span class="hljs-keyword">var</span> argumentsDirective = argumentDirectives[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">var</span> args;

    <span class="hljs-keyword">if</span> (argumentsDirective != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> isDeprecatedUncheckedArguments = getName(argumentsDirective) === DEPRECATED_UNCHECKED_ARGUMENTS;
      <span class="hljs-keyword">var</span> hasInvalidArgument = <span class="hljs-literal">false</span>;
      args = (argumentsDirective.arguments || []).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
        <span class="hljs-keyword">var</span> _argumentDefinition$t;

        <span class="hljs-keyword">var</span> argName = getName(arg);
        <span class="hljs-keyword">var</span> argValue = arg.value;
        <span class="hljs-keyword">var</span> argumentDefinition = fragmentArgumentDefinitions.get(argName);
        <span class="hljs-keyword">var</span> argumentType = (_argumentDefinition$t = argumentDefinition === <span class="hljs-literal">null</span> || argumentDefinition === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : argumentDefinition.type) !== <span class="hljs-literal">null</span> &amp;&amp; _argumentDefinition$t !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _argumentDefinition$t : <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (argValue.kind === <span class="hljs-string">'Variable'</span>) {
          <span class="hljs-keyword">if</span> (argumentDefinition == <span class="hljs-literal">null</span> &amp;&amp; !isDeprecatedUncheckedArguments) {
            <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Variable @"</span>.concat(ARGUMENTS, <span class="hljs-string">" values are only supported when the "</span>) + <span class="hljs-string">"argument is defined with @"</span>.concat(ARGUMENT_DEFINITIONS, <span class="hljs-string">". Check "</span>) + <span class="hljs-string">"the definition of fragment '"</span>.concat(fragmentName, <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [arg.value, fragmentDefinition.definition]);
          }

          hasInvalidArgument = hasInvalidArgument || argumentDefinition == <span class="hljs-literal">null</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> check the type of the variable and use the type</span>

          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
            <span class="hljs-attr">loc</span>: buildLocation(arg.loc),
            <span class="hljs-attr">name</span>: argName,
            <span class="hljs-attr">value</span>: _this5._transformVariable(argValue, <span class="hljs-literal">null</span>),
            <span class="hljs-attr">type</span>: <span class="hljs-literal">null</span>
          };
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (argumentType == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Literal @"</span>.concat(ARGUMENTS, <span class="hljs-string">" values are only supported when the "</span>) + <span class="hljs-string">"argument is defined with @"</span>.concat(ARGUMENT_DEFINITIONS, <span class="hljs-string">". Check "</span>) + <span class="hljs-string">"the definition of fragment '"</span>.concat(fragmentName, <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [arg.value, fragmentDefinition.definition]);
          }

          <span class="hljs-keyword">var</span> value = _this5._transformValue(argValue, argumentType);

          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
            <span class="hljs-attr">loc</span>: buildLocation(arg.loc),
            <span class="hljs-attr">name</span>: argName,
            <span class="hljs-attr">value</span>: value,
            <span class="hljs-attr">type</span>: argumentType
          };
        }
      });

      <span class="hljs-keyword">if</span> (isDeprecatedUncheckedArguments &amp;&amp; !hasInvalidArgument) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @"</span>.concat(DEPRECATED_UNCHECKED_ARGUMENTS, <span class="hljs-string">": all arguments "</span>) + <span class="hljs-string">"are defined, use @"</span>.concat(ARGUMENTS, <span class="hljs-string">" instead."</span>), <span class="hljs-literal">null</span>, [argumentsDirective]);
      }
    }

    <span class="hljs-keyword">var</span> directives = <span class="hljs-keyword">this</span>._transformDirectives(otherDirectives, <span class="hljs-string">'FRAGMENT_SPREAD'</span>);

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'FragmentSpread'</span>,
      <span class="hljs-attr">args</span>: args || [],
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">loc</span>: buildLocation(fragmentSpread.loc),
      <span class="hljs-attr">name</span>: fragmentName,
      <span class="hljs-attr">directives</span>: directives
    };
  };

  _proto2._transformField = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_transformField</span>(<span class="hljs-params">field, parentType</span>) </span>{
    <span class="hljs-keyword">var</span> _field$alias$value, _field$alias;

    <span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">this</span>._schema;
    <span class="hljs-keyword">var</span> name = getName(field);

    <span class="hljs-keyword">var</span> fieldDef = <span class="hljs-keyword">this</span>._getFieldDefinition(schema, parentType, name, field);

    <span class="hljs-keyword">if</span> (fieldDef == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unknown field '"</span>.concat(name, <span class="hljs-string">"' on type '"</span>).concat(schema.getTypeString(parentType), <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [field]);
    }

    <span class="hljs-keyword">var</span> alias = (_field$alias$value = (_field$alias = field.alias) === <span class="hljs-literal">null</span> || _field$alias === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _field$alias.value) !== <span class="hljs-literal">null</span> &amp;&amp; _field$alias$value !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _field$alias$value : name;

    <span class="hljs-keyword">var</span> args = <span class="hljs-keyword">this</span>._transformArguments(field.arguments || [], schema.getFieldArgs(fieldDef), fieldDef);

    <span class="hljs-keyword">var</span> _partitionArray2 = partitionArray(field.directives || [], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> getName(directive) !== CLIENT_FIELD;
    }),
        otherDirectives = _partitionArray2[<span class="hljs-number">0</span>],
        clientFieldDirectives = _partitionArray2[<span class="hljs-number">1</span>];

    <span class="hljs-keyword">var</span> directives = <span class="hljs-keyword">this</span>._transformDirectives(otherDirectives, <span class="hljs-string">'FIELD'</span>);

    <span class="hljs-keyword">var</span> type = schema.getFieldType(fieldDef);

    <span class="hljs-keyword">var</span> handles = <span class="hljs-keyword">this</span>._transformHandle(name, args, clientFieldDirectives);

    <span class="hljs-keyword">if</span> (schema.isLeafType(schema.getRawType(type))) {
      <span class="hljs-keyword">if</span> (field.selectionSet &amp;&amp; field.selectionSet.selections &amp;&amp; field.selectionSet.selections.length) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected no selections for scalar field '"</span>.concat(name, <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [field]);
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'ScalarField'</span>,
        <span class="hljs-attr">alias</span>: alias,
        <span class="hljs-attr">args</span>: args,
        <span class="hljs-attr">directives</span>: directives,
        <span class="hljs-attr">handles</span>: handles,
        <span class="hljs-attr">loc</span>: buildLocation(field.loc),
        <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">name</span>: name,
        <span class="hljs-attr">type</span>: schema.assertScalarFieldType(type)
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> selections = field.selectionSet ? <span class="hljs-keyword">this</span>._transformSelections(field.selectionSet, type) : <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (selections == <span class="hljs-literal">null</span> || selections.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected at least one selection for non-scalar field '"</span>.concat(name, <span class="hljs-string">"' on type '"</span>).concat(schema.getTypeString(type), <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [field]);
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkedField'</span>,
        <span class="hljs-attr">alias</span>: alias,
        <span class="hljs-attr">args</span>: args,
        <span class="hljs-attr">connection</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">directives</span>: directives,
        <span class="hljs-attr">handles</span>: handles,
        <span class="hljs-attr">loc</span>: buildLocation(field.loc),
        <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">name</span>: name,
        <span class="hljs-attr">selections</span>: selections,
        <span class="hljs-attr">type</span>: schema.assertLinkedFieldType(type)
      };
    }
  };

  _proto2._transformHandle = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_transformHandle</span>(<span class="hljs-params">fieldName, fieldArgs, clientFieldDirectives</span>) </span>{
    <span class="hljs-keyword">var</span> handles = <span class="hljs-literal">null</span>;
    clientFieldDirectives.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clientFieldDirective</span>) </span>{
      <span class="hljs-keyword">var</span> handleArgument = (clientFieldDirective.arguments || []).find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
        <span class="hljs-keyword">return</span> getName(arg) === CLIENT_FIELD_HANDLE;
      });

      <span class="hljs-keyword">if</span> (handleArgument) {
        <span class="hljs-keyword">var</span> name = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> key = DEFAULT_HANDLE_KEY;
        <span class="hljs-keyword">var</span> filters = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> maybeHandle = transformLiteralValue(handleArgument.value, handleArgument);

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> maybeHandle !== <span class="hljs-string">'string'</span>) {
          <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected a string literal argument for the @"</span>.concat(CLIENT_FIELD, <span class="hljs-string">" directive."</span>), <span class="hljs-literal">null</span>, [handleArgument.value]);
        }

        name = maybeHandle;
        <span class="hljs-keyword">var</span> keyArgument = (clientFieldDirective.arguments || []).find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
          <span class="hljs-keyword">return</span> getName(arg) === CLIENT_FIELD_KEY;
        });

        <span class="hljs-keyword">if</span> (keyArgument) {
          <span class="hljs-keyword">var</span> maybeKey = transformLiteralValue(keyArgument.value, keyArgument);

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> maybeKey !== <span class="hljs-string">'string'</span>) {
            <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected a string literal argument for the @"</span>.concat(CLIENT_FIELD, <span class="hljs-string">" directive."</span>), <span class="hljs-literal">null</span>, [keyArgument.value]);
          }

          key = maybeKey;
        }

        <span class="hljs-keyword">var</span> filtersArgument = (clientFieldDirective.arguments || []).find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
          <span class="hljs-keyword">return</span> getName(arg) === CLIENT_FIELD_FILTERS;
        });

        <span class="hljs-keyword">if</span> (filtersArgument) {
          <span class="hljs-keyword">var</span> maybeFilters = transformLiteralValue(filtersArgument.value, filtersArgument);

          <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">Array</span>.isArray(maybeFilters) &amp;&amp; maybeFilters.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">filter</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> filter === <span class="hljs-string">'string'</span> &amp;&amp; fieldArgs.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fieldArg</span>) </span>{
              <span class="hljs-keyword">return</span> fieldArg.name === filter;
            });
          }))) {
            <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected an array of argument names on field '"</span>.concat(fieldName, <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [filtersArgument.value]);
          } <span class="hljs-comment">// $FlowFixMe[incompatible-cast]</span>


          filters = maybeFilters;
        }

        <span class="hljs-keyword">var</span> dynamicKeyArgument = (clientFieldDirective.arguments || []).find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
          <span class="hljs-keyword">return</span> getName(arg) === <span class="hljs-string">'dynamicKey_UNSTABLE'</span>;
        });

        <span class="hljs-keyword">if</span> (dynamicKeyArgument != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Dynamic keys are only supported with @connection.'</span>, <span class="hljs-literal">null</span>, [dynamicKeyArgument.value]);
        }

        handles = handles || [];
        handles.push({
          <span class="hljs-attr">name</span>: name,
          <span class="hljs-attr">key</span>: key,
          <span class="hljs-attr">filters</span>: filters,
          <span class="hljs-attr">dynamicKey</span>: <span class="hljs-literal">null</span>
        });
      }
    });
    <span class="hljs-keyword">return</span> handles;
  };

  _proto2._transformDirectives = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_transformDirectives</span>(<span class="hljs-params">directives, location</span>) </span>{
    <span class="hljs-keyword">var</span> _this6 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">this</span>._validateDirectivesLocation(directives, location);

    <span class="hljs-keyword">return</span> directives.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">var</span> name = getName(directive);

      <span class="hljs-keyword">var</span> directiveDef = _this6._schema.getDirective(name);

      <span class="hljs-keyword">if</span> (directiveDef == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unknown directive '"</span>.concat(name, <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [directive]);
      }

      <span class="hljs-keyword">var</span> args = _this6._transformArguments(directive.arguments || [], directiveDef.args.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">name</span>: item.name,
          <span class="hljs-attr">type</span>: item.type,
          <span class="hljs-attr">defaultValue</span>: item.defaultValue
        };
      }), <span class="hljs-literal">null</span>, name);

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Directive'</span>,
        <span class="hljs-attr">loc</span>: buildLocation(directive.loc),
        <span class="hljs-attr">name</span>: name,
        <span class="hljs-attr">args</span>: args
      };
    });
  };

  _proto2._transformArguments = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_transformArguments</span>(<span class="hljs-params">args, argumentDefinitions, field, directiveName</span>) </span>{
    <span class="hljs-keyword">var</span> _this7 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">return</span> args.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">var</span> argName = getName(arg);
      <span class="hljs-keyword">var</span> argDef = argumentDefinitions.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">def</span>) </span>{
        <span class="hljs-keyword">return</span> def.name === argName;
      });

      <span class="hljs-keyword">if</span> (argDef == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> message = <span class="hljs-string">"Unknown argument '"</span>.concat(argName, <span class="hljs-string">"'"</span>) + (field ? <span class="hljs-string">" on field '"</span>.concat(_this7._schema.getFieldName(field), <span class="hljs-string">"'"</span>) + <span class="hljs-string">" of type '"</span>.concat(_this7._schema.getTypeString(_this7._schema.getFieldParentType(field)), <span class="hljs-string">"'."</span>) : directiveName != <span class="hljs-literal">null</span> ? <span class="hljs-string">" on directive '@"</span>.concat(directiveName, <span class="hljs-string">"'."</span>) : <span class="hljs-string">'.'</span>);
        <span class="hljs-keyword">throw</span> createUserError(message, <span class="hljs-literal">null</span>, [arg]);
      }

      <span class="hljs-keyword">var</span> value = _this7._transformValue(arg.value, argDef.type);

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
        <span class="hljs-attr">loc</span>: buildLocation(arg.loc),
        <span class="hljs-attr">name</span>: argName,
        <span class="hljs-attr">value</span>: value,
        <span class="hljs-attr">type</span>: argDef.type
      };
    });
  };

  _proto2._splitConditions = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_splitConditions</span>(<span class="hljs-params">mixedDirectives</span>) </span>{
    <span class="hljs-keyword">var</span> _partitionArray3 = partitionArray(mixedDirectives, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> directive.name === INCLUDE || directive.name === SKIP;
    }),
        conditionDirectives = _partitionArray3[<span class="hljs-number">0</span>],
        otherDirectives = _partitionArray3[<span class="hljs-number">1</span>];

    <span class="hljs-keyword">var</span> conditions = conditionDirectives.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">var</span> passingValue = directive.name === INCLUDE;
      <span class="hljs-keyword">var</span> arg = directive.args[<span class="hljs-number">0</span>];

      <span class="hljs-keyword">if</span> (arg == <span class="hljs-literal">null</span> || arg.name !== IF) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected an 'if' argument to @"</span>.concat(directive.name, <span class="hljs-string">"."</span>), [directive.loc]);
      }

      <span class="hljs-keyword">if</span> (!(arg.value.kind === <span class="hljs-string">'Variable'</span> || arg.value.kind === <span class="hljs-string">'Literal'</span>)) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected the 'if' argument to @"</span>.concat(directive.name, <span class="hljs-string">" to be a variable or literal."</span>), [directive.loc]);
      }

      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Condition'</span>,
        <span class="hljs-attr">condition</span>: arg.value,
        <span class="hljs-attr">loc</span>: directive.loc,
        <span class="hljs-attr">passingValue</span>: passingValue,
        <span class="hljs-attr">selections</span>: []
      };
    });
    <span class="hljs-keyword">var</span> sortedConditions = conditions.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
      <span class="hljs-keyword">if</span> (a.condition.kind === <span class="hljs-string">'Variable'</span> &amp;&amp; b.condition.kind === <span class="hljs-string">'Variable'</span>) {
        <span class="hljs-keyword">return</span> a.condition.variableName &lt; b.condition.variableName ? <span class="hljs-number">-1</span> : a.condition.variableName &gt; b.condition.variableName ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-84" id="section-84"></a>
</div>
<p>sort literals earlier, variables later</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> a.condition.kind === <span class="hljs-string">'Variable'</span> ? <span class="hljs-number">1</span> : b.condition.kind === <span class="hljs-string">'Variable'</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">0</span>;
      }
    });
    <span class="hljs-keyword">return</span> [sortedConditions, otherDirectives];
  };

  _proto2._transformVariable = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_transformVariable</span>(<span class="hljs-params">ast, usedAsType</span>) </span>{
    <span class="hljs-keyword">var</span> variableName = getName(ast);

    <span class="hljs-keyword">this</span>._recordAndVerifyVariableReference(ast, variableName, usedAsType);

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Variable'</span>,
      <span class="hljs-attr">loc</span>: buildLocation(ast.loc),
      <span class="hljs-attr">variableName</span>: variableName,
      <span class="hljs-attr">type</span>: usedAsType
    };
  };

  _proto2._transformValue = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_transformValue</span>(<span class="hljs-params">ast, type</span>) </span>{
    <span class="hljs-keyword">var</span> _this8 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">return</span> transformValue(<span class="hljs-keyword">this</span>._schema, ast, type, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">variableAst, variableType</span>) </span>{
      <span class="hljs-keyword">return</span> _this8._transformVariable(variableAst, variableType);
    });
  };

  <span class="hljs-keyword">return</span> GraphQLDefinitionParser;
}();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-85" id="section-85"></a>
</div>
<div class="dox">
<div class="summary">
<p>Transforms and validates argument values according to the expected
type.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformValue</span>(<span class="hljs-params">schema, ast, type, transformVariable</span>) </span>{
  <span class="hljs-keyword">if</span> (ast.kind === <span class="hljs-string">'Variable'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-86" id="section-86"></a>
</div>
<p>Special case variables since there is no value to parse</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> transformVariable(ast, type);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ast.kind === <span class="hljs-string">'NullValue'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-87" id="section-87"></a>
</div>
<p>Special case null literals since there is no value to parse</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (schema.isNonNull(type)) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected a value matching type '"</span>.concat(<span class="hljs-built_in">String</span>(type), <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [ast]);
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
      <span class="hljs-attr">loc</span>: buildLocation(ast.loc),
      <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span>
    };
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> transformNonNullLiteral(schema, ast, type, transformVariable);
  }
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-88" id="section-88"></a>
</div>
<div class="dox">
<div class="summary">
<p>Transforms and validates non-null literal (non-variable) values
according to the expected type.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformNonNullLiteral</span>(<span class="hljs-params">schema, ast, type, transformVariable</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-89" id="section-89"></a>
</div>
<p>Transform the value based on the type without a non-null wrapper.
Note that error messages should still use the original <code>type</code>
since that accurately describes to the user what the expected
type is (using nullableType would suggest that <code>null</code> is legal
even when it may not be, for example).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> nullableType = schema.getNullableType(type);

  <span class="hljs-keyword">if</span> (schema.isList(nullableType)) {
    <span class="hljs-keyword">if</span> (ast.kind !== <span class="hljs-string">'ListValue'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-90" id="section-90"></a>
</div>
<p>Parse singular (non-list) values flowing into a list type
as scalars, ie without wrapping them in an array.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (!schema.isInputType(schema.getListItemType(nullableType))) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected type "</span>.concat(schema.getTypeString(nullableType), <span class="hljs-string">" to be an input type."</span>), <span class="hljs-literal">null</span>, [ast]);
      }

      <span class="hljs-keyword">return</span> transformValue(schema, ast, schema.assertInputType(schema.getListItemType(nullableType)), transformVariable);
    }

    <span class="hljs-keyword">var</span> itemType = schema.assertInputType(schema.getListItemType(nullableType));
    <span class="hljs-keyword">var</span> literalList = [];
    <span class="hljs-keyword">var</span> items = [];
    <span class="hljs-keyword">var</span> areAllItemsScalar = <span class="hljs-literal">true</span>;
    ast.values.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
      <span class="hljs-keyword">var</span> itemValue = transformValue(schema, item, itemType, transformVariable);

      <span class="hljs-keyword">if</span> (itemValue.kind === <span class="hljs-string">'Literal'</span>) {
        literalList.push(itemValue.value);
      }

      items.push(itemValue);
      areAllItemsScalar = areAllItemsScalar &amp;&amp; itemValue.kind === <span class="hljs-string">'Literal'</span>;
    });

    <span class="hljs-keyword">if</span> (areAllItemsScalar) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">loc</span>: buildLocation(ast.loc),
        <span class="hljs-attr">value</span>: literalList
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'ListValue'</span>,
        <span class="hljs-attr">loc</span>: buildLocation(ast.loc),
        <span class="hljs-attr">items</span>: items
      };
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isInputObject(nullableType)) {
    <span class="hljs-keyword">if</span> (ast.kind !== <span class="hljs-string">'ObjectValue'</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected a value matching type '"</span>.concat(schema.getTypeString(type), <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [ast]);
    }

    <span class="hljs-keyword">var</span> literalObject = {};
    <span class="hljs-keyword">var</span> fields = [];
    <span class="hljs-keyword">var</span> areAllFieldsScalar = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> inputType = schema.assertInputObjectType(nullableType);
    <span class="hljs-keyword">var</span> requiredFieldNames = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(schema.getFields(inputType).filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field</span>) </span>{
      <span class="hljs-keyword">return</span> schema.isNonNull(schema.getFieldType(field));
    }).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field</span>) </span>{
      <span class="hljs-keyword">return</span> schema.getFieldName(field);
    }));
    <span class="hljs-keyword">var</span> seenFields = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    ast.fields.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field</span>) </span>{
      <span class="hljs-keyword">var</span> fieldName = getName(field);
      <span class="hljs-keyword">var</span> seenField = seenFields.get(fieldName);

      <span class="hljs-keyword">if</span> (seenField) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Duplicated field name '"</span>.concat(fieldName, <span class="hljs-string">"' in the input object."</span>), <span class="hljs-literal">null</span>, [field, seenField]);
      }

      <span class="hljs-keyword">var</span> fieldID = schema.getFieldByName(inputType, fieldName);

      <span class="hljs-keyword">if</span> (!fieldID) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unknown field '"</span>.concat(fieldName, <span class="hljs-string">"' on type '"</span>).concat(schema.getTypeString(inputType), <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [field]);
      }

      <span class="hljs-keyword">var</span> fieldConfig = schema.getFieldConfig(fieldID);
      <span class="hljs-keyword">var</span> fieldType = schema.assertInputType(fieldConfig.type);
      <span class="hljs-keyword">var</span> fieldValue = transformValue(schema, field.value, fieldType, transformVariable);

      <span class="hljs-keyword">if</span> (fieldValue.kind === <span class="hljs-string">'Literal'</span>) {
        literalObject[field.name.value] = fieldValue.value;
      }

      fields.push({
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'ObjectFieldValue'</span>,
        <span class="hljs-attr">loc</span>: buildLocation(field.loc),
        <span class="hljs-attr">name</span>: fieldName,
        <span class="hljs-attr">value</span>: fieldValue
      });
      seenFields.set(fieldName, field);
      requiredFieldNames[<span class="hljs-string">"delete"</span>](fieldName);
      areAllFieldsScalar = areAllFieldsScalar &amp;&amp; fieldValue.kind === <span class="hljs-string">'Literal'</span>;
    });

    <span class="hljs-keyword">if</span> (requiredFieldNames.size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> requiredFieldStr = <span class="hljs-built_in">Array</span>.from(requiredFieldNames).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"'"</span>.concat(item, <span class="hljs-string">"'"</span>);
      }).join(<span class="hljs-string">', '</span>);
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Missing non-optional field"</span>.concat(requiredFieldNames.size &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">'s:'</span> : <span class="hljs-string">''</span>, <span class="hljs-string">" "</span>).concat(requiredFieldStr, <span class="hljs-string">" for input type '"</span>).concat(schema.getTypeString(inputType), <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [ast]);
    }

    <span class="hljs-keyword">if</span> (areAllFieldsScalar) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">loc</span>: buildLocation(ast.loc),
        <span class="hljs-attr">value</span>: literalObject
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'ObjectValue'</span>,
        <span class="hljs-attr">loc</span>: buildLocation(ast.loc),
        <span class="hljs-attr">fields</span>: fields
      };
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isId(nullableType)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-91" id="section-91"></a>
</div>
<p>GraphQLID's parseLiteral() always returns the string value. However
the int/string distinction may be important at runtime, so this
transform parses int/string literals into the corresponding JS types.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (ast.kind === <span class="hljs-string">'IntValue'</span>) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">loc</span>: buildLocation(ast.loc),
        <span class="hljs-attr">value</span>: <span class="hljs-built_in">parseInt</span>(ast.value, <span class="hljs-number">10</span>)
      };
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ast.kind === <span class="hljs-string">'StringValue'</span>) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">loc</span>: buildLocation(ast.loc),
        <span class="hljs-attr">value</span>: ast.value
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid value, expected a value matching type '"</span>.concat(schema.getTypeString(type), <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [ast]);
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isEnum(nullableType)) {
    <span class="hljs-keyword">var</span> enumType = schema.assertEnumType(nullableType);
    <span class="hljs-keyword">var</span> value = schema.parseLiteral(enumType, ast);

    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> suggestions = schema.getEnumValues(enumType); <span class="hljs-comment">// parseLiteral() should return a non-null JavaScript value</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-92" id="section-92"></a>
</div>
<p>if the ast value is valid for the type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected a value matching type '"</span>.concat(schema.getTypeString(type), <span class="hljs-string">"'. Possible values: "</span>).concat(orList(suggestions), <span class="hljs-string">"?'"</span>), <span class="hljs-literal">null</span>, [ast]);
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
      <span class="hljs-attr">loc</span>: buildLocation(ast.loc),
      <span class="hljs-attr">value</span>: value
    };
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isScalar(nullableType)) {
    <span class="hljs-keyword">var</span> _value = schema.parseLiteral(schema.assertScalarType(nullableType), ast);

    <span class="hljs-keyword">if</span> (_value == <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-93" id="section-93"></a>
</div>
<p>parseLiteral() should return a non-null JavaScript value
if the ast value is valid for the type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected a value matching type '"</span>.concat(schema.getTypeString(type), <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [ast]);
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
      <span class="hljs-attr">loc</span>: buildLocation(ast.loc),
      <span class="hljs-attr">value</span>: _value
    };
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unsupported type '"</span>.concat(schema.getTypeString(type), <span class="hljs-string">"' for input value, expected a GraphQLList, "</span>) + <span class="hljs-string">'GraphQLInputObjectType, GraphQLEnumType, or GraphQLScalarType.'</span>, <span class="hljs-literal">null</span>, [ast]);
  }
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-94" id="section-94"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformLiteralValue</span>(<span class="hljs-params">ast, context</span>) </span>{
  <span class="hljs-keyword">switch</span> (ast.kind) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'IntValue'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(ast.value, <span class="hljs-number">10</span>);

    <span class="hljs-keyword">case</span> <span class="hljs-string">'FloatValue'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseFloat</span>(ast.value);

    <span class="hljs-keyword">case</span> <span class="hljs-string">'StringValue'</span>:
      <span class="hljs-keyword">return</span> ast.value;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'BooleanValue'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-95" id="section-95"></a>
</div>
<p>Note: duplicated because Flow does not understand fall-through cases</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> ast.value;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'EnumValue'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-96" id="section-96"></a>
</div>
<p>Note: duplicated because Flow does not understand fall-through cases</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> ast.value;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'ListValue'</span>:
      <span class="hljs-keyword">return</span> ast.values.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
        <span class="hljs-keyword">return</span> transformLiteralValue(item, context);
      });

    <span class="hljs-keyword">case</span> <span class="hljs-string">'NullValue'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'ObjectValue'</span>:
      {
        <span class="hljs-keyword">var</span> objectValue = {};
        ast.fields.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field</span>) </span>{
          <span class="hljs-keyword">var</span> fieldName = getName(field);
          <span class="hljs-keyword">var</span> value = transformLiteralValue(field.value, context);
          objectValue[fieldName] = value;
        });
        <span class="hljs-keyword">return</span> objectValue;
      }

    <span class="hljs-keyword">case</span> <span class="hljs-string">'Variable'</span>:
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Unexpected variable where a literal (static) value is required.'</span>, <span class="hljs-literal">null</span>, [ast, context]);

    <span class="hljs-keyword">default</span>:
      ast.kind;
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unknown ast kind '"</span>.concat(ast.kind, <span class="hljs-string">"'."</span>), [ast]);
  }
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-97" id="section-97"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildArgumentDefinitions</span>(<span class="hljs-params">variables</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(variables.values(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref3</span>) </span>{
    <span class="hljs-keyword">var</span> ast = _ref3.ast,
        name = _ref3.name,
        defaultValue = _ref3.defaultValue,
        type = _ref3.type;
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'LocalArgumentDefinition'</span>,
      <span class="hljs-attr">loc</span>: buildLocation(ast.loc),
      <span class="hljs-attr">name</span>: name,
      <span class="hljs-attr">type</span>: type,
      <span class="hljs-attr">defaultValue</span>: defaultValue
    };
  });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-98" id="section-98"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildLocation</span>(<span class="hljs-params">loc</span>) </span>{
  <span class="hljs-keyword">if</span> (loc == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Unknown'</span>
    };
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Source'</span>,
    <span class="hljs-attr">start</span>: loc.start,
    <span class="hljs-attr">end</span>: loc.end,
    <span class="hljs-attr">source</span>: loc.source
  };
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-99" id="section-99"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyConditions</span>(<span class="hljs-params">conditions, selections</span>) </span>{
  <span class="hljs-keyword">var</span> nextSelections = selections;
  conditions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">condition</span>) </span>{
    nextSelections = [_objectSpread(_objectSpread({}, condition), {}, {
      <span class="hljs-attr">selections</span>: nextSelections
    })];
  });
  <span class="hljs-keyword">return</span> nextSelections;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-100" id="section-100"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params">ast</span>) </span>{
  <span class="hljs-keyword">var</span> _ast$name;

  <span class="hljs-keyword">var</span> name = (_ast$name = ast.name) === <span class="hljs-literal">null</span> || _ast$name === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _ast$name.value;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected ast node to have a 'name'."</span>, <span class="hljs-literal">null</span>, [ast]);
  }

  <span class="hljs-keyword">return</span> name;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTypeName</span>(<span class="hljs-params">ast</span>) </span>{
  <span class="hljs-keyword">return</span> ast ? print(ast) : <span class="hljs-string">'Undefined Type Name'</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-101" id="section-101"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFragmentType</span>(<span class="hljs-params">ast</span>) </span>{
  <span class="hljs-keyword">if</span> (ast.kind === <span class="hljs-string">'FragmentDefinition'</span>) {
    <span class="hljs-keyword">return</span> ast.typeCondition;
  }

  <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Expected ast node to be a FragmentDefinition node.'</span>, <span class="hljs-literal">null</span>, [ast]);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkFragmentSpreadTypeCompatibility</span>(<span class="hljs-params">schema, fragmentType, parentType, fragmentName, fragmentTypeAST, parentTypeAST</span>) </span>{
  <span class="hljs-keyword">if</span> (!schema.doTypesOverlap(fragmentType, schema.assertCompositeType(parentType))) {
    <span class="hljs-keyword">var</span> nodes = [];

    <span class="hljs-keyword">if</span> (parentTypeAST) {
      nodes.push(parentTypeAST);
    }

    <span class="hljs-keyword">if</span> (fragmentTypeAST) {
      nodes.push(fragmentTypeAST);
    }

    <span class="hljs-keyword">var</span> possibleConcreteTypes = schema.isAbstractType(parentType) ? <span class="hljs-built_in">Array</span>.from(schema.getPossibleTypes(schema.assertAbstractType(parentType))) : [];
    <span class="hljs-keyword">var</span> suggestedTypesMessage = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">if</span> (possibleConcreteTypes.length !== <span class="hljs-number">0</span>) {
      suggestedTypesMessage = <span class="hljs-string">" Possible concrete types include "</span>.concat(possibleConcreteTypes.sort().slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"'"</span>.concat(schema.getTypeString(type), <span class="hljs-string">"'"</span>);
      }).join(<span class="hljs-string">', '</span>), <span class="hljs-string">", etc."</span>);
    }

    <span class="hljs-keyword">throw</span> createUserError((fragmentName != <span class="hljs-literal">null</span> ? <span class="hljs-string">"Fragment '"</span>.concat(fragmentName, <span class="hljs-string">"' cannot be spread here as objects of "</span>) : <span class="hljs-string">'Fragment cannot be spread here as objects of '</span>) + <span class="hljs-string">"type '"</span>.concat(schema.getTypeString(parentType), <span class="hljs-string">"' "</span>) + <span class="hljs-string">"can never be of type '"</span>.concat(schema.getTypeString(fragmentType), <span class="hljs-string">"'."</span>) + suggestedTypesMessage, <span class="hljs-literal">null</span>, nodes);
  }
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">parse</span>: parse,
  <span class="hljs-attr">transform</span>: transform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 29 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-102" id="section-102"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">DEFAULT_HANDLE_KEY</span>: <span class="hljs-string">''</span>
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 30 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-103" id="section-103"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">7</span>),
    SchemaMetaFieldDef = _require2.SchemaMetaFieldDef,
    TypeMetaFieldDef = _require2.TypeMetaFieldDef;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-104" id="section-104"></a>
</div>
<div class="dox">
<div class="summary">
<p>Find the definition of a field of the specified type using strict
resolution rules per the GraphQL spec.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldDefinitionStrict</span>(<span class="hljs-params">schema, parentType, fieldName</span>) </span>{
  <span class="hljs-keyword">var</span> type = schema.getRawType(parentType);
  <span class="hljs-keyword">var</span> queryType = schema.getQueryType();
  <span class="hljs-keyword">var</span> isQueryType = queryType != <span class="hljs-literal">null</span> &amp;&amp; schema.areEqualTypes(type, queryType);
  <span class="hljs-keyword">var</span> hasTypeName = schema.isAbstractType(type) || schema.isObject(type);
  <span class="hljs-keyword">var</span> schemaFieldDef;

  <span class="hljs-keyword">if</span> (isQueryType &amp;&amp; fieldName === SchemaMetaFieldDef.name) {
    schemaFieldDef = queryType != <span class="hljs-literal">null</span> ? schema.getFieldByName(queryType, <span class="hljs-string">'__schema'</span>) : <span class="hljs-literal">null</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isQueryType &amp;&amp; fieldName === TypeMetaFieldDef.name) {
    schemaFieldDef = queryType != <span class="hljs-literal">null</span> ? schema.getFieldByName(queryType, <span class="hljs-string">'__type'</span>) : <span class="hljs-literal">null</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasTypeName &amp;&amp; fieldName === <span class="hljs-string">'__typename'</span>) {
    schemaFieldDef = schema.getFieldByName(schema.assertCompositeType(type), <span class="hljs-string">'__typename'</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasTypeName &amp;&amp; fieldName === <span class="hljs-string">'__id'</span>) {
    schemaFieldDef = schema.getFieldByName(schema.assertCompositeType(type), <span class="hljs-string">'__id'</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isInterface(type) || schema.isObject(type)) {
    <span class="hljs-keyword">var</span> compositeType = schema.assertCompositeType(type);

    <span class="hljs-keyword">if</span> (schema.hasField(compositeType, fieldName)) {
      schemaFieldDef = schema.getFieldByName(compositeType, fieldName);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-keyword">return</span> schemaFieldDef;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-105" id="section-105"></a>
</div>
<div class="dox">
<div class="summary">
<p>Find the definition of a field of the specified type, first trying
the standard spec-compliant resolution process and falling back
to legacy mode that supports fat interfaces.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldDefinitionLegacy</span>(<span class="hljs-params">schema, parentType, fieldName, fieldAST</span>) </span>{
  <span class="hljs-keyword">var</span> _schemaFieldDef;

  <span class="hljs-keyword">var</span> schemaFieldDef = getFieldDefinitionStrict(schema, parentType, fieldName);

  <span class="hljs-keyword">if</span> (!schemaFieldDef) {
    schemaFieldDef = getFieldDefinitionLegacyImpl(schema, parentType, fieldName, fieldAST);
  }

  <span class="hljs-keyword">return</span> (_schemaFieldDef = schemaFieldDef) !== <span class="hljs-literal">null</span> &amp;&amp; _schemaFieldDef !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _schemaFieldDef : <span class="hljs-literal">null</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-106" id="section-106"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldDefinitionLegacyImpl</span>(<span class="hljs-params">schema, type, fieldName, fieldAST</span>) </span>{
  <span class="hljs-keyword">var</span> rawType = schema.getRawType(type);

  <span class="hljs-keyword">if</span> (schema.isAbstractType(rawType) &amp;&amp; fieldAST &amp;&amp; fieldAST.directives &amp;&amp; fieldAST.directives.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> getName(directive) === <span class="hljs-string">'fixme_fat_interface'</span>;
  })) {
    <span class="hljs-keyword">var</span> possibleTypes = schema.getPossibleTypes(schema.assertAbstractType(rawType));
    <span class="hljs-keyword">var</span> schemaFieldDef;

    <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(possibleTypes),
        _step;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">var</span> _loop = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_loop</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> possibleType = _step.value;
        <span class="hljs-keyword">var</span> possibleField = schema.getFieldByName(possibleType, fieldName);

        <span class="hljs-keyword">if</span> (possibleField) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-107" id="section-107"></a>
</div>
<p>Fat interface fields can have differing arguments. Try to return
a field with matching arguments, but still return a field if the
arguments do not match.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          schemaFieldDef = possibleField;

          <span class="hljs-keyword">if</span> (fieldAST &amp;&amp; fieldAST.arguments) {
            <span class="hljs-keyword">var</span> argumentsAllExist = fieldAST.arguments.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argument</span>) </span>{
              <span class="hljs-keyword">return</span> schema.getFieldArgByName(possibleField, getName(argument)) != <span class="hljs-literal">null</span>;
            });

            <span class="hljs-keyword">if</span> (argumentsAllExist) {
              <span class="hljs-keyword">return</span> <span class="hljs-string">"break"</span>;
            }
          }
        }
      };

      <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
        <span class="hljs-keyword">var</span> _ret = _loop();

        <span class="hljs-keyword">if</span> (_ret === <span class="hljs-string">"break"</span>) <span class="hljs-keyword">break</span>;
      }
    } <span class="hljs-keyword">catch</span> (err) {
      _iterator.e(err);
    } <span class="hljs-keyword">finally</span> {
      _iterator.f();
    }

    <span class="hljs-keyword">return</span> schemaFieldDef;
  }
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-108" id="section-108"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params">ast</span>) </span>{
  <span class="hljs-keyword">var</span> name = ast.name ? ast.name.value : <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected ast node to have a 'name'."</span>, <span class="hljs-literal">null</span>, [ast]);
  }

  <span class="hljs-keyword">return</span> name;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">getFieldDefinitionLegacy</span>: getFieldDefinitionLegacy,
  <span class="hljs-attr">getFieldDefinitionStrict</span>: getFieldDefinitionStrict
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 31 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-109" id="section-109"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">29</span>),
    DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;

<span class="hljs-keyword">var</span> INDENT = <span class="hljs-string">'  '</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-110" id="section-110"></a>
</div>
<div class="dox">
<div class="summary">
<p>Converts an IR node into a GraphQL string. Custom Relay
extensions (directives) are not supported; to print fragments with
variables or fragment spreads with arguments, transform the node
prior to printing.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.kind) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Fragment'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">"fragment "</span>.concat(node.name, <span class="hljs-string">" on "</span>).concat(schema.getTypeString(node.type)) + printFragmentArgumentDefinitions(schema, node.argumentDefinitions) + printDirectives(schema, node.directives) + printSelections(schema, node, <span class="hljs-string">''</span>, {}) + <span class="hljs-string">'\n'</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'Root'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.concat(node.operation, <span class="hljs-string">" "</span>).concat(node.name) + printArgumentDefinitions(schema, node.argumentDefinitions) + printDirectives(schema, node.directives) + printSelections(schema, node, <span class="hljs-string">''</span>, {}) + <span class="hljs-string">'\n'</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'SplitOperation'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">"SplitOperation "</span>.concat(node.name, <span class="hljs-string">" on "</span>).concat(schema.getTypeString(node.type)) + printSelections(schema, node, <span class="hljs-string">''</span>, {}) + <span class="hljs-string">'\n'</span>;

    <span class="hljs-keyword">default</span>:
      node;
       <span class="hljs-literal">true</span> ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRPrinter: Unsupported IR node `%s`.'</span>, node.kind) : <span class="hljs-literal">undefined</span> : <span class="hljs-literal">undefined</span>;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printSelections</span>(<span class="hljs-params">schema, node, indent, options</span>) </span>{
  <span class="hljs-keyword">var</span> selections = node.selections;

  <span class="hljs-keyword">if</span> (selections == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
  }

  <span class="hljs-keyword">var</span> printed = selections.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">return</span> printSelection(schema, selection, indent, options);
  });
  <span class="hljs-keyword">return</span> printed.length ? <span class="hljs-string">" {\n"</span>.concat(indent + INDENT).concat(printed.join(<span class="hljs-string">'\n'</span> + indent + INDENT), <span class="hljs-string">"\n"</span>).concat(indent).concat((options === <span class="hljs-literal">null</span> || options === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : options.isClientExtension) === <span class="hljs-literal">true</span> ? <span class="hljs-string">'# '</span> : <span class="hljs-string">''</span>, <span class="hljs-string">"}"</span>) : <span class="hljs-string">''</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-111" id="section-111"></a>
</div>
<div class="dox">
<div class="summary">
<p>Prints a field without subselections.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printField</span>(<span class="hljs-params">schema, field, options</span>) </span>{
  <span class="hljs-keyword">var</span> _options$parentDirect;

  <span class="hljs-keyword">var</span> parentDirectives = (_options$parentDirect = options === <span class="hljs-literal">null</span> || options === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : options.parentDirectives) !== <span class="hljs-literal">null</span> &amp;&amp; _options$parentDirect !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _options$parentDirect : <span class="hljs-string">''</span>;
  <span class="hljs-keyword">var</span> isClientExtension = (options === <span class="hljs-literal">null</span> || options === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : options.isClientExtension) === <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> (isClientExtension ? <span class="hljs-string">'# '</span> : <span class="hljs-string">''</span>) + (field.alias === field.name ? field.name : field.alias + <span class="hljs-string">': '</span> + field.name) + printArguments(schema, field.args) + parentDirectives + printDirectives(schema, field.directives) + printHandles(schema, field);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printSelection</span>(<span class="hljs-params">schema, selection, indent, options</span>) </span>{
  <span class="hljs-keyword">var</span> _options$parentDirect2;

  <span class="hljs-keyword">var</span> str;
  <span class="hljs-keyword">var</span> parentDirectives = (_options$parentDirect2 = options === <span class="hljs-literal">null</span> || options === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : options.parentDirectives) !== <span class="hljs-literal">null</span> &amp;&amp; _options$parentDirect2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _options$parentDirect2 : <span class="hljs-string">''</span>;
  <span class="hljs-keyword">var</span> isClientExtension = (options === <span class="hljs-literal">null</span> || options === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : options.isClientExtension) === <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'LinkedField'</span>) {
    str = printField(schema, selection, {
      <span class="hljs-attr">parentDirectives</span>: parentDirectives,
      <span class="hljs-attr">isClientExtension</span>: isClientExtension
    });
    str += printSelections(schema, selection, indent + INDENT, {
      <span class="hljs-attr">isClientExtension</span>: isClientExtension
    });
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'ModuleImport'</span>) {
    str = selection.selections.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matchSelection</span>) </span>{
      <span class="hljs-keyword">return</span> printSelection(schema, matchSelection, indent, {
        <span class="hljs-attr">parentDirectives</span>: parentDirectives,
        <span class="hljs-attr">isClientExtension</span>: isClientExtension
      });
    }).join(<span class="hljs-string">'\n'</span> + indent + INDENT);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'ScalarField'</span>) {
    str = printField(schema, selection, {
      <span class="hljs-attr">parentDirectives</span>: parentDirectives,
      <span class="hljs-attr">isClientExtension</span>: isClientExtension
    });
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'InlineFragment'</span>) {
    str = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">if</span> (isClientExtension) {
      str += <span class="hljs-string">'# '</span>;
    }

    str += <span class="hljs-string">'... on '</span> + schema.getTypeString(selection.typeCondition);
    str += parentDirectives;
    str += printDirectives(schema, selection.directives);
    str += printSelections(schema, selection, indent + INDENT, {
      <span class="hljs-attr">isClientExtension</span>: isClientExtension
    });
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'FragmentSpread'</span>) {
    str = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">if</span> (isClientExtension) {
      str += <span class="hljs-string">'# '</span>;
    }

    str += <span class="hljs-string">'...'</span> + selection.name;
    str += parentDirectives;
    str += printFragmentArguments(schema, selection.args);
    str += printDirectives(schema, selection.directives);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'InlineDataFragmentSpread'</span>) {
    str = <span class="hljs-string">"# "</span>.concat(selection.name, <span class="hljs-string">" @inline"</span>) + <span class="hljs-string">"\n"</span>.concat(indent).concat(INDENT, <span class="hljs-string">"..."</span>) + parentDirectives + printSelections(schema, selection, indent + INDENT, {});
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'Condition'</span>) {
    <span class="hljs-keyword">var</span> value = printValue(schema, selection.condition, <span class="hljs-literal">null</span>); <span class="hljs-comment">// For Flow</span>

    !(value != <span class="hljs-literal">null</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRPrinter: Expected a variable for condition, got a literal `null`.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> condStr = selection.passingValue ? <span class="hljs-string">' @include'</span> : <span class="hljs-string">' @skip'</span>;
    condStr += <span class="hljs-string">'(if: '</span> + value + <span class="hljs-string">')'</span>;
    condStr += parentDirectives; <span class="hljs-comment">// For multi-selection conditions, pushes the condition down to each</span>

    <span class="hljs-keyword">var</span> subSelections = selection.selections.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sel</span>) </span>{
      <span class="hljs-keyword">return</span> printSelection(schema, sel, indent, {
        <span class="hljs-attr">parentDirectives</span>: condStr,
        <span class="hljs-attr">isClientExtension</span>: isClientExtension
      });
    });
    str = subSelections.join(<span class="hljs-string">'\n'</span> + indent + INDENT);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'Stream'</span>) {
    <span class="hljs-keyword">var</span> streamStr = parentDirectives;
    streamStr += <span class="hljs-string">" @stream(label: \""</span>.concat(selection.label, <span class="hljs-string">"\""</span>);

    <span class="hljs-keyword">if</span> (selection[<span class="hljs-string">"if"</span>] !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> _printValue;

      streamStr += <span class="hljs-string">", if: "</span>.concat((_printValue = printValue(schema, selection[<span class="hljs-string">"if"</span>], <span class="hljs-literal">null</span>)) !== <span class="hljs-literal">null</span> &amp;&amp; _printValue !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _printValue : <span class="hljs-string">''</span>);
    }

    <span class="hljs-keyword">if</span> (selection.initialCount !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> _printValue2;

      streamStr += <span class="hljs-string">", initial_count: "</span>.concat((_printValue2 = printValue(schema, selection.initialCount, <span class="hljs-literal">null</span>)) !== <span class="hljs-literal">null</span> &amp;&amp; _printValue2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _printValue2 : <span class="hljs-string">''</span>);
    }

    <span class="hljs-keyword">if</span> (selection.useCustomizedBatch !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> _printValue3;

      streamStr += <span class="hljs-string">", use_customized_batch: "</span>.concat((_printValue3 = printValue(schema, selection.useCustomizedBatch, <span class="hljs-literal">null</span>)) !== <span class="hljs-literal">null</span> &amp;&amp; _printValue3 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _printValue3 : <span class="hljs-string">'false'</span>);
    }

    streamStr += <span class="hljs-string">')'</span>;

    <span class="hljs-keyword">var</span> _subSelections = selection.selections.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sel</span>) </span>{
      <span class="hljs-keyword">return</span> printSelection(schema, sel, indent, {
        <span class="hljs-attr">parentDirectives</span>: streamStr,
        <span class="hljs-attr">isClientExtension</span>: isClientExtension
      });
    });

    str = _subSelections.join(<span class="hljs-string">'\n'</span> + INDENT);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'Defer'</span>) {
    <span class="hljs-keyword">var</span> deferStr = parentDirectives;
    deferStr += <span class="hljs-string">" @defer(label: \""</span>.concat(selection.label, <span class="hljs-string">"\""</span>);

    <span class="hljs-keyword">if</span> (selection[<span class="hljs-string">"if"</span>] !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> _printValue4;

      deferStr += <span class="hljs-string">", if: "</span>.concat((_printValue4 = printValue(schema, selection[<span class="hljs-string">"if"</span>], <span class="hljs-literal">null</span>)) !== <span class="hljs-literal">null</span> &amp;&amp; _printValue4 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _printValue4 : <span class="hljs-string">''</span>);
    }

    deferStr += <span class="hljs-string">')'</span>;

    <span class="hljs-keyword">if</span> (selection.selections.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">subSelection</span>) </span>{
      <span class="hljs-keyword">return</span> subSelection.kind === <span class="hljs-string">'InlineFragment'</span> || subSelection.kind === <span class="hljs-string">'FragmentSpread'</span>;
    })) {
      <span class="hljs-keyword">var</span> _subSelections2 = selection.selections.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sel</span>) </span>{
        <span class="hljs-keyword">return</span> printSelection(schema, sel, indent, {
          <span class="hljs-attr">parentDirectives</span>: deferStr,
          <span class="hljs-attr">isClientExtension</span>: isClientExtension
        });
      });

      str = _subSelections2.join(<span class="hljs-string">'\n'</span> + INDENT);
    } <span class="hljs-keyword">else</span> {
      str = <span class="hljs-string">'...'</span> + deferStr;
      str += printSelections(schema, selection, indent + INDENT, {
        <span class="hljs-attr">isClientExtension</span>: isClientExtension
      });
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'ClientExtension'</span>) {
    !(isClientExtension === <span class="hljs-literal">false</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRPrinter: Did not expect to encounter a ClientExtension node '</span> + <span class="hljs-string">'as a descendant of another ClientExtension node.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    str = <span class="hljs-string">'# Client-only selections:\n'</span> + indent + INDENT + selection.selections.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sel</span>) </span>{
      <span class="hljs-keyword">return</span> printSelection(schema, sel, indent, {
        <span class="hljs-attr">parentDirectives</span>: parentDirectives,
        <span class="hljs-attr">isClientExtension</span>: <span class="hljs-literal">true</span>
      });
    }).join(<span class="hljs-string">'\n'</span> + indent + INDENT);
  } <span class="hljs-keyword">else</span> {
    selection;
     <span class="hljs-literal">true</span> ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRPrinter: Unknown selection kind `%s`.'</span>, selection.kind) : <span class="hljs-literal">undefined</span> : <span class="hljs-literal">undefined</span>;
  }

  <span class="hljs-keyword">return</span> str;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printArgumentDefinitions</span>(<span class="hljs-params">schema, argumentDefinitions</span>) </span>{
  <span class="hljs-keyword">var</span> printed = argumentDefinitions.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">def</span>) </span>{
    <span class="hljs-keyword">var</span> str = <span class="hljs-string">"$"</span>.concat(def.name, <span class="hljs-string">": "</span>).concat(schema.getTypeString(def.type));

    <span class="hljs-keyword">if</span> (def.defaultValue != <span class="hljs-literal">null</span>) {
      str += <span class="hljs-string">' = '</span> + printLiteral(schema, def.defaultValue, def.type);
    }

    <span class="hljs-keyword">return</span> str;
  });
  <span class="hljs-keyword">return</span> printed.length ? <span class="hljs-string">"(\n"</span>.concat(INDENT).concat(printed.join(<span class="hljs-string">'\n'</span> + INDENT), <span class="hljs-string">"\n)"</span>) : <span class="hljs-string">''</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printFragmentArgumentDefinitions</span>(<span class="hljs-params">schema, argumentDefinitions</span>) </span>{
  <span class="hljs-keyword">var</span> printed;
  argumentDefinitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">def</span>) </span>{
    <span class="hljs-keyword">if</span> (def.kind !== <span class="hljs-string">'LocalArgumentDefinition'</span>) {
      <span class="hljs-keyword">return</span>;
    }

    printed = printed || [];
    <span class="hljs-keyword">var</span> str = <span class="hljs-string">""</span>.concat(def.name, <span class="hljs-string">": {type: \""</span>).concat(schema.getTypeString(def.type), <span class="hljs-string">"\""</span>);

    <span class="hljs-keyword">if</span> (def.defaultValue != <span class="hljs-literal">null</span>) {
      str += <span class="hljs-string">", defaultValue: "</span>.concat(printLiteral(schema, def.defaultValue, def.type));
    }

    str += <span class="hljs-string">'}'</span>;
    printed.push(str);
  });
  <span class="hljs-keyword">return</span> printed &amp;&amp; printed.length ? <span class="hljs-string">" @argumentDefinitions(\n"</span>.concat(INDENT).concat(printed.join(<span class="hljs-string">'\n'</span> + INDENT), <span class="hljs-string">"\n)"</span>) : <span class="hljs-string">''</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printHandles</span>(<span class="hljs-params">schema, field</span>) </span>{
  <span class="hljs-keyword">if</span> (!field.handles) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
  }

  <span class="hljs-keyword">var</span> printed = field.handles.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">handle</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-112" id="section-112"></a>
</div>
<p>For backward compatibility.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> key = handle.key === DEFAULT_HANDLE_KEY ? <span class="hljs-string">''</span> : <span class="hljs-string">", key: \""</span>.concat(handle.key, <span class="hljs-string">"\""</span>);
    <span class="hljs-keyword">var</span> filters = handle.filters == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-string">", filters: "</span>.concat(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">Array</span>.from(handle.filters).sort()));
    <span class="hljs-keyword">var</span> handleArgs = handle.handleArgs == <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : <span class="hljs-string">", handleArgs: "</span>.concat(printArguments(schema, handle.handleArgs));
    <span class="hljs-keyword">return</span> <span class="hljs-string">"@__clientField(handle: \""</span>.concat(handle.name, <span class="hljs-string">"\""</span>).concat(key).concat(filters).concat(handleArgs, <span class="hljs-string">")"</span>);
  });
  <span class="hljs-keyword">return</span> printed.length ? <span class="hljs-string">' '</span> + printed.join(<span class="hljs-string">' '</span>) : <span class="hljs-string">''</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printDirectives</span>(<span class="hljs-params">schema, directives</span>) </span>{
  <span class="hljs-keyword">var</span> printed = directives.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">'@'</span> + directive.name + printArguments(schema, directive.args);
  });
  <span class="hljs-keyword">return</span> printed.length ? <span class="hljs-string">' '</span> + printed.join(<span class="hljs-string">' '</span>) : <span class="hljs-string">''</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printFragmentArguments</span>(<span class="hljs-params">schema, args</span>) </span>{
  <span class="hljs-keyword">var</span> printedArgs = printArguments(schema, args);

  <span class="hljs-keyword">if</span> (!printedArgs.length) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-string">" @arguments"</span>.concat(printedArgs);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printArguments</span>(<span class="hljs-params">schema, args</span>) </span>{
  <span class="hljs-keyword">var</span> printed = [];
  args.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">var</span> printedValue = printValue(schema, arg.value, arg.type);

    <span class="hljs-keyword">if</span> (printedValue != <span class="hljs-literal">null</span>) {
      printed.push(arg.name + <span class="hljs-string">': '</span> + printedValue);
    }
  });
  <span class="hljs-keyword">return</span> printed.length ? <span class="hljs-string">'('</span> + printed.join(<span class="hljs-string">', '</span>) + <span class="hljs-string">')'</span> : <span class="hljs-string">''</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printValue</span>(<span class="hljs-params">schema, value, type</span>) </span>{
  <span class="hljs-keyword">if</span> (type != <span class="hljs-literal">null</span> &amp;&amp; schema.isNonNull(type)) {
    type = schema.getNullableType(type);
  }

  <span class="hljs-keyword">if</span> (value.kind === <span class="hljs-string">'Variable'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'$'</span> + value.variableName;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.kind === <span class="hljs-string">'ObjectValue'</span>) {
    <span class="hljs-keyword">var</span> inputType = type != <span class="hljs-literal">null</span> ? schema.asInputObjectType(type) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> pairs = value.fields.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field</span>) </span>{
      <span class="hljs-keyword">var</span> fieldConfig = inputType != <span class="hljs-literal">null</span> ? schema.hasField(inputType, field.name) ? schema.getFieldConfig(schema.expectField(inputType, field.name)) : <span class="hljs-literal">null</span> : <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> innerValue = printValue(schema, field.value, fieldConfig === <span class="hljs-literal">null</span> || fieldConfig === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : fieldConfig.type);
      <span class="hljs-keyword">return</span> innerValue == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : field.name + <span class="hljs-string">': '</span> + innerValue;
    }).filter(<span class="hljs-built_in">Boolean</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-string">'{'</span> + pairs.join(<span class="hljs-string">', '</span>) + <span class="hljs-string">'}'</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.kind === <span class="hljs-string">'ListValue'</span>) {
    !(type &amp;&amp; schema.isList(type)) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'GraphQLIRPrinter: Need a type in order to print arrays.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> innerType = schema.getListItemType(type);
    <span class="hljs-keyword">return</span> <span class="hljs-string">"["</span>.concat(value.items.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) </span>{
      <span class="hljs-keyword">return</span> printValue(schema, i, innerType);
    }).join(<span class="hljs-string">', '</span>), <span class="hljs-string">"]"</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.value != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> printLiteral(schema, value.value, type);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printLiteral</span>(<span class="hljs-params">schema, value, type</span>) </span>{
  <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> _JSON$stringify;

    <span class="hljs-keyword">return</span> (_JSON$stringify = <span class="hljs-built_in">JSON</span>.stringify(value)) !== <span class="hljs-literal">null</span> &amp;&amp; _JSON$stringify !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _JSON$stringify : <span class="hljs-string">'null'</span>;
  }

  <span class="hljs-keyword">if</span> (type != <span class="hljs-literal">null</span> &amp;&amp; schema.isNonNull(type)) {
    type = schema.getNullableType(type);
  }

  <span class="hljs-keyword">if</span> (type &amp;&amp; schema.isEnum(type)) {
    <span class="hljs-keyword">var</span> _JSON$stringify2;

    <span class="hljs-keyword">var</span> result = schema.serialize(schema.assertEnumType(type), value);

    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-113" id="section-113"></a>
</div>
<p>For backwards compatibility, print invalid input values as-is. This
can occur with literals defined as an @argumentDefinitions
defaultValue.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      result = value;
    }

    !(<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'string'</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRPrinter: Expected value of type %s to be a valid enum value, got `%s`.'</span>, schema.getTypeString(type), (_JSON$stringify2 = <span class="hljs-built_in">JSON</span>.stringify(value)) !== <span class="hljs-literal">null</span> &amp;&amp; _JSON$stringify2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _JSON$stringify2 : <span class="hljs-string">'null'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type &amp;&amp; (schema.isId(type) || schema.isInt(type))) {
    <span class="hljs-keyword">var</span> _JSON$stringify3;

    <span class="hljs-keyword">return</span> (_JSON$stringify3 = <span class="hljs-built_in">JSON</span>.stringify(value)) !== <span class="hljs-literal">null</span> &amp;&amp; _JSON$stringify3 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _JSON$stringify3 : <span class="hljs-string">''</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type &amp;&amp; schema.isScalar(type)) {
    <span class="hljs-keyword">var</span> _JSON$stringify4;

    <span class="hljs-keyword">var</span> _result = schema.serialize(schema.assertScalarType(type), value);

    <span class="hljs-keyword">return</span> (_JSON$stringify4 = <span class="hljs-built_in">JSON</span>.stringify(_result)) !== <span class="hljs-literal">null</span> &amp;&amp; _JSON$stringify4 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _JSON$stringify4 : <span class="hljs-string">''</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) {
    !(type &amp;&amp; schema.isList(type)) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRPrinter: Need a type in order to print arrays.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> itemType = schema.getListItemType(type);
    <span class="hljs-keyword">return</span> <span class="hljs-string">'['</span> + value.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
      <span class="hljs-keyword">return</span> printLiteral(schema, item, itemType);
    }).join(<span class="hljs-string">', '</span>) + <span class="hljs-string">']'</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type &amp;&amp; schema.isList(type) &amp;&amp; value != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-114" id="section-114"></a>
</div>
<p>Not an array, but still a list. Treat as list-of-one as per spec 3.1.7:
http://facebook.github.io/graphql/October2016/#sec-Lists</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> printLiteral(schema, value, schema.getListItemType(type));
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span> &amp;&amp; value != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> fields = [];
    !(type &amp;&amp; schema.isInputObject(type)) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRPrinter: Need an InputObject type to print objects.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> inputType = schema.assertInputObjectType(type);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> value) {
      <span class="hljs-keyword">if</span> (value.hasOwnProperty(key)) {
        <span class="hljs-keyword">var</span> fieldConfig = schema.getFieldConfig(schema.expectField(inputType, key));
        fields.push(key + <span class="hljs-string">': '</span> + printLiteral(schema, value[key], fieldConfig.type));
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-string">'{'</span> + fields.join(<span class="hljs-string">', '</span>) + <span class="hljs-string">'}'</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> _JSON$stringify5;

    <span class="hljs-keyword">return</span> (_JSON$stringify5 = <span class="hljs-built_in">JSON</span>.stringify(value)) !== <span class="hljs-literal">null</span> &amp;&amp; _JSON$stringify5 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _JSON$stringify5 : <span class="hljs-string">'null'</span>;
  }
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">print</span>: print,
  <span class="hljs-attr">printField</span>: printField,
  <span class="hljs-attr">printArguments</span>: printArguments,
  <span class="hljs-attr">printDirectives</span>: printDirectives
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 32 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-115" id="section-115"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">argumentContainsVariables</span>(<span class="hljs-params">arg</span>) </span>{
  <span class="hljs-keyword">if</span> (arg == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">switch</span> (arg.kind) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Variable'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'Literal'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'ListValue'</span>:
      <span class="hljs-keyword">return</span> arg.items.some(argumentContainsVariables);

    <span class="hljs-keyword">case</span> <span class="hljs-string">'ObjectValue'</span>:
      <span class="hljs-keyword">return</span> arg.fields.some(argumentContainsVariables);

    <span class="hljs-keyword">default</span>:
      arg.kind;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
}

<span class="hljs-built_in">module</span>.exports = argumentContainsVariables;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 33 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-116" id="section-116"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortObjectByKey</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> obj;
  }

  <span class="hljs-keyword">var</span> result = {};

  <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(<span class="hljs-built_in">Object</span>.keys(obj).sort()),
      _step;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
      <span class="hljs-keyword">var</span> _key = _step.value;
      result[_key] = obj[_key];
    } <span class="hljs-comment">// $FlowFixMe[incompatible-return]</span>

  } <span class="hljs-keyword">catch</span> (err) {
    _iterator.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator.f();
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-built_in">module</span>.exports = sortObjectByKey;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 34 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-117" id="section-117"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-118" id="section-118"></a>
</div>
<div class="dox">
<div class="summary">
<p>Marks a string of code as code to be replaced later.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moduleDependency</span>(<span class="hljs-params">code</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">"@@MODULE_START@@"</span>.concat(code, <span class="hljs-string">"@@MODULE_END@@"</span>);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-119" id="section-119"></a>
</div>
<div class="dox">
<div class="summary">
<p>After JSON.stringify'ing some code that contained parts marked with <code>mark()</code>,
this post-processes the JSON to convert the marked code strings to raw code.</p>
</div>
<div class="body">
<p>Example:
CodeMarker.postProcess(
JSON.stringify({code: CodeMarker.mark('alert(1)')})
)</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postProcess</span>(<span class="hljs-params">json, printModule</span>) </span>{
  <span class="hljs-keyword">return</span> json.replace(<span class="hljs-regexp">/"@@MODULE_START@@(.*?)@@MODULE_END@@"/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_, moduleName</span>) </span>{
    <span class="hljs-keyword">return</span> printModule(moduleName);
  });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-120" id="section-120"></a>
</div>
<div class="dox">
<div class="summary">
<p>Transforms a value such that any transitive CodeMarker strings are replaced
with the value of the named module in the given module map.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transform</span>(<span class="hljs-params">node, moduleMap</span>) </span>{
  <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> node;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(node)) {
    <span class="hljs-keyword">return</span> node.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
      <span class="hljs-keyword">return</span> transform(item, moduleMap);
    });
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node === <span class="hljs-string">'object'</span>) {
    <span class="hljs-keyword">var</span> next = {};
    <span class="hljs-built_in">Object</span>.keys(node).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
      next[key] = transform(node[key], moduleMap);
    });
    <span class="hljs-keyword">return</span> next;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">var</span> match = <span class="hljs-regexp">/^@@MODULE_START@@(.*?)@@MODULE_END@@$/</span>.exec(node);

    <span class="hljs-keyword">if</span> (match != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> moduleName = match[<span class="hljs-number">1</span>];

      <span class="hljs-keyword">if</span> (moduleMap.hasOwnProperty(moduleName)) {
        <span class="hljs-keyword">return</span> moduleMap[moduleName];
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Could not find a value for CodeMarker value '"</span>.concat(moduleName, <span class="hljs-string">"', "</span>) + <span class="hljs-string">'make sure to supply one in the module mapping.'</span>);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.indexOf(<span class="hljs-string">'@@MODULE_START'</span>) &gt;= <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Found unprocessed CodeMarker value '"</span>.concat(node, <span class="hljs-string">"'."</span>));
    }

    <span class="hljs-keyword">return</span> node;
  } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-121" id="section-121"></a>
</div>
<p>mixed</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> node;
  }
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">moduleDependency</span>: moduleDependency,
  <span class="hljs-attr">postProcess</span>: postProcess,
  <span class="hljs-attr">transform</span>: transform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 35 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-122" id="section-122"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-123" id="section-123"></a>
</div>
<div class="dox">
<div class="summary">
<p>Generates an identifier for an argument value. The identifier is based on the
structure/order of items and keys in the value.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIdentifierForArgumentValue</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-keyword">switch</span> (value.kind) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Variable'</span>:
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">variable</span>: value.variableName
      };

    <span class="hljs-keyword">case</span> <span class="hljs-string">'Literal'</span>:
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">value</span>: value.value
      };

    <span class="hljs-keyword">case</span> <span class="hljs-string">'ListValue'</span>:
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">list</span>: value.items.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
          <span class="hljs-keyword">return</span> getIdentifierForArgumentValue(item);
        })
      };

    <span class="hljs-keyword">case</span> <span class="hljs-string">'ObjectValue'</span>:
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">object</span>: value.fields.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field</span>) </span>{
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">name</span>: field.name,
            <span class="hljs-attr">value</span>: getIdentifierForArgumentValue(field.value)
          };
        })
      };

    <span class="hljs-keyword">default</span>:
       <span class="hljs-literal">true</span> ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'getIdentifierForArgumentValue(): Unsupported AST kind `%s`.'</span>, value.kind) : <span class="hljs-literal">undefined</span> : <span class="hljs-literal">undefined</span>;
  }
}

<span class="hljs-built_in">module</span>.exports = getIdentifierForArgumentValue;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 36 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-124" id="section-124"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-125" id="section-125"></a>
</div>
<div class="dox">
<div class="summary">
<p>Based on implementations by Gary Court and Austin Appleby, 2011, MIT.</p>
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> BASE62 = <span class="hljs-string">'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-126" id="section-126"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">key</span>
<span class="dox_type">string</span>
<span>A UTF-16 or ASCII string
</span>
</div>
<div class="dox_tag_title">Returns</div>
<div class="dox_tag_detail">
<span class="dox_tag_name"></span>
<span class="dox_type">string</span>
<span>a base62 murmur hash
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">murmurHash</span>(<span class="hljs-params">str</span>) </span>{
  <span class="hljs-comment">/* eslint-disable no-bitwise */</span>
  <span class="hljs-keyword">var</span> length = str.length;
  <span class="hljs-keyword">var</span> rem = length &amp; <span class="hljs-number">3</span>;
  <span class="hljs-keyword">var</span> len = length ^ rem;
  <span class="hljs-keyword">var</span> h = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> k;

  <span class="hljs-keyword">while</span> (i !== len) {
    <span class="hljs-keyword">var</span> ch4 = str.charCodeAt(i + <span class="hljs-number">3</span>);
    k = str.charCodeAt(i) ^ str.charCodeAt(i + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">8</span> ^ str.charCodeAt(i + <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">16</span> ^ (ch4 &amp; <span class="hljs-number">0xff</span>) &lt;&lt; <span class="hljs-number">24</span> ^ (ch4 &amp; <span class="hljs-number">0xff00</span>) &gt;&gt; <span class="hljs-number">8</span>;
    i += <span class="hljs-number">4</span>;
    k = k * <span class="hljs-number">0x2d51</span> + (k &amp; <span class="hljs-number">0xffff</span>) * <span class="hljs-number">0xcc9e0000</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;
    k = k &lt;&lt; <span class="hljs-number">15</span> | k &gt;&gt;&gt; <span class="hljs-number">17</span>;
    k = k * <span class="hljs-number">0x3593</span> + (k &amp; <span class="hljs-number">0xffff</span>) * <span class="hljs-number">0x1b870000</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;
    h ^= k;
    h = h &lt;&lt; <span class="hljs-number">13</span> | h &gt;&gt;&gt; <span class="hljs-number">19</span>;
    h = h * <span class="hljs-number">5</span> + <span class="hljs-number">0xe6546b64</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;
  }

  k = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">switch</span> (rem) {
    <span class="hljs-comment">/* eslint-disable no-fallthrough */</span>
    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
      k ^= str.charCodeAt(len + <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">16</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
      k ^= str.charCodeAt(len + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">8</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
      k ^= str.charCodeAt(len);
      k = k * <span class="hljs-number">0x2d51</span> + (k &amp; <span class="hljs-number">0xffff</span>) * <span class="hljs-number">0xcc9e0000</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;
      k = k &lt;&lt; <span class="hljs-number">15</span> | k &gt;&gt;&gt; <span class="hljs-number">17</span>;
      k = k * <span class="hljs-number">0x3593</span> + (k &amp; <span class="hljs-number">0xffff</span>) * <span class="hljs-number">0x1b870000</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;
      h ^= k;
  }

  h ^= length;
  h ^= h &gt;&gt;&gt; <span class="hljs-number">16</span>;
  h = h * <span class="hljs-number">0xca6b</span> + (h &amp; <span class="hljs-number">0xffff</span>) * <span class="hljs-number">0x85eb0000</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;
  h ^= h &gt;&gt;&gt; <span class="hljs-number">13</span>;
  h = h * <span class="hljs-number">0xae35</span> + (h &amp; <span class="hljs-number">0xffff</span>) * <span class="hljs-number">0xc2b20000</span> &gt;&gt;&gt; <span class="hljs-number">0</span>;
  h ^= h &gt;&gt;&gt; <span class="hljs-number">16</span>;
  h &gt;&gt;&gt;= <span class="hljs-number">0</span>;

  <span class="hljs-keyword">if</span> (!h) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'0'</span>;
  }

  <span class="hljs-keyword">var</span> s = <span class="hljs-string">''</span>;

  <span class="hljs-keyword">while</span> (h) {
    <span class="hljs-keyword">var</span> d = h % <span class="hljs-number">62</span>;
    s = BASE62[d] + s;
    h = (h - d) / <span class="hljs-number">62</span>;
  }

  <span class="hljs-keyword">return</span> s;
}

<span class="hljs-built_in">module</span>.exports = murmurHash;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 37 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-127" id="section-127"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    eachWithCombinedError = _require.eachWithCombinedError;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-128" id="section-128"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validate</span>(<span class="hljs-params">context, visitor, stateInitializer</span>) </span>{
  <span class="hljs-keyword">var</span> validator = <span class="hljs-keyword">new</span> Validator(context, visitor);
  eachWithCombinedError(context.documents(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prevNode</span>) </span>{
    <span class="hljs-keyword">if</span> (stateInitializer === <span class="hljs-literal">undefined</span>) {
      validator.visit(prevNode, <span class="hljs-literal">undefined</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> _state = stateInitializer(prevNode);

      <span class="hljs-keyword">if</span> (_state != <span class="hljs-literal">null</span>) {
        validator.visit(prevNode, _state);
      }
    }
  });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-129" id="section-129"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> Validator = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Validator</span>(<span class="hljs-params">context, visitor</span>) </span>{
    <span class="hljs-keyword">this</span>._context = context;
    <span class="hljs-keyword">this</span>._states = [];
    <span class="hljs-keyword">this</span>._visitor = visitor;
  }

  <span class="hljs-keyword">var</span> _proto = Validator.prototype;

  _proto.getContext = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getContext</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._context;
  };

  _proto.visit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span>(<span class="hljs-params">node, state</span>) </span>{
    <span class="hljs-keyword">this</span>._states.push(state);

    <span class="hljs-keyword">this</span>._visit(node);

    <span class="hljs-keyword">this</span>._states.pop();
  };

  _proto.traverse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">node, state</span>) </span>{
    <span class="hljs-keyword">this</span>._states.push(state);

    <span class="hljs-keyword">this</span>._traverse(node);

    <span class="hljs-keyword">this</span>._states.pop();
  };

  _proto._visit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_visit</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">var</span> nodeVisitor = <span class="hljs-keyword">this</span>._visitor[node.kind];

    <span class="hljs-keyword">if</span> (nodeVisitor) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-130" id="section-130"></a>
</div>
<p>If a handler for the kind is defined, it is responsible for calling
<code>traverse</code> to transform children as necessary.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> _state2 = <span class="hljs-keyword">this</span>._getState();

      nodeVisitor.call(<span class="hljs-keyword">this</span>, node, _state2);
      <span class="hljs-keyword">return</span>;
    } <span class="hljs-comment">// Otherwise traverse is called automatically.</span>


    <span class="hljs-keyword">this</span>._traverse(node);
  };

  _proto._traverse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverse</span>(<span class="hljs-params">prevNode</span>) </span>{
    <span class="hljs-keyword">switch</span> (prevNode.kind) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Argument'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, <span class="hljs-literal">null</span>, [<span class="hljs-string">'value'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Literal'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'LocalArgumentDefinition'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'RootArgumentDefinition'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Variable'</span>:
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Defer'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'selections'</span>], [<span class="hljs-string">'if'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Stream'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'selections'</span>], [<span class="hljs-string">'if'</span>, <span class="hljs-string">'initialCount'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ClientExtension'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'selections'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Directive'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'args'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ModuleImport'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'selections'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'FragmentSpread'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'ScalarField'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'args'</span>, <span class="hljs-string">'directives'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineDataFragmentSpread'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'selections'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'LinkedField'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'args'</span>, <span class="hljs-string">'directives'</span>, <span class="hljs-string">'selections'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ListValue'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'items'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ObjectFieldValue'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, <span class="hljs-literal">null</span>, [<span class="hljs-string">'value'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ObjectValue'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'fields'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Condition'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'directives'</span>, <span class="hljs-string">'selections'</span>], [<span class="hljs-string">'condition'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineFragment'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'directives'</span>, <span class="hljs-string">'selections'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Fragment'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Root'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'argumentDefinitions'</span>, <span class="hljs-string">'directives'</span>, <span class="hljs-string">'selections'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Request'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, <span class="hljs-literal">null</span>, [<span class="hljs-string">'fragment'</span>, <span class="hljs-string">'root'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'SplitOperation'</span>:
        <span class="hljs-keyword">this</span>._traverseChildren(prevNode, [<span class="hljs-string">'selections'</span>]);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">default</span>:
        prevNode;
         <span class="hljs-literal">true</span> ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRValidator: Unknown kind `%s`.'</span>, prevNode.kind) : <span class="hljs-literal">undefined</span> : <span class="hljs-literal">undefined</span>;
    }
  };

  _proto._traverseChildren = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_traverseChildren</span>(<span class="hljs-params">prevNode, pluralKeys, singularKeys</span>) </span>{
    <span class="hljs-keyword">var</span> _this = <span class="hljs-keyword">this</span>;

    pluralKeys &amp;&amp; pluralKeys.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
      <span class="hljs-keyword">var</span> prevItems = prevNode[key];

      <span class="hljs-keyword">if</span> (!prevItems) {
        <span class="hljs-keyword">return</span>;
      }

      !<span class="hljs-built_in">Array</span>.isArray(prevItems) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRValidator: Expected data for `%s` to be an array, got `%s`.'</span>, key, prevItems) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
      prevItems.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prevItem</span>) </span>{
        <span class="hljs-keyword">return</span> _this._visit(prevItem);
      });
    });
    singularKeys &amp;&amp; singularKeys.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
      <span class="hljs-keyword">var</span> prevItem = prevNode[key];

      <span class="hljs-keyword">if</span> (!prevItem) {
        <span class="hljs-keyword">return</span>;
      }

      _this._visit(prevItem);
    });
  };

  _proto._getState = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_getState</span>(<span class="hljs-params"></span>) </span>{
    !<span class="hljs-keyword">this</span>._states.length ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'IRValidator: Expected a current state to be set but found none. '</span> + <span class="hljs-string">'This is usually the result of mismatched number of pushState()/popState() '</span> + <span class="hljs-string">'calls.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._states[<span class="hljs-keyword">this</span>._states.length - <span class="hljs-number">1</span>];
  };

  <span class="hljs-keyword">return</span> Validator;
}();

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">validate</span>: validate
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 38 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-131" id="section-131"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> areEqual = __webpack_require__(<span class="hljs-number">87</span>);

<span class="hljs-keyword">var</span> getIdentifierForSelection = __webpack_require__(<span class="hljs-number">39</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError,
    createUserError = _require.createUserError;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-132" id="section-132"></a>
</div>
<div class="dox">
<div class="summary">
<p>Transform that flattens inline fragments, fragment spreads, and conditionals.</p>
</div>
<div class="body">
<p>Inline fragments are inlined (replaced with their selections) when:</p>
<ul>
<li>The fragment type matches the type of its parent, and its <code>isForCodegen</code>,
or if it's for printing, there is no directive on the inline fragment.</li>
</ul>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flattenTransformImpl</span>(<span class="hljs-params">context, options</span>) </span>{
  <span class="hljs-keyword">var</span> state = {
    <span class="hljs-attr">isForCodegen</span>: !!(options &amp;&amp; options.isForCodegen),
    <span class="hljs-attr">parentType</span>: <span class="hljs-literal">null</span>
  };
  <span class="hljs-keyword">var</span> visitorFn = memoizedFlattenSelection(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>());
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">Condition</span>: visitorFn,
    <span class="hljs-attr">Defer</span>: visitorFn,
    <span class="hljs-attr">Fragment</span>: visitorFn,
    <span class="hljs-attr">InlineDataFragmentSpread</span>: visitorFn,
    <span class="hljs-attr">InlineFragment</span>: visitorFn,
    <span class="hljs-attr">LinkedField</span>: visitorFn,
    <span class="hljs-attr">ModuleImport</span>: visitorFn,
    <span class="hljs-attr">Root</span>: visitorFn,
    <span class="hljs-attr">SplitOperation</span>: visitorFn
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> state;
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoizedFlattenSelection</span>(<span class="hljs-params">cache</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flattenSelectionsFn</span>(<span class="hljs-params">node, state</span>) </span>{
    <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
    <span class="hljs-keyword">var</span> nodeCache = cache.get(node);

    <span class="hljs-keyword">if</span> (nodeCache == <span class="hljs-literal">null</span>) {
      nodeCache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
      cache.set(node, nodeCache);
    } <span class="hljs-comment">// Determine the current type.</span>


    <span class="hljs-keyword">var</span> parentType = state.parentType;
    <span class="hljs-keyword">var</span> result = nodeCache.get(parentType);

    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">var</span> type = node.kind === <span class="hljs-string">'LinkedField'</span> || node.kind === <span class="hljs-string">'Fragment'</span> || node.kind === <span class="hljs-string">'Root'</span> || node.kind === <span class="hljs-string">'SplitOperation'</span> ? node.type : node.kind === <span class="hljs-string">'InlineFragment'</span> ? node.typeCondition : parentType;

    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'FlattenTransform: Expected a parent type.'</span>, [node.loc]);
    } <span class="hljs-comment">// Flatten the selections in this node, creating a new node with flattened</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-133" id="section-133"></a>
</div>
<p>selections if possible, then deeply traverse the flattened node, while
keeping track of the parent type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">var</span> nextSelections = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">var</span> hasFlattened = flattenSelectionsInto(context.getSchema(), nextSelections, node, state, type);
    <span class="hljs-keyword">var</span> flattenedNode = hasFlattened ? _objectSpread(_objectSpread({}, node), {}, {
      <span class="hljs-attr">selections</span>: <span class="hljs-built_in">Array</span>.from(nextSelections.values())
    }) : node;
    state.parentType = type;
    <span class="hljs-keyword">var</span> deeplyFlattenedNode = <span class="hljs-keyword">this</span>.traverse(flattenedNode, state);
    state.parentType = parentType;
    nodeCache.set(parentType, deeplyFlattenedNode);
    <span class="hljs-keyword">return</span> deeplyFlattenedNode;
  };
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-134" id="section-134"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flattenSelectionsInto</span>(<span class="hljs-params">schema, flattenedSelections, node, state, type</span>) </span>{
  <span class="hljs-keyword">var</span> hasFlattened = <span class="hljs-literal">false</span>;
  node.selections.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'InlineFragment'</span> &amp;&amp; shouldFlattenInlineFragment(schema, selection, state, type)) {
      hasFlattened = <span class="hljs-literal">true</span>;
      flattenSelectionsInto(schema, flattenedSelections, selection, state, type);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> nodeIdentifier = getIdentifierForSelection(schema, selection);
    <span class="hljs-keyword">var</span> flattenedSelection = flattenedSelections.get(nodeIdentifier); <span class="hljs-comment">// If this selection hasn't been seen before, keep track of it.</span>

    <span class="hljs-keyword">if</span> (!flattenedSelection) {
      flattenedSelections.set(nodeIdentifier, selection);
      <span class="hljs-keyword">return</span>;
    } <span class="hljs-comment">// Otherwise a similar selection exists which should be merged.</span>


    hasFlattened = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">if</span> (flattenedSelection.kind === <span class="hljs-string">'InlineFragment'</span>) {
      <span class="hljs-keyword">if</span> (selection.kind !== <span class="hljs-string">'InlineFragment'</span>) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"FlattenTransform: Expected an InlineFragment, got a '"</span>.concat(selection.kind, <span class="hljs-string">"'"</span>), [selection.loc]);
      }

      flattenedSelections.set(nodeIdentifier, _objectSpread(_objectSpread({}, flattenedSelection), {}, {
        <span class="hljs-attr">selections</span>: mergeSelections(schema, flattenedSelection, selection, state, selection.typeCondition)
      }));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flattenedSelection.kind === <span class="hljs-string">'Condition'</span>) {
      <span class="hljs-keyword">if</span> (selection.kind !== <span class="hljs-string">'Condition'</span>) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"FlattenTransform: Expected a Condition, got a '"</span>.concat(selection.kind, <span class="hljs-string">"'"</span>), [selection.loc]);
      }

      flattenedSelections.set(nodeIdentifier, _objectSpread(_objectSpread({}, flattenedSelection), {}, {
        <span class="hljs-attr">selections</span>: mergeSelections(schema, flattenedSelection, selection, state, type)
      }));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flattenedSelection.kind === <span class="hljs-string">'ClientExtension'</span>) {
      <span class="hljs-keyword">if</span> (selection.kind !== <span class="hljs-string">'ClientExtension'</span>) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"FlattenTransform: Expected a ClientExtension, got a '"</span>.concat(selection.kind, <span class="hljs-string">"'"</span>), [selection.loc]);
      }

      flattenedSelections.set(nodeIdentifier, _objectSpread(_objectSpread({}, flattenedSelection), {}, {
        <span class="hljs-attr">selections</span>: mergeSelections(schema, flattenedSelection, selection, state, type)
      }));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flattenedSelection.kind === <span class="hljs-string">'FragmentSpread'</span>) {<span class="hljs-comment">// Ignore duplicate fragment spreads.</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flattenedSelection.kind === <span class="hljs-string">'ModuleImport'</span>) {
      <span class="hljs-keyword">if</span> (selection.kind !== <span class="hljs-string">'ModuleImport'</span>) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"FlattenTransform: Expected a ModuleImport, got a '"</span>.concat(selection.kind, <span class="hljs-string">"'"</span>), [selection.loc]);
      }

      <span class="hljs-keyword">if</span> (selection.name !== flattenedSelection.name || selection.module !== flattenedSelection.module || selection.key !== flattenedSelection.key) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Found conflicting @module selections: use a unique alias on the '</span> + <span class="hljs-string">'parent fields.'</span>, [selection.loc, flattenedSelection.loc]);
      }

      flattenedSelections.set(nodeIdentifier, _objectSpread(_objectSpread({}, flattenedSelection), {}, {
        <span class="hljs-attr">selections</span>: mergeSelections(schema, flattenedSelection, selection, state, type)
      }));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flattenedSelection.kind === <span class="hljs-string">'Defer'</span>) {
      <span class="hljs-keyword">if</span> (selection.kind !== <span class="hljs-string">'Defer'</span>) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"FlattenTransform: Expected a Defer, got a '"</span>.concat(selection.kind, <span class="hljs-string">"'"</span>), [selection.loc]);
      }

      flattenedSelections.set(nodeIdentifier, _objectSpread(_objectSpread({
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Defer'</span>
      }, flattenedSelection), {}, {
        <span class="hljs-attr">selections</span>: mergeSelections(schema, flattenedSelection, selection, state, type)
      }));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flattenedSelection.kind === <span class="hljs-string">'Stream'</span>) {
      <span class="hljs-keyword">if</span> (selection.kind !== <span class="hljs-string">'Stream'</span>) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"FlattenTransform: Expected a Stream, got a '"</span>.concat(selection.kind, <span class="hljs-string">"'"</span>), [selection.loc]);
      }

      flattenedSelections.set(nodeIdentifier, _objectSpread(_objectSpread({
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Stream'</span>
      }, flattenedSelection), {}, {
        <span class="hljs-attr">selections</span>: mergeSelections(schema, flattenedSelection, selection, state, type)
      }));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flattenedSelection.kind === <span class="hljs-string">'LinkedField'</span>) {
      <span class="hljs-keyword">if</span> (selection.kind !== <span class="hljs-string">'LinkedField'</span>) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"FlattenTransform: Expected a LinkedField, got a '"</span>.concat(selection.kind, <span class="hljs-string">"'"</span>), [selection.loc]);
      }

      assertUniqueArgsForAlias(selection, flattenedSelection); <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> not using object spread here as this code is pretty hot</span>

      flattenedSelections.set(nodeIdentifier, {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkedField'</span>,
        <span class="hljs-attr">alias</span>: flattenedSelection.alias,
        <span class="hljs-attr">args</span>: flattenedSelection.args,
        <span class="hljs-attr">connection</span>: flattenedSelection.connection || selection.connection,
        <span class="hljs-attr">directives</span>: flattenedSelection.directives,
        <span class="hljs-attr">handles</span>: mergeHandles(flattenedSelection, selection),
        <span class="hljs-attr">loc</span>: flattenedSelection.loc,
        <span class="hljs-attr">metadata</span>: flattenedSelection.metadata,
        <span class="hljs-attr">name</span>: flattenedSelection.name,
        <span class="hljs-attr">selections</span>: mergeSelections(schema, flattenedSelection, selection, state, selection.type),
        <span class="hljs-attr">type</span>: flattenedSelection.type
      });
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flattenedSelection.kind === <span class="hljs-string">'ScalarField'</span>) {
      <span class="hljs-keyword">if</span> (selection.kind !== <span class="hljs-string">'ScalarField'</span>) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"FlattenTransform: Expected a ScalarField, got a '"</span>.concat(selection.kind, <span class="hljs-string">"'"</span>), [selection.loc]);
      }

      assertUniqueArgsForAlias(selection, flattenedSelection);

      <span class="hljs-keyword">if</span> (selection.handles &amp;&amp; selection.handles.length &gt; <span class="hljs-number">0</span>) {
        flattenedSelections.set(nodeIdentifier, _objectSpread(_objectSpread({
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'ScalarField'</span>
        }, flattenedSelection), {}, {
          <span class="hljs-attr">handles</span>: mergeHandles(selection, flattenedSelection)
        }));
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flattenedSelection.kind === <span class="hljs-string">'InlineDataFragmentSpread'</span>) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'FlattenTransform: did not expect an InlineDataFragmentSpread node. '</span> + <span class="hljs-string">'Only expecting InlineDataFragmentSpread in reader ASTs and this '</span> + <span class="hljs-string">'transform to run only on normalization ASTs.'</span>, [selection.loc]);
    } <span class="hljs-keyword">else</span> {
      flattenedSelection.kind;
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"FlattenTransform: Unknown kind '"</span>.concat(flattenedSelection.kind, <span class="hljs-string">"'"</span>));
    }
  });
  <span class="hljs-keyword">return</span> hasFlattened;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-135" id="section-135"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSelections</span>(<span class="hljs-params">schema, nodeA, nodeB, state, type</span>) </span>{
  <span class="hljs-keyword">var</span> flattenedSelections = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  flattenSelectionsInto(schema, flattenedSelections, nodeA, state, type);
  flattenSelectionsInto(schema, flattenedSelections, nodeB, state, type);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(flattenedSelections.values());
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-136" id="section-136"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertUniqueArgsForAlias</span>(<span class="hljs-params">field, otherField</span>) </span>{
  <span class="hljs-keyword">if</span> (!areEqualFields(field, otherField)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Expected all fields on the same parent with the name or alias '</span> + <span class="hljs-string">"'"</span>.concat(field.alias, <span class="hljs-string">"' to have the same name and arguments."</span>), [field.loc, otherField.loc]);
  }
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-137" id="section-137"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shouldFlattenInlineFragment</span>(<span class="hljs-params">schema, fragment, state, type</span>) </span>{
  <span class="hljs-keyword">return</span> schema.areEqualTypes(fragment.typeCondition, schema.getRawType(type)) &amp;&amp; (state.isForCodegen || fragment.directives.length === <span class="hljs-number">0</span>);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-138" id="section-138"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">areEqualFields</span>(<span class="hljs-params">thisField, thatField</span>) </span>{
  <span class="hljs-keyword">return</span> thisField.kind === thatField.kind &amp;&amp; thisField.name === thatField.name &amp;&amp; thisField.alias === thatField.alias &amp;&amp; areEqualArgs(thisField.args, thatField.args);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-139" id="section-139"></a>
</div>
<div class="dox">
<div class="summary">
<p>Verify that two sets of arguments are equivalent - same argument names
and values. Notably this ignores the types of arguments and values, which
may not always be inferred identically.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">areEqualArgs</span>(<span class="hljs-params">thisArgs, thatArgs</span>) </span>{
  <span class="hljs-keyword">return</span> thisArgs.length === thatArgs.length &amp;&amp; thisArgs.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">thisArg, index</span>) </span>{
    <span class="hljs-keyword">var</span> thatArg = thatArgs[index];
    <span class="hljs-keyword">return</span> thisArg.name === thatArg.name &amp;&amp; thisArg.value.kind === thatArg.value.kind &amp;&amp; thisArg.value.variableName === thatArg.value.variableName &amp;&amp; areEqual(thisArg.value.value, thatArg.value.value);
  });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-140" id="section-140"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeHandles</span>(<span class="hljs-params">nodeA, nodeB</span>) </span>{
  <span class="hljs-keyword">if</span> (!nodeA.handles) {
    <span class="hljs-keyword">return</span> nodeB.handles;
  }

  <span class="hljs-keyword">if</span> (!nodeB.handles) {
    <span class="hljs-keyword">return</span> nodeA.handles;
  }

  <span class="hljs-keyword">var</span> uniqueItems = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  nodeA.handles.concat(nodeB.handles).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
    <span class="hljs-keyword">return</span> uniqueItems.set(item.name + item.key, item);
  });
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(uniqueItems.values());
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformWithOptions</span>(<span class="hljs-params">options</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flattenTransform</span>(<span class="hljs-params">context</span>) </span>{
    <span class="hljs-keyword">return</span> flattenTransformImpl(context, options);
  };
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transformWithOptions</span>: transformWithOptions
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 39 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-141" id="section-141"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">31</span>),
    printArguments = _require.printArguments,
    printDirectives = _require.printDirectives;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-142" id="section-142"></a>
</div>
<div class="dox">
<div class="summary">
<p>Generates an identifier that is unique to a given selection: the alias for
fields, the type for inline fragments, and a summary of the condition
variable and passing value for conditions.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIdentifierForSelection</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">if</span> (node.kind === <span class="hljs-string">'LinkedField'</span> || node.kind === <span class="hljs-string">'ScalarField'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Field: '</span> + node.directives.length === <span class="hljs-number">0</span> ? node.alias : node.alias + printDirectives(schema, node.directives);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.kind === <span class="hljs-string">'FragmentSpread'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'FragmentSpread:'</span> + node.args.length === <span class="hljs-number">0</span> ? node.name : node.name + printArguments(schema, node.args);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.kind === <span class="hljs-string">'ModuleImport'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'ModuleImport:'</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.kind === <span class="hljs-string">'Defer'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Defer:'</span> + node.label;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.kind === <span class="hljs-string">'Stream'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Stream:'</span> + node.label;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.kind === <span class="hljs-string">'InlineFragment'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'InlineFragment:'</span> + schema.getTypeString(node.typeCondition) + printDirectives(schema, node.directives);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.kind === <span class="hljs-string">'ClientExtension'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'ClientExtension:'</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.kind === <span class="hljs-string">'InlineDataFragmentSpread'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'InlineDataFragment:'</span> + node.name;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.kind === <span class="hljs-string">'Condition'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Condition:'</span> + (node.condition.kind === <span class="hljs-string">'Variable'</span> ? <span class="hljs-string">'$'</span> + node.condition.variableName : <span class="hljs-built_in">String</span>(node.condition.value)) + <span class="hljs-built_in">String</span>(node.passingValue);
  } <span class="hljs-keyword">else</span> {
     <span class="hljs-literal">true</span> ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'getIdentifierForSelection: Unexpected kind `%s`.'</span>, node.kind) : <span class="hljs-literal">undefined</span> : <span class="hljs-literal">undefined</span>;
  }
}

<span class="hljs-built_in">module</span>.exports = getIdentifierForSelection;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 40 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-143" id="section-143"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasUnaliasedSelection</span>(<span class="hljs-params">field, fieldName</span>) </span>{
  <span class="hljs-keyword">return</span> field.selections.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">return</span> selection.kind === <span class="hljs-string">'ScalarField'</span> &amp;&amp; selection.alias === fieldName &amp;&amp; selection.name === fieldName;
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">hasUnaliasedSelection</span>: hasUnaliasedSelection
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 41 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-144" id="section-144"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> joinArgumentDefinitions = __webpack_require__(<span class="hljs-number">92</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-145" id="section-145"></a>
</div>
<div class="dox">
<div class="summary">
<p>A transform that inlines fragment spreads with the @relay(mask: false)
directive.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maskTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">FragmentSpread</span>: visitFragmentSpread,
    <span class="hljs-attr">Fragment</span>: visitFragment
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">reachableArguments</span>: []
    };
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragment</span>(<span class="hljs-params">fragment, state</span>) </span>{
  <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.traverse(fragment, state);

  <span class="hljs-keyword">if</span> (state.reachableArguments.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-keyword">var</span> joinedArgumentDefinitions = joinArgumentDefinitions(<span class="hljs-keyword">this</span>.getContext().getSchema(), fragment, state.reachableArguments, <span class="hljs-string">'@relay(unmask: true)'</span>);
  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, result), {}, {
    <span class="hljs-attr">argumentDefinitions</span>: joinedArgumentDefinitions
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragmentSpread</span>(<span class="hljs-params">fragmentSpread, state</span>) </span>{
  <span class="hljs-keyword">if</span> (!isUnmaskedSpread(fragmentSpread)) {
    <span class="hljs-keyword">return</span> fragmentSpread;
  }

  !(fragmentSpread.args.length === <span class="hljs-number">0</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'MaskTransform: Cannot unmask fragment spread `%s` with '</span> + <span class="hljs-string">'arguments. Use the `ApplyFragmentArgumentTransform` before flattening'</span>, fragmentSpread.name) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> fragment = context.getFragment(fragmentSpread.name);
  <span class="hljs-keyword">var</span> result = {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineFragment'</span>,
    <span class="hljs-attr">directives</span>: fragmentSpread.directives,
    <span class="hljs-attr">loc</span>: {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
      <span class="hljs-attr">source</span>: fragmentSpread.loc
    },
    <span class="hljs-attr">metadata</span>: fragmentSpread.metadata,
    <span class="hljs-attr">selections</span>: fragment.selections,
    <span class="hljs-attr">typeCondition</span>: fragment.type
  };

  <span class="hljs-keyword">if</span> (fragment.directives.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> createUserError(<span class="hljs-string">'Cannot use @relay(mask: false) on fragment spreads for fragments '</span> + <span class="hljs-string">'with directives.'</span>, [fragmentSpread.loc, fragment.directives[<span class="hljs-number">0</span>].loc]);
  }

  <span class="hljs-keyword">var</span> localArgDef = fragment.argumentDefinitions.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argDef</span>) </span>{
    <span class="hljs-keyword">return</span> argDef.kind === <span class="hljs-string">'LocalArgumentDefinition'</span>;
  });

  <span class="hljs-keyword">if</span> (localArgDef != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'MaskTransform: Cannot use @relay(mask: false) on fragment spread '</span> + <span class="hljs-string">'because the fragment definition uses @argumentDefinitions.'</span>, [fragmentSpread.loc, localArgDef.loc]);
  } <span class="hljs-comment">// Note: defer validating arguments to the containing fragment in order</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-146" id="section-146"></a>
</div>
<p>to list all invalid variables/arguments instead of only one.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(fragment.argumentDefinitions),
      _step;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
      <span class="hljs-keyword">var</span> argDef = _step.value;
      state.reachableArguments.push(argDef);
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator.f();
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(result, state);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-147" id="section-147"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUnmaskedSpread</span>(<span class="hljs-params">spread</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Boolean</span>(spread.metadata &amp;&amp; spread.metadata.mask === <span class="hljs-literal">false</span>);
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: maskTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 42 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-148" id="section-148"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> getLiteralArgumentValues = __webpack_require__(<span class="hljs-number">19</span>);

<span class="hljs-keyword">var</span> getNormalizationOperationName = __webpack_require__(<span class="hljs-number">43</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError,
    createUserError = _require.createUserError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">10</span>),
    getModuleComponentKey = _require2.getModuleComponentKey,
    getModuleOperationKey = _require2.getModuleOperationKey;

<span class="hljs-keyword">var</span> SUPPORTED_ARGUMENT_NAME = <span class="hljs-string">'supported'</span>;
<span class="hljs-keyword">var</span> JS_FIELD_TYPE = <span class="hljs-string">'JSDependency'</span>;
<span class="hljs-keyword">var</span> JS_FIELD_MODULE_ARG = <span class="hljs-string">'module'</span>;
<span class="hljs-keyword">var</span> JS_FIELD_ID_ARG = <span class="hljs-string">'id'</span>;
<span class="hljs-keyword">var</span> JS_FIELD_NAME = <span class="hljs-string">'js'</span>;
<span class="hljs-keyword">var</span> SCHEMA_EXTENSION = <span class="hljs-string">"\n  directive @match(key: String) on FIELD\n\n  directive @module(\n    name: String!\n  ) on FRAGMENT_SPREAD\n"</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-149" id="section-149"></a>
</div>
<div class="dox">
<div class="summary">
<p>This transform rewrites LinkedField nodes with @match and rewrites them
into <code>LinkedField</code> nodes with a <code>supported</code> argument.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-150" id="section-150"></a>
</div>
<p>TODO: type IRTransformer to allow changing result type</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    FragmentSpread: visitFragmentSpread,
    <span class="hljs-attr">LinkedField</span>: visitLinkedField,
    <span class="hljs-attr">InlineFragment</span>: visitInlineFragment,
    <span class="hljs-attr">ScalarField</span>: visitScalarField
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">documentName</span>: node.name,
      <span class="hljs-attr">matchesForPath</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(),
      <span class="hljs-attr">moduleKey</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">parentType</span>: node.type,
      <span class="hljs-attr">path</span>: []
    };
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitInlineFragment</span>(<span class="hljs-params">node, state</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(node, _objectSpread(_objectSpread({}, state), {}, {
    <span class="hljs-attr">parentType</span>: node.typeCondition
  }));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitScalarField</span>(<span class="hljs-params">field</span>) </span>{
  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> schema = context.getSchema();

  <span class="hljs-keyword">if</span> (field.name === JS_FIELD_NAME) {
    <span class="hljs-keyword">var</span> jsModuleType = schema.getTypeFromString(JS_FIELD_TYPE);

    <span class="hljs-keyword">if</span> (jsModuleType == <span class="hljs-literal">null</span> || !schema.isServerType(jsModuleType)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> createUserError(<span class="hljs-string">"'"</span>.concat(JS_FIELD_NAME, <span class="hljs-string">"' should be defined on the server schema."</span>), [field.loc]);
    }

    <span class="hljs-keyword">if</span> (schema.isScalar(jsModuleType) &amp;&amp; schema.areEqualTypes(schema.getRawType(field.type), jsModuleType)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> createUserError(<span class="hljs-string">"Direct use of the '"</span>.concat(JS_FIELD_NAME, <span class="hljs-string">"' field is not allowed, use "</span>) + <span class="hljs-string">'@match/@module instead.'</span>, [field.loc]);
    }
  }

  <span class="hljs-keyword">return</span> field;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitLinkedField</span>(<span class="hljs-params">node, state</span>) </span>{
  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> matchDirective = node.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'match'</span>;
  });
  <span class="hljs-keyword">var</span> moduleKey = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (matchDirective != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> _getLiteralArgumentVa = getLiteralArgumentValues(matchDirective.args);

    moduleKey = _getLiteralArgumentVa.key;

    <span class="hljs-keyword">if</span> (moduleKey != <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> moduleKey !== <span class="hljs-string">'string'</span> || !moduleKey.startsWith(state.documentName))) {
      <span class="hljs-keyword">var</span> _matchDirective$args$;

      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected the 'key' argument of @match to be a literal string starting "</span> + <span class="hljs-string">"with the document name, e.g. '"</span>.concat(state.documentName, <span class="hljs-string">"_&lt;localName&gt;'."</span>), [((_matchDirective$args$ = matchDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
        <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'key'</span>;
      })) !== <span class="hljs-literal">null</span> &amp;&amp; _matchDirective$args$ !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _matchDirective$args$ : matchDirective).loc]);
    }
  }

  state.path.push(node);
  <span class="hljs-keyword">var</span> transformedNode = <span class="hljs-keyword">this</span>.traverse(node, _objectSpread(_objectSpread({}, state), {}, {
    <span class="hljs-attr">moduleKey</span>: moduleKey,
    <span class="hljs-attr">parentType</span>: node.type
  }));
  state.path.pop();

  <span class="hljs-keyword">if</span> (matchDirective == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> transformedNode;
  }

  <span class="hljs-keyword">var</span> parentType = state.parentType;
  <span class="hljs-keyword">var</span> rawType = schema.getRawType(parentType);

  <span class="hljs-keyword">if</span> (!(schema.isInterface(rawType) || schema.isObject(rawType))) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@match used on incompatible field '"</span>.concat(transformedNode.name, <span class="hljs-string">"'."</span>) + <span class="hljs-string">'@match may only be used with fields whose parent type is an '</span> + <span class="hljs-string">"interface or object, got invalid type '"</span>.concat(schema.getTypeString(parentType), <span class="hljs-string">"'."</span>), [node.loc]);
  }

  <span class="hljs-keyword">var</span> currentField = schema.getFieldConfig(schema.expectField(schema.assertCompositeType(rawType), transformedNode.name));
  <span class="hljs-keyword">var</span> supportedArgumentDefinition = currentField.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref</span>) </span>{
    <span class="hljs-keyword">var</span> name = _ref.name;
    <span class="hljs-keyword">return</span> name === SUPPORTED_ARGUMENT_NAME;
  });

  <span class="hljs-keyword">if</span> (supportedArgumentDefinition == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (moduleKey == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'@match on a field without the `supported` argument is a no-op, please remove the `@match`.'</span>, [node.loc]);
    }

    <span class="hljs-keyword">return</span> transformedNode;
  }

  <span class="hljs-keyword">var</span> supportedArgType = schema.getNullableType(supportedArgumentDefinition.type);
  <span class="hljs-keyword">var</span> supportedArgOfType = supportedArgType != <span class="hljs-literal">null</span> &amp;&amp; schema.isList(supportedArgType) ? schema.getListItemType(supportedArgType) : <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (supportedArgType == <span class="hljs-literal">null</span> || supportedArgOfType == <span class="hljs-literal">null</span> || !schema.isString(schema.getNullableType(supportedArgOfType))) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@match used on incompatible field '"</span>.concat(transformedNode.name, <span class="hljs-string">"'. "</span>) + <span class="hljs-string">'@match may only be used with fields that accept a '</span> + <span class="hljs-string">"'supported: [String!]!' argument."</span>, [node.loc]);
  }

  <span class="hljs-keyword">var</span> rawFieldType = schema.getRawType(transformedNode.type);

  <span class="hljs-keyword">if</span> (!schema.isAbstractType(rawFieldType)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@match used on incompatible field '"</span>.concat(transformedNode.name, <span class="hljs-string">"'."</span>) + <span class="hljs-string">'@match may only be used with fields that return a union or interface.'</span>, [node.loc]);
  }

  <span class="hljs-keyword">var</span> seenTypes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">var</span> selections = [];
  transformedNode.selections.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matchSelection</span>) </span>{
    <span class="hljs-keyword">if</span> (matchSelection.kind === <span class="hljs-string">'ScalarField'</span> &amp;&amp; matchSelection.name === <span class="hljs-string">'__typename'</span>) {
      selections.push(matchSelection);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> moduleImport = matchSelection.kind === <span class="hljs-string">'InlineFragment'</span> ? matchSelection.selections[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (matchSelection.kind !== <span class="hljs-string">'InlineFragment'</span> || moduleImport == <span class="hljs-literal">null</span> || moduleImport.kind !== <span class="hljs-string">'ModuleImport'</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Invalid @match selection: all selections should be '</span> + <span class="hljs-string">'fragment spreads with @module.'</span>, [matchSelection.loc]);
    }

    <span class="hljs-keyword">var</span> matchedType = matchSelection.typeCondition;
    seenTypes.set(matchedType, matchSelection);
    selections.push(matchSelection);
  });

  <span class="hljs-keyword">if</span> (seenTypes.size === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Invalid @match selection: expected at least one @module selection. '</span> + <span class="hljs-string">"Remove @match or add a '...Fragment @module()' selection."</span>, [matchDirective.loc]);
  }

  <span class="hljs-keyword">var</span> supportedArg = transformedNode.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === SUPPORTED_ARGUMENT_NAME;
  });

  <span class="hljs-keyword">if</span> (supportedArg != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid @match selection: the '"</span>.concat(SUPPORTED_ARGUMENT_NAME, <span class="hljs-string">"' argument "</span>) + <span class="hljs-string">'is automatically added and cannot be supplied explicitly.'</span>, [supportedArg.loc]);
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkedField'</span>,
    <span class="hljs-attr">alias</span>: transformedNode.alias,
    <span class="hljs-attr">args</span>: [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transformedNode.args), [{
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
      <span class="hljs-attr">name</span>: SUPPORTED_ARGUMENT_NAME,
      <span class="hljs-attr">type</span>: supportedArgumentDefinition.type,
      <span class="hljs-attr">value</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">loc</span>: node.loc,
        <span class="hljs-attr">value</span>: <span class="hljs-built_in">Array</span>.from(seenTypes.keys()).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
          <span class="hljs-keyword">return</span> schema.getTypeString(type);
        })
      },
      <span class="hljs-attr">loc</span>: node.loc
    }]),
    <span class="hljs-attr">connection</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">directives</span>: [],
    <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">loc</span>: node.loc,
    <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">name</span>: transformedNode.name,
    <span class="hljs-attr">type</span>: transformedNode.type,
    <span class="hljs-attr">selections</span>: selections
  };
} <span class="hljs-comment">// Transform @module</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragmentSpread</span>(<span class="hljs-params">spread, _ref2</span>) </span>{
  <span class="hljs-keyword">var</span> _moduleDirective$args2, _moduleDirective$args3, _moduleDirective$args4, _moduleDirective$args5, _moduleDirective$args6, _moduleDirective$args7;

  <span class="hljs-keyword">var</span> documentName = _ref2.documentName,
      path = _ref2.path,
      matchesForPath = _ref2.matchesForPath,
      moduleKeyFromParent = _ref2.moduleKey;
  <span class="hljs-keyword">var</span> transformedNode = <span class="hljs-keyword">this</span>.traverse(spread);
  <span class="hljs-keyword">var</span> moduleDirective = transformedNode.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'module'</span>;
  });

  <span class="hljs-keyword">if</span> (moduleDirective == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> transformedNode;
  }

  <span class="hljs-keyword">if</span> (spread.args.length !== <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">var</span> _spread$args$;

    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'@module does not support @arguments.'</span>, [(_spread$args$ = spread.args[<span class="hljs-number">0</span>]) === <span class="hljs-literal">null</span> || _spread$args$ === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _spread$args$.loc].filter(<span class="hljs-built_in">Boolean</span>));
  }

  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> jsModuleType = schema.asScalarFieldType(schema.getTypeFromString(JS_FIELD_TYPE));

  <span class="hljs-keyword">if</span> (jsModuleType == <span class="hljs-literal">null</span> || !schema.isServerType(jsModuleType)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> createUserError(<span class="hljs-string">"'"</span>.concat(JS_FIELD_NAME, <span class="hljs-string">"' should be defined on the server schema."</span>), [spread.loc]);
  }

  <span class="hljs-keyword">if</span> (!schema.isScalar(jsModuleType)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Using @module requires the schema to define a scalar '</span> + <span class="hljs-string">"'"</span>.concat(JS_FIELD_TYPE, <span class="hljs-string">"' type."</span>));
  }

  <span class="hljs-keyword">var</span> fragment = context.getFragment(spread.name, spread.loc);

  <span class="hljs-keyword">if</span> (!schema.isObject(fragment.type)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@module used on invalid fragment spread '..."</span>.concat(spread.name, <span class="hljs-string">"'. @module "</span>) + <span class="hljs-string">'may only be used with fragments on a concrete (object) type, '</span> + <span class="hljs-string">"but the fragment has abstract type '"</span>.concat(schema.getTypeString(fragment.type), <span class="hljs-string">"'."</span>), [spread.loc, fragment.loc]);
  }

  <span class="hljs-keyword">var</span> field = schema.getFieldByName(fragment.type, JS_FIELD_NAME);

  <span class="hljs-keyword">if</span> (!field) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@module used on invalid fragment spread '..."</span>.concat(spread.name, <span class="hljs-string">"'. @module "</span>) + <span class="hljs-string">"requires the fragment type '"</span>.concat(schema.getTypeString(fragment.type), <span class="hljs-string">"' to have a "</span>) + <span class="hljs-string">"'"</span>.concat(JS_FIELD_NAME, <span class="hljs-string">"("</span>).concat(JS_FIELD_MODULE_ARG, <span class="hljs-string">": String! "</span>) + <span class="hljs-string">"["</span>.concat(JS_FIELD_ID_ARG, <span class="hljs-string">": String]): "</span>).concat(JS_FIELD_TYPE, <span class="hljs-string">"' field (your "</span>) + <span class="hljs-string">"schema may choose to omit the 'id'  argument but if present it "</span> + <span class="hljs-string">"must accept a 'String')."</span>, [moduleDirective.loc]);
  }

  <span class="hljs-keyword">var</span> jsField = schema.getFieldConfig(field);
  <span class="hljs-keyword">var</span> jsFieldModuleArg = jsField ? jsField.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === JS_FIELD_MODULE_ARG;
  }) : <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> jsFieldIdArg = jsField ? jsField.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === JS_FIELD_ID_ARG;
  }) : <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (jsFieldModuleArg == <span class="hljs-literal">null</span> || !schema.isString(schema.getNullableType(jsFieldModuleArg.type)) || jsFieldIdArg != <span class="hljs-literal">null</span> &amp;&amp; !schema.isString(jsFieldIdArg.type) || jsField.type !== jsModuleType) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@module used on invalid fragment spread '..."</span>.concat(spread.name, <span class="hljs-string">"'. @module "</span>) + <span class="hljs-string">"requires the fragment type '"</span>.concat(schema.getTypeString(fragment.type), <span class="hljs-string">"' to have a "</span>) + <span class="hljs-string">"'"</span>.concat(JS_FIELD_NAME, <span class="hljs-string">"("</span>).concat(JS_FIELD_MODULE_ARG, <span class="hljs-string">": String! "</span>) + <span class="hljs-string">"["</span>.concat(JS_FIELD_ID_ARG, <span class="hljs-string">": String]): "</span>).concat(JS_FIELD_TYPE, <span class="hljs-string">"' field (your "</span>) + <span class="hljs-string">"schema may choose to omit the 'id'  argument but if present it "</span> + <span class="hljs-string">"must accept a 'String')."</span>, [moduleDirective.loc]);
  }

  <span class="hljs-keyword">if</span> (spread.directives.length !== <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@module used on invalid fragment spread '..."</span>.concat(spread.name, <span class="hljs-string">"'. @module "</span>) + <span class="hljs-string">'may not have additional directives.'</span>, [spread.loc]);
  }

  <span class="hljs-keyword">var</span> _getLiteralArgumentVa2 = getLiteralArgumentValues(moduleDirective.args),
      moduleName = _getLiteralArgumentVa2.name;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> moduleName !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">var</span> _moduleDirective$args;

    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected the 'name' argument of @module to be a literal string"</span>, [((_moduleDirective$args = moduleDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'name'</span>;
    })) !== <span class="hljs-literal">null</span> &amp;&amp; _moduleDirective$args !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _moduleDirective$args : spread).loc]);
  }

  <span class="hljs-keyword">var</span> parentField = path[path.length - <span class="hljs-number">1</span>];
  <span class="hljs-keyword">var</span> moduleKey = moduleKeyFromParent !== <span class="hljs-literal">null</span> &amp;&amp; moduleKeyFromParent !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? moduleKeyFromParent : documentName;
  <span class="hljs-keyword">var</span> aliasPath = path.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x.alias;
  }).join(<span class="hljs-string">'.'</span>);
  <span class="hljs-keyword">var</span> moduleId = aliasPath === <span class="hljs-string">''</span> ? documentName : <span class="hljs-string">""</span>.concat(documentName, <span class="hljs-string">"."</span>).concat(aliasPath);
  <span class="hljs-keyword">var</span> typeName = schema.getTypeString(fragment.type);
  <span class="hljs-keyword">var</span> matches = matchesForPath.get(aliasPath);

  <span class="hljs-keyword">if</span> (matches == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> _parentField$loc;

    <span class="hljs-keyword">if</span> (matchesForPath.size !== <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> existingMatchWithKey = <span class="hljs-built_in">Array</span>.from(matchesForPath.values()).find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entry</span>) </span>{
        <span class="hljs-keyword">return</span> entry.key === moduleKey;
      });

      <span class="hljs-keyword">if</span> (existingMatchWithKey != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (parentField == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Cannot have @module selections at multiple paths unless the selections are within fields.'</span>, [spread.loc]);
        }

        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Invalid @module selection: documents with multiple fields '</span> + <span class="hljs-string">"containing 3D selections must specify a unique 'key' value "</span> + <span class="hljs-string">"for each field: use '"</span>.concat(parentField.alias, <span class="hljs-string">" @match(key: \""</span>).concat(documentName, <span class="hljs-string">"_&lt;localName&gt;\")'."</span>), [parentField.loc]);
      }
    }

    matches = {
      <span class="hljs-attr">key</span>: moduleKey,
      <span class="hljs-attr">location</span>: (_parentField$loc = parentField === <span class="hljs-literal">null</span> || parentField === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : parentField.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _parentField$loc !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _parentField$loc : spread.loc,
      <span class="hljs-attr">types</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()
    };
    matchesForPath.set(aliasPath, matches);
  }

  <span class="hljs-keyword">if</span> (moduleKey !== matches.key) {
    <span class="hljs-keyword">var</span> _parentField$loc2;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-151" id="section-151"></a>
</div>
<p>The user can't override the key locally (per @module),
so this is just an internal sanity check</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Invalid @module selection: expected all selections at path '</span> + <span class="hljs-string">"'"</span>.concat(aliasPath, <span class="hljs-string">" to have the same 'key', got '"</span>).concat(moduleKey, <span class="hljs-string">"' and '"</span>).concat(matches.key, <span class="hljs-string">"'."</span>), [(_parentField$loc2 = parentField === <span class="hljs-literal">null</span> || parentField === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : parentField.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _parentField$loc2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _parentField$loc2 : spread.loc]);
  }

  <span class="hljs-keyword">var</span> previousMatchForType = matches.types.get(typeName);

  <span class="hljs-keyword">if</span> (previousMatchForType != <span class="hljs-literal">null</span> &amp;&amp; (previousMatchForType.fragment !== spread.name || previousMatchForType.module !== moduleName)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Invalid @module selection: concrete type '</span> + <span class="hljs-string">"'"</span>.concat(typeName, <span class="hljs-string">"' was matched multiple times at path "</span>) + <span class="hljs-string">"'"</span>.concat(aliasPath, <span class="hljs-string">"' but with a different fragment or module name."</span>), [spread.loc, previousMatchForType.location]);
  }

  matches.types.set(typeName, {
    <span class="hljs-attr">location</span>: spread.loc,
    <span class="hljs-attr">fragment</span>: spread.name,
    <span class="hljs-attr">module</span>: moduleName
  });
  <span class="hljs-keyword">var</span> normalizationName = getNormalizationOperationName(spread.name) + <span class="hljs-string">'.graphql'</span>;
  <span class="hljs-keyword">var</span> componentKey = getModuleComponentKey(moduleKey);
  <span class="hljs-keyword">var</span> componentField = {
    <span class="hljs-attr">alias</span>: componentKey,
    <span class="hljs-attr">args</span>: [{
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
      <span class="hljs-attr">name</span>: JS_FIELD_MODULE_ARG,
      <span class="hljs-attr">type</span>: jsFieldModuleArg.type,
      <span class="hljs-attr">value</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">loc</span>: (_moduleDirective$args2 = (_moduleDirective$args3 = moduleDirective.args[<span class="hljs-number">0</span>]) === <span class="hljs-literal">null</span> || _moduleDirective$args3 === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _moduleDirective$args3.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _moduleDirective$args2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _moduleDirective$args2 : moduleDirective.loc,
        <span class="hljs-attr">value</span>: moduleName
      },
      <span class="hljs-attr">loc</span>: moduleDirective.loc
    }, jsFieldIdArg != <span class="hljs-literal">null</span> ? {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
      <span class="hljs-attr">name</span>: JS_FIELD_ID_ARG,
      <span class="hljs-attr">type</span>: jsFieldIdArg.type,
      <span class="hljs-attr">value</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">loc</span>: (_moduleDirective$args4 = (_moduleDirective$args5 = moduleDirective.args[<span class="hljs-number">0</span>]) === <span class="hljs-literal">null</span> || _moduleDirective$args5 === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _moduleDirective$args5.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _moduleDirective$args4 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _moduleDirective$args4 : moduleDirective.loc,
        <span class="hljs-attr">value</span>: moduleId
      },
      <span class="hljs-attr">loc</span>: moduleDirective.loc
    } : <span class="hljs-literal">null</span>].filter(<span class="hljs-built_in">Boolean</span>),
    <span class="hljs-attr">directives</span>: [],
    <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'ScalarField'</span>,
    <span class="hljs-attr">loc</span>: moduleDirective.loc,
    <span class="hljs-attr">metadata</span>: {
      <span class="hljs-attr">skipNormalizationNode</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-attr">name</span>: JS_FIELD_NAME,
    <span class="hljs-attr">type</span>: jsModuleType
  };
  <span class="hljs-keyword">var</span> operationKey = getModuleOperationKey(moduleKey);
  <span class="hljs-keyword">var</span> operationField = {
    <span class="hljs-attr">alias</span>: operationKey,
    <span class="hljs-attr">args</span>: [{
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
      <span class="hljs-attr">name</span>: JS_FIELD_MODULE_ARG,
      <span class="hljs-attr">type</span>: jsFieldModuleArg.type,
      <span class="hljs-attr">value</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">loc</span>: moduleDirective.loc,
        <span class="hljs-attr">value</span>: normalizationName
      },
      <span class="hljs-attr">loc</span>: moduleDirective.loc
    }, jsFieldIdArg != <span class="hljs-literal">null</span> ? {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
      <span class="hljs-attr">name</span>: JS_FIELD_ID_ARG,
      <span class="hljs-attr">type</span>: jsFieldIdArg.type,
      <span class="hljs-attr">value</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">loc</span>: (_moduleDirective$args6 = (_moduleDirective$args7 = moduleDirective.args[<span class="hljs-number">0</span>]) === <span class="hljs-literal">null</span> || _moduleDirective$args7 === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _moduleDirective$args7.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _moduleDirective$args6 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _moduleDirective$args6 : moduleDirective.loc,
        <span class="hljs-attr">value</span>: moduleId
      },
      <span class="hljs-attr">loc</span>: moduleDirective.loc
    } : <span class="hljs-literal">null</span>].filter(<span class="hljs-built_in">Boolean</span>),
    <span class="hljs-attr">directives</span>: [],
    <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'ScalarField'</span>,
    <span class="hljs-attr">loc</span>: moduleDirective.loc,
    <span class="hljs-attr">metadata</span>: {
      <span class="hljs-attr">skipNormalizationNode</span>: <span class="hljs-literal">true</span>
    },
    <span class="hljs-attr">name</span>: JS_FIELD_NAME,
    <span class="hljs-attr">type</span>: jsModuleType
  };
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineFragment'</span>,
    <span class="hljs-attr">directives</span>: [],
    <span class="hljs-attr">loc</span>: moduleDirective.loc,
    <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">selections</span>: [{
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'ModuleImport'</span>,
      <span class="hljs-attr">loc</span>: moduleDirective.loc,
      <span class="hljs-attr">key</span>: moduleKey,
      <span class="hljs-attr">id</span>: moduleId,
      <span class="hljs-attr">module</span>: moduleName,
      <span class="hljs-attr">sourceDocument</span>: documentName,
      <span class="hljs-attr">name</span>: spread.name,
      <span class="hljs-attr">selections</span>: [_objectSpread(_objectSpread({}, spread), {}, {
        <span class="hljs-attr">directives</span>: spread.directives.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
          <span class="hljs-keyword">return</span> directive !== moduleDirective;
        })
      }), operationField, componentField]
    }],
    <span class="hljs-attr">typeCondition</span>: fragment.type
  };
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">SCHEMA_EXTENSION</span>: SCHEMA_EXTENSION,
  <span class="hljs-attr">transform</span>: matchTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 43 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-152" id="section-152"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNormalizationOperationName</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.concat(name, <span class="hljs-string">"$normalization"</span>);
}

<span class="hljs-built_in">module</span>.exports = getNormalizationOperationName;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 44 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-153" id="section-153"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRVisitor = __webpack_require__(<span class="hljs-number">18</span>);

<span class="hljs-keyword">var</span> getLiteralArgumentValues = __webpack_require__(<span class="hljs-number">19</span>);

<span class="hljs-keyword">var</span> inferRootArgumentDefinitions = __webpack_require__(<span class="hljs-number">20</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError,
    eachWithCombinedError = _require.eachWithCombinedError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">94</span>),
    buildRefetchOperation = _require2.buildRefetchOperation;

<span class="hljs-keyword">var</span> SCHEMA_EXTENSION = <span class="hljs-string">"\n  directive @refetchable(\n    queryName: String!\n  ) on FRAGMENT_DEFINITION\n"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-154" id="section-154"></a>
</div>
<div class="dox">
<div class="summary">
<p>This transform synthesizes &quot;refetch&quot; queries for fragments that
are trivially refetchable. This is comprised of three main stages:</p>
</div>
<div class="body">
<ol>
<li>Validating that fragments marked with @refetchable qualify for
refetch query generation; mainly this means that the fragment
type is able to be refetched in some canonical way.</li>
<li>Determining the variable definitions to use for each generated
query. GraphQL does not have a notion of fragment-local variables
at all, and although Relay adds this concept developers are still
allowed to reference global variables. This necessitates a
visiting all reachable fragments for each @refetchable fragment,
and finding the union of all global variables expceted to be defined.</li>
<li>Building the refetch queries, a straightforward copying transform from
Fragment to Root IR nodes.</li>
</ol>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refetchableFragmentTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> refetchOperations = buildRefetchMap(context);
  <span class="hljs-keyword">var</span> nextContext = context;
  eachWithCombinedError(refetchOperations, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref</span>) </span>{
    <span class="hljs-keyword">var</span> refetchName = _ref[<span class="hljs-number">0</span>],
        fragment = _ref[<span class="hljs-number">1</span>];

    <span class="hljs-keyword">var</span> _buildRefetchOperatio = buildRefetchOperation(schema, fragment, refetchName),
        identifierField = _buildRefetchOperatio.identifierField,
        path = _buildRefetchOperatio.path,
        node = _buildRefetchOperatio.node,
        transformedFragment = _buildRefetchOperatio.transformedFragment;

    <span class="hljs-keyword">var</span> connectionMetadata = extractConnectionMetadata(context.getSchema(), transformedFragment);
    nextContext = nextContext.replace(_objectSpread(_objectSpread({}, transformedFragment), {}, {
      <span class="hljs-attr">metadata</span>: _objectSpread(_objectSpread({}, transformedFragment.metadata || {}), {}, {
        <span class="hljs-attr">refetch</span>: {
          <span class="hljs-attr">connection</span>: connectionMetadata !== <span class="hljs-literal">null</span> &amp;&amp; connectionMetadata !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? connectionMetadata : <span class="hljs-literal">null</span>,
          <span class="hljs-attr">operation</span>: refetchName,
          <span class="hljs-attr">fragmentPathInResult</span>: path,
          <span class="hljs-attr">identifierField</span>: identifierField
        }
      })
    }));
    nextContext = nextContext.add(_objectSpread(_objectSpread({}, node), {}, {
      <span class="hljs-attr">metadata</span>: _objectSpread(_objectSpread({}, node.metadata || {}), {}, {
        <span class="hljs-attr">derivedFrom</span>: transformedFragment.name,
        <span class="hljs-attr">isRefetchableQuery</span>: <span class="hljs-literal">true</span>
      })
    }));
  });
  <span class="hljs-keyword">return</span> nextContext;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-155" id="section-155"></a>
</div>
<div class="dox">
<div class="summary">
<p>Walk the documents of a compiler context and create a mapping of
refetch operation names to the source fragment from which the refetch
operation should be derived.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildRefetchMap</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> refetchOperations = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  eachWithCombinedError(context.documents(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">if</span> (node.kind !== <span class="hljs-string">'Fragment'</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> refetchName = getRefetchQueryName(node);

    <span class="hljs-keyword">if</span> (refetchName === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> previousOperation = refetchOperations.get(refetchName);

    <span class="hljs-keyword">if</span> (previousOperation != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Duplicate definition for @refetchable operation '"</span>.concat(refetchName, <span class="hljs-string">"' from fragments '"</span>).concat(node.name, <span class="hljs-string">"' and '"</span>).concat(previousOperation.name, <span class="hljs-string">"'"</span>), [node.loc, previousOperation.loc]);
    }

    refetchOperations.set(refetchName, node);
  });
  <span class="hljs-keyword">var</span> transformed = inferRootArgumentDefinitions(context);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(<span class="hljs-built_in">Array</span>.from(refetchOperations.entries(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref2</span>) </span>{
    <span class="hljs-keyword">var</span> name = _ref2[<span class="hljs-number">0</span>],
        fragment = _ref2[<span class="hljs-number">1</span>];
    <span class="hljs-keyword">return</span> [name, transformed.getFragment(fragment.name)];
  }));
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-156" id="section-156"></a>
</div>
<div class="dox">
<div class="summary">
<p>Validate that any @connection usage is valid for refetching:</p>
<ul>
<li>Variables are used for both the &quot;count&quot; and &quot;cursor&quot; arguments
(after/first or before/last)</li>
<li>Exactly one connection</li>
<li>Has a stable path to the connection data</li>
</ul>
</div>
<div class="body">
<p>Returns connection metadata to add to the transformed fragment or undefined
if there is no connection.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractConnectionMetadata</span>(<span class="hljs-params">schema, fragment</span>) </span>{
  <span class="hljs-keyword">var</span> fields = [];
  <span class="hljs-keyword">var</span> connectionField = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> path = <span class="hljs-literal">null</span>;
  IRVisitor.visit(fragment, {
    <span class="hljs-attr">LinkedField</span>: {
      <span class="hljs-attr">enter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enter</span>(<span class="hljs-params">field</span>) </span>{
        fields.push(field);

        <span class="hljs-keyword">if</span> (field.connection === <span class="hljs-literal">true</span> || field.handles &amp;&amp; field.handles.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">handle</span>) </span>{
          <span class="hljs-keyword">return</span> handle.name === <span class="hljs-string">'connection'</span>;
        })) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-157" id="section-157"></a>
</div>
<p>Disallow multiple @connections</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (connectionField != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @refetchable with @connection in fragment '"</span>.concat(fragment.name, <span class="hljs-string">"', at most once @connection can appear in a refetchable fragment."</span>), [field.loc]);
          } <span class="hljs-comment">// Disallow connections within plurals</span>


          <span class="hljs-keyword">var</span> pluralOnPath = fields.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pathField</span>) </span>{
            <span class="hljs-keyword">return</span> schema.isList(schema.getNullableType(pathField.type));
          });

          <span class="hljs-keyword">if</span> (pluralOnPath) {
            <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @refetchable with @connection in fragment '"</span>.concat(fragment.name, <span class="hljs-string">"', refetchable connections cannot appear inside plural fields."</span>), [field.loc, pluralOnPath.loc]);
          }

          connectionField = field;
          path = fields.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pathField</span>) </span>{
            <span class="hljs-keyword">return</span> pathField.alias;
          });
        }
      },
      <span class="hljs-attr">leave</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">leave</span>(<span class="hljs-params"></span>) </span>{
        fields.pop();
      }
    }
  });

  <span class="hljs-keyword">if</span> (connectionField == <span class="hljs-literal">null</span> || path == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  } <span class="hljs-comment">// Validate arguments: if either of before/last appear they must both appear</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-158" id="section-158"></a>
</div>
<p>and use variables (not scalar values)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">var</span> backward = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> before = findArgument(connectionField, <span class="hljs-string">'before'</span>);
  <span class="hljs-keyword">var</span> last = findArgument(connectionField, <span class="hljs-string">'last'</span>);

  <span class="hljs-keyword">if</span> (before || last) {
    <span class="hljs-keyword">if</span> (!before || !last || before.value.kind !== <span class="hljs-string">'Variable'</span> || last.value.kind !== <span class="hljs-string">'Variable'</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @refetchable with @connection in fragment '"</span>.concat(fragment.name, <span class="hljs-string">"', refetchable connections must use variables for the before and last arguments."</span>), [connectionField.loc, before &amp;&amp; before.value.kind !== <span class="hljs-string">'Variable'</span> ? before.value.loc : <span class="hljs-literal">null</span>, last &amp;&amp; last.value.kind !== <span class="hljs-string">'Variable'</span> ? last.value.loc : <span class="hljs-literal">null</span>].filter(<span class="hljs-built_in">Boolean</span>));
    }

    backward = {
      <span class="hljs-attr">count</span>: last.value.variableName,
      <span class="hljs-attr">cursor</span>: before.value.variableName
    };
  } <span class="hljs-comment">// Validate arguments: if either of after/first appear they must both appear</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-159" id="section-159"></a>
</div>
<p>and use variables (not scalar values)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">var</span> forward = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> after = findArgument(connectionField, <span class="hljs-string">'after'</span>);
  <span class="hljs-keyword">var</span> first = findArgument(connectionField, <span class="hljs-string">'first'</span>);

  <span class="hljs-keyword">if</span> (after || first) {
    <span class="hljs-keyword">if</span> (!after || !first || after.value.kind !== <span class="hljs-string">'Variable'</span> || first.value.kind !== <span class="hljs-string">'Variable'</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @refetchable with @connection in fragment '"</span>.concat(fragment.name, <span class="hljs-string">"', refetchable connections must use variables for the after and first arguments."</span>), [connectionField.loc, after &amp;&amp; after.value.kind !== <span class="hljs-string">'Variable'</span> ? after.value.loc : <span class="hljs-literal">null</span>, first &amp;&amp; first.value.kind !== <span class="hljs-string">'Variable'</span> ? first.value.loc : <span class="hljs-literal">null</span>].filter(<span class="hljs-built_in">Boolean</span>));
    }

    forward = {
      <span class="hljs-attr">count</span>: first.value.variableName,
      <span class="hljs-attr">cursor</span>: after.value.variableName
    };
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">forward</span>: forward,
    <span class="hljs-attr">backward</span>: backward,
    <span class="hljs-attr">path</span>: path
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRefetchQueryName</span>(<span class="hljs-params">fragment</span>) </span>{
  <span class="hljs-keyword">var</span> refetchableDirective = fragment.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'refetchable'</span>;
  });

  <span class="hljs-keyword">if</span> (refetchableDirective == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> refetchArguments = getLiteralArgumentValues(refetchableDirective.args);
  <span class="hljs-keyword">var</span> queryName = refetchArguments.queryName;

  <span class="hljs-keyword">if</span> (queryName == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected the 'queryName' argument of @refetchable to be provided"</span>, [refetchableDirective.loc]);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> queryName !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">var</span> _queryNameArg$loc;

    <span class="hljs-keyword">var</span> queryNameArg = refetchableDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'queryName'</span>;
    });
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected the 'queryName' argument of @refetchable to be a string, got '"</span>.concat(<span class="hljs-built_in">String</span>(queryName), <span class="hljs-string">"'."</span>), [(_queryNameArg$loc = queryNameArg === <span class="hljs-literal">null</span> || queryNameArg === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : queryNameArg.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _queryNameArg$loc !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _queryNameArg$loc : refetchableDirective.loc]);
  }

  <span class="hljs-keyword">return</span> queryName;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findArgument</span>(<span class="hljs-params">field, argumentName</span>) </span>{
  <span class="hljs-keyword">var</span> _field$args$find;

  <span class="hljs-keyword">return</span> (_field$args$find = field.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === argumentName;
  })) !== <span class="hljs-literal">null</span> &amp;&amp; _field$args$find !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _field$args$find : <span class="hljs-literal">null</span>;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">SCHEMA_EXTENSION</span>: SCHEMA_EXTENSION,
  <span class="hljs-attr">transform</span>: refetchableFragmentTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 45 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-160" id="section-160"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> getLiteralArgumentValues = __webpack_require__(<span class="hljs-number">19</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> RELAY = <span class="hljs-string">'relay'</span>;
<span class="hljs-keyword">var</span> SCHEMA_EXTENSION = <span class="hljs-string">"\ndirective @relay(\n  # Marks a fragment as being backed by a GraphQLList.\n  plural: Boolean,\n\n  # Marks a fragment spread which should be unmasked if provided false\n  mask: Boolean = true,\n) on FRAGMENT_DEFINITION | FRAGMENT_SPREAD\n"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-161" id="section-161"></a>
</div>
<div class="dox">
<div class="summary">
<p>A transform that extracts <code>@relay(plural: Boolean)</code> directives and converts
them to metadata that can be accessed at runtime.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">relayDirectiveTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">Fragment</span>: visitRelayMetadata(fragmentMetadata),
    <span class="hljs-attr">FragmentSpread</span>: visitRelayMetadata(fragmentSpreadMetadata)
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitRelayMetadata</span>(<span class="hljs-params">metadataFn</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">var</span> relayDirective = node.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref</span>) </span>{
      <span class="hljs-keyword">var</span> name = _ref.name;
      <span class="hljs-keyword">return</span> name === RELAY;
    });

    <span class="hljs-keyword">if</span> (!relayDirective) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(node);
    }

    <span class="hljs-keyword">var</span> argValues = getLiteralArgumentValues(relayDirective.args);
    <span class="hljs-keyword">var</span> metadata = metadataFn(argValues);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(_objectSpread(_objectSpread({}, node), {}, {
      <span class="hljs-attr">directives</span>: node.directives.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
        <span class="hljs-keyword">return</span> directive !== relayDirective;
      }),
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-162" id="section-162"></a>
</div>
<p>$FlowFixMe[cannot-spread-indexer]</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      metadata: _objectSpread(_objectSpread({}, node.metadata || {}), metadata)
    }));
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fragmentMetadata</span>(<span class="hljs-params">_ref2</span>) </span>{
  <span class="hljs-keyword">var</span> mask = _ref2.mask,
      plural = _ref2.plural;
  !(plural === <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">typeof</span> plural === <span class="hljs-string">'boolean'</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayDirectiveTransform: Expected the "plural" argument to @relay '</span> + <span class="hljs-string">'to be a boolean literal if specified.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  !(mask === <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">typeof</span> mask === <span class="hljs-string">'boolean'</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayDirectiveTransform: Expected the "mask" argument to @relay '</span> + <span class="hljs-string">'to be a boolean literal if specified.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">mask</span>: mask,
    <span class="hljs-attr">plural</span>: plural
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fragmentSpreadMetadata</span>(<span class="hljs-params">_ref3</span>) </span>{
  <span class="hljs-keyword">var</span> mask = _ref3.mask;
  !(mask === <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">typeof</span> mask === <span class="hljs-string">'boolean'</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayDirectiveTransform: Expected the "mask" argument to @relay '</span> + <span class="hljs-string">'to be a boolean literal if specified.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">mask</span>: mask
  };
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">RELAY</span>: RELAY,
  <span class="hljs-attr">SCHEMA_EXTENSION</span>: SCHEMA_EXTENSION,
  <span class="hljs-attr">transform</span>: relayDirectiveTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 46 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-163" id="section-163"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> FlattenTransform = __webpack_require__(<span class="hljs-number">38</span>);

<span class="hljs-keyword">var</span> IRVisitor = __webpack_require__(<span class="hljs-number">18</span>);

<span class="hljs-keyword">var</span> MaskTransform = __webpack_require__(<span class="hljs-number">41</span>);

<span class="hljs-keyword">var</span> MatchTransform = __webpack_require__(<span class="hljs-number">42</span>);

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>);

<span class="hljs-keyword">var</span> RefetchableFragmentTransform = __webpack_require__(<span class="hljs-number">44</span>);

<span class="hljs-keyword">var</span> RelayDirectiveTransform = __webpack_require__(<span class="hljs-number">45</span>);

<span class="hljs-keyword">var</span> RequiredFieldTransform = __webpack_require__(<span class="hljs-number">47</span>);

<span class="hljs-keyword">var</span> generateAbstractTypeRefinementKey = __webpack_require__(<span class="hljs-number">17</span>);

<span class="hljs-keyword">var</span> partitionArray = __webpack_require__(<span class="hljs-number">15</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">48</span>),
    anyTypeAlias = _require.anyTypeAlias,
    declareExportOpaqueType = _require.declareExportOpaqueType,
    exactObjectTypeAnnotation = _require.exactObjectTypeAnnotation,
    exportType = _require.exportType,
    exportTypes = _require.exportTypes,
    importTypes = _require.importTypes,
    inexactObjectTypeAnnotation = _require.inexactObjectTypeAnnotation,
    intersectionTypeAnnotation = _require.intersectionTypeAnnotation,
    lineComments = _require.lineComments,
    readOnlyArrayOfType = _require.readOnlyArrayOfType,
    readOnlyObjectTypeProperty = _require.readOnlyObjectTypeProperty,
    unionTypeAnnotation = _require.unionTypeAnnotation;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">99</span>),
    transformInputType = _require2.transformInputType,
    transformScalarType = _require2.transformScalarType;

<span class="hljs-keyword">var</span> babelGenerator = __webpack_require__(<span class="hljs-number">100</span>)[<span class="hljs-string">"default"</span>];

<span class="hljs-keyword">var</span> t = __webpack_require__(<span class="hljs-number">25</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> nullthrows = __webpack_require__(<span class="hljs-number">16</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generate</span>(<span class="hljs-params">schema, node, options</span>) </span>{
  <span class="hljs-keyword">var</span> ast = IRVisitor.visit(node, createVisitor(schema, options));
  <span class="hljs-keyword">return</span> babelGenerator(ast).code;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeProp</span>(<span class="hljs-params">schema, _ref, state, unmasked, concreteType</span>) </span>{
  <span class="hljs-keyword">var</span> key = _ref.key,
      schemaName = _ref.schemaName,
      value = _ref.value,
      conditional = _ref.conditional,
      nodeType = _ref.nodeType,
      nodeSelections = _ref.nodeSelections;

  <span class="hljs-keyword">if</span> (schemaName === <span class="hljs-string">'__typename'</span> &amp;&amp; concreteType) {
    value = t.stringLiteralTypeAnnotation(concreteType);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeType) {
    value = transformScalarType(schema, nodeType, state, selectionsToBabel(schema, [<span class="hljs-built_in">Array</span>.from(nullthrows(nodeSelections).values())], state, unmasked));
  }

  <span class="hljs-keyword">var</span> typeProperty = readOnlyObjectTypeProperty(key, value);

  <span class="hljs-keyword">if</span> (conditional) {
    typeProperty.optional = <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">return</span> typeProperty;
}

<span class="hljs-keyword">var</span> isTypenameSelection = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTypenameSelection</span>(<span class="hljs-params">selection</span>) </span>{
  <span class="hljs-keyword">return</span> selection.schemaName === <span class="hljs-string">'__typename'</span>;
};

<span class="hljs-keyword">var</span> hasTypenameSelection = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasTypenameSelection</span>(<span class="hljs-params">selections</span>) </span>{
  <span class="hljs-keyword">return</span> selections.some(isTypenameSelection);
};

<span class="hljs-keyword">var</span> onlySelectsTypename = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onlySelectsTypename</span>(<span class="hljs-params">selections</span>) </span>{
  <span class="hljs-keyword">return</span> selections.every(isTypenameSelection);
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionsToBabel</span>(<span class="hljs-params">schema, selections, state, unmasked, fragmentTypeName</span>) </span>{
  <span class="hljs-keyword">var</span> baseFields = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">var</span> byConcreteType = {};
  flattenArray(selections).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">var</span> concreteType = selection.concreteType;

    <span class="hljs-keyword">if</span> (concreteType) {
      <span class="hljs-keyword">var</span> _byConcreteType$concr;

      byConcreteType[concreteType] = (_byConcreteType$concr = byConcreteType[concreteType]) !== <span class="hljs-literal">null</span> &amp;&amp; _byConcreteType$concr !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _byConcreteType$concr : [];
      byConcreteType[concreteType].push(selection);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> previousSel = baseFields.get(selection.key);
      baseFields.set(selection.key, previousSel ? mergeSelection(selection, previousSel) : selection);
    }
  });
  <span class="hljs-keyword">var</span> types = [];

  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(byConcreteType).length &gt; <span class="hljs-number">0</span> &amp;&amp; onlySelectsTypename(<span class="hljs-built_in">Array</span>.from(baseFields.values())) &amp;&amp; (hasTypenameSelection(<span class="hljs-built_in">Array</span>.from(baseFields.values())) || <span class="hljs-built_in">Object</span>.keys(byConcreteType).every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> hasTypenameSelection(byConcreteType[type]);
  }))) {
    (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> typenameAliases = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();

      <span class="hljs-keyword">var</span> _loop = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_loop</span>(<span class="hljs-params">concreteType</span>) </span>{
        types.push(groupRefs([].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(<span class="hljs-built_in">Array</span>.from(baseFields.values())), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(byConcreteType[concreteType]))).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
          <span class="hljs-keyword">if</span> (selection.schemaName === <span class="hljs-string">'__typename'</span>) {
            typenameAliases.add(selection.key);
          }

          <span class="hljs-keyword">return</span> makeProp(schema, selection, state, unmasked, concreteType);
        }));
      };

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> concreteType <span class="hljs-keyword">in</span> byConcreteType) {
        _loop(concreteType);
      } <span class="hljs-comment">// It might be some other type then the listed concrete types. Ideally, we</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-164" id="section-164"></a>
</div>
<p>would set the type to diff(string, set of listed concrete types), but
this doesn't exist in Flow at the time.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      types.push(<span class="hljs-built_in">Array</span>.from(typenameAliases).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">typenameAlias</span>) </span>{
        <span class="hljs-keyword">var</span> otherProp = readOnlyObjectTypeProperty(typenameAlias, t.stringLiteralTypeAnnotation(<span class="hljs-string">'%other'</span>));
        otherProp.leadingComments = lineComments(<span class="hljs-string">"This will never be '%other', but we need some"</span>, <span class="hljs-string">'value in case none of the concrete values match.'</span>);
        <span class="hljs-keyword">return</span> otherProp;
      }));
    })();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> selectionMap = selectionsToMap(<span class="hljs-built_in">Array</span>.from(baseFields.values()));

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> concreteType <span class="hljs-keyword">in</span> byConcreteType) {
      selectionMap = mergeSelections(selectionMap, selectionsToMap(byConcreteType[concreteType].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sel</span>) </span>{
        <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, sel), {}, {
          <span class="hljs-attr">conditional</span>: <span class="hljs-literal">true</span>
        });
      })));
    }

    <span class="hljs-keyword">var</span> selectionMapValues = groupRefs(<span class="hljs-built_in">Array</span>.from(selectionMap.values())).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sel</span>) </span>{
      <span class="hljs-keyword">return</span> isTypenameSelection(sel) &amp;&amp; sel.concreteType ? makeProp(schema, _objectSpread(_objectSpread({}, sel), {}, {
        <span class="hljs-attr">conditional</span>: <span class="hljs-literal">false</span>
      }), state, unmasked, sel.concreteType) : makeProp(schema, sel, state, unmasked);
    });
    types.push(selectionMapValues);
  }

  <span class="hljs-keyword">return</span> unionTypeAnnotation(types.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">props</span>) </span>{
    <span class="hljs-keyword">if</span> (fragmentTypeName) {
      props.push(readOnlyObjectTypeProperty(<span class="hljs-string">'$refType'</span>, t.genericTypeAnnotation(t.identifier(fragmentTypeName))));
    }

    <span class="hljs-keyword">return</span> unmasked ? inexactObjectTypeAnnotation(props) : exactObjectTypeAnnotation(props);
  }));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSelection</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">var</span> shouldSetConditional = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>] : <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">if</span> (!a) {
    <span class="hljs-keyword">if</span> (shouldSetConditional) {
      <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, b), {}, {
        <span class="hljs-attr">conditional</span>: <span class="hljs-literal">true</span>
      });
    }

    <span class="hljs-keyword">return</span> b;
  }

  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, a), {}, {
    <span class="hljs-attr">nodeSelections</span>: a.nodeSelections ? mergeSelections(a.nodeSelections, nullthrows(b.nodeSelections), shouldSetConditional) : <span class="hljs-literal">null</span>,
    <span class="hljs-attr">conditional</span>: a.conditional &amp;&amp; b.conditional
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSelections</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">var</span> shouldSetConditional = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>] : <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">var</span> merged = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(a.entries()),
      _step;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
      <span class="hljs-keyword">var</span> _step$value = _step.value,
          key = _step$value[<span class="hljs-number">0</span>],
          value = _step$value[<span class="hljs-number">1</span>];
      merged.set(key, value);
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator.f();
  }

  <span class="hljs-keyword">var</span> _iterator2 = _createForOfIteratorHelper(b.entries()),
      _step2;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      <span class="hljs-keyword">var</span> _step2$value = _step2.value,
          _key = _step2$value[<span class="hljs-number">0</span>],
          _value = _step2$value[<span class="hljs-number">1</span>];
      merged.set(_key, mergeSelection(a.get(_key), _value, shouldSetConditional));
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator2.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator2.f();
  }

  <span class="hljs-keyword">return</span> merged;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPlural</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Boolean</span>(node.metadata &amp;&amp; node.metadata.plural);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createVisitor</span>(<span class="hljs-params">schema, options</span>) </span>{
  <span class="hljs-keyword">var</span> state = {
    <span class="hljs-attr">customScalars</span>: options.customScalars,
    <span class="hljs-attr">enumsHasteModule</span>: options.enumsHasteModule,
    <span class="hljs-attr">generatedFragments</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),
    <span class="hljs-attr">generatedInputObjectTypes</span>: {},
    <span class="hljs-attr">optionalInputFields</span>: options.optionalInputFields,
    <span class="hljs-attr">usedEnums</span>: {},
    <span class="hljs-attr">usedFragments</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(),
    <span class="hljs-attr">useHaste</span>: options.useHaste,
    <span class="hljs-attr">useSingleArtifactDirectory</span>: options.useSingleArtifactDirectory,
    <span class="hljs-attr">noFutureProofEnums</span>: options.noFutureProofEnums,
    <span class="hljs-attr">matchFields</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(),
    <span class="hljs-attr">runtimeImports</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
  };
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">leave</span>: {
      <span class="hljs-attr">Root</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Root</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> _node$metadata;

        <span class="hljs-keyword">var</span> inputVariablesType = generateInputVariablesType(schema, node, state);
        <span class="hljs-keyword">var</span> inputObjectTypes = generateInputObjectTypes(state);
        <span class="hljs-keyword">var</span> responseTypeDefinition = selectionsToBabel(schema,
        <span class="hljs-comment">/* $FlowFixMe: selections have already been transformed */</span>
        node.selections, state, <span class="hljs-literal">false</span>);

        <span class="hljs-keyword">if</span> (((_node$metadata = node.metadata) === <span class="hljs-literal">null</span> || _node$metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$metadata.childrenCanBubbleNull) === <span class="hljs-literal">true</span>) {
          responseTypeDefinition = t.nullableTypeAnnotation(responseTypeDefinition);
        }

        <span class="hljs-keyword">var</span> responseType = exportType(<span class="hljs-string">""</span>.concat(node.name, <span class="hljs-string">"Response"</span>), responseTypeDefinition);
        <span class="hljs-keyword">var</span> operationTypes = [t.objectTypeProperty(t.identifier(<span class="hljs-string">'variables'</span>), t.genericTypeAnnotation(t.identifier(<span class="hljs-string">""</span>.concat(node.name, <span class="hljs-string">"Variables"</span>)))), t.objectTypeProperty(t.identifier(<span class="hljs-string">'response'</span>), t.genericTypeAnnotation(t.identifier(<span class="hljs-string">""</span>.concat(node.name, <span class="hljs-string">"Response"</span>))))]; <span class="hljs-comment">// Generate raw response type</span>

        <span class="hljs-keyword">var</span> rawResponseType;
        <span class="hljs-keyword">var</span> normalizationIR = options.normalizationIR;

        <span class="hljs-keyword">if</span> (normalizationIR &amp;&amp; node.directives.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) </span>{
          <span class="hljs-keyword">return</span> d.name === DIRECTIVE_NAME;
        })) {
          rawResponseType = IRVisitor.visit(normalizationIR, createRawResponseTypeVisitor(schema, state));
        }

        <span class="hljs-keyword">var</span> refetchableFragmentName = getRefetchableQueryParentFragmentName(state, node.metadata);

        <span class="hljs-keyword">if</span> (refetchableFragmentName != <span class="hljs-literal">null</span>) {
          state.runtimeImports.add(<span class="hljs-string">'FragmentReference'</span>);
        }

        <span class="hljs-keyword">var</span> babelNodes = [];

        <span class="hljs-keyword">if</span> (state.runtimeImports.size) {
          babelNodes.push(importTypes(<span class="hljs-built_in">Array</span>.from(state.runtimeImports).sort(), <span class="hljs-string">'relay-runtime'</span>));
        }

        babelNodes.push.apply(babelNodes, (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(refetchableFragmentName ? generateFragmentRefsForRefetchable(refetchableFragmentName) : getFragmentImports(state)).concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(getEnumDefinitions(schema, state)), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(inputObjectTypes), [inputVariablesType, responseType]));

        <span class="hljs-keyword">if</span> (rawResponseType) {
          <span class="hljs-keyword">var</span> _iterator3 = _createForOfIteratorHelper(state.matchFields),
              _step3;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">for</span> (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              <span class="hljs-keyword">var</span> _step3$value = _step3.value,
                  key = _step3$value[<span class="hljs-number">0</span>],
                  ast = _step3$value[<span class="hljs-number">1</span>];
              babelNodes.push(exportType(key, ast));
            }
          } <span class="hljs-keyword">catch</span> (err) {
            _iterator3.e(err);
          } <span class="hljs-keyword">finally</span> {
            _iterator3.f();
          }

          operationTypes.push(t.objectTypeProperty(t.identifier(<span class="hljs-string">'rawResponse'</span>), t.genericTypeAnnotation(t.identifier(<span class="hljs-string">""</span>.concat(node.name, <span class="hljs-string">"RawResponse"</span>)))));
          babelNodes.push(rawResponseType);
        }

        babelNodes.push(exportType(node.name, exactObjectTypeAnnotation(operationTypes)));
        <span class="hljs-keyword">return</span> t.program(babelNodes);
      },
      <span class="hljs-attr">Fragment</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fragment</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> _node$metadata2;

        <span class="hljs-keyword">var</span> selections = flattenArray( <span class="hljs-comment">// $FlowFixMe[incompatible-cast] : selections have already been transformed</span>
        node.selections);
        <span class="hljs-keyword">var</span> numConecreteSelections = selections.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
          <span class="hljs-keyword">return</span> s.concreteType;
        }).length;
        selections = selections.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
          <span class="hljs-keyword">if</span> (numConecreteSelections &lt;= <span class="hljs-number">1</span> &amp;&amp; isTypenameSelection(selection) &amp;&amp; !schema.isAbstractType(node.type)) {
            <span class="hljs-keyword">return</span> [_objectSpread(_objectSpread({}, selection), {}, {
              <span class="hljs-attr">concreteType</span>: schema.getTypeString(node.type)
            })];
          }

          <span class="hljs-keyword">return</span> [selection];
        });
        state.generatedFragments.add(node.name);
        <span class="hljs-keyword">var</span> fragmentTypes = getFragmentTypes(node.name, getRefetchableQueryPath(state, node.directives));
        <span class="hljs-keyword">var</span> refTypeName = getRefTypeName(node.name);
        <span class="hljs-keyword">var</span> refTypeDataProperty = readOnlyObjectTypeProperty(<span class="hljs-string">'$data'</span>, t.genericTypeAnnotation(t.identifier(<span class="hljs-string">""</span>.concat(node.name, <span class="hljs-string">"$data"</span>))));
        refTypeDataProperty.optional = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">var</span> refTypeFragmentRefProperty = readOnlyObjectTypeProperty(<span class="hljs-string">'$fragmentRefs'</span>, t.genericTypeAnnotation(t.identifier(getOldFragmentTypeName(node.name))));
        <span class="hljs-keyword">var</span> isPluralFragment = isPlural(node);
        <span class="hljs-keyword">var</span> refType = inexactObjectTypeAnnotation([refTypeDataProperty, refTypeFragmentRefProperty]);
        <span class="hljs-keyword">var</span> dataTypeName = getDataTypeName(node.name);
        <span class="hljs-keyword">var</span> dataType = t.genericTypeAnnotation(t.identifier(node.name));
        <span class="hljs-keyword">var</span> unmasked = node.metadata != <span class="hljs-literal">null</span> &amp;&amp; node.metadata.mask === <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">var</span> baseType = selectionsToBabel(schema, selections, state, unmasked, unmasked ? <span class="hljs-literal">undefined</span> : getOldFragmentTypeName(node.name));
        <span class="hljs-keyword">var</span> type = isPluralFragment ? readOnlyArrayOfType(baseType) : baseType;

        <span class="hljs-keyword">if</span> (((_node$metadata2 = node.metadata) === <span class="hljs-literal">null</span> || _node$metadata2 === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$metadata2.childrenCanBubbleNull) === <span class="hljs-literal">true</span>) {
          type = t.nullableTypeAnnotation(type);
        }

        state.runtimeImports.add(<span class="hljs-string">'FragmentReference'</span>);
        <span class="hljs-keyword">return</span> t.program([].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(getFragmentImports(state)), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(getEnumDefinitions(schema, state)), [importTypes(<span class="hljs-built_in">Array</span>.from(state.runtimeImports).sort(), <span class="hljs-string">'relay-runtime'</span>)], (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(fragmentTypes), [exportType(node.name, type), exportType(dataTypeName, dataType), exportType(refTypeName, isPluralFragment ? readOnlyArrayOfType(refType) : refType)]));
      },
      <span class="hljs-attr">InlineFragment</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InlineFragment</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> flattenArray( <span class="hljs-comment">// $FlowFixMe[incompatible-cast] : selections have already been transformed</span>
        node.selections).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">typeSelection</span>) </span>{
          <span class="hljs-keyword">return</span> schema.isAbstractType(node.typeCondition) ? _objectSpread(_objectSpread({}, typeSelection), {}, {
            <span class="hljs-attr">conditional</span>: <span class="hljs-literal">true</span>
          }) : _objectSpread(_objectSpread({}, typeSelection), {}, {
            <span class="hljs-attr">concreteType</span>: schema.getTypeString(node.typeCondition)
          });
        });
      },
      <span class="hljs-attr">Condition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Condition</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> flattenArray( <span class="hljs-comment">// $FlowFixMe[incompatible-cast] : selections have already been transformed</span>
        node.selections).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
          <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, selection), {}, {
            <span class="hljs-attr">conditional</span>: <span class="hljs-literal">true</span>
          });
        });
      },
      <span class="hljs-attr">ScalarField</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ScalarField</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> visitScalarField(schema, node, state);
      },
      <span class="hljs-attr">LinkedField</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LinkedField</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> visitLinkedField(schema, node);
      },
      <span class="hljs-attr">ModuleImport</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ModuleImport</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> [{
          <span class="hljs-attr">key</span>: <span class="hljs-string">'__fragmentPropName'</span>,
          <span class="hljs-attr">conditional</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">value</span>: transformScalarType(schema, schema.expectStringType(), state)
        }, {
          <span class="hljs-attr">key</span>: <span class="hljs-string">'__module_component'</span>,
          <span class="hljs-attr">conditional</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">value</span>: transformScalarType(schema, schema.expectStringType(), state)
        }, {
          <span class="hljs-attr">key</span>: <span class="hljs-string">'__fragments_'</span> + node.name,
          <span class="hljs-attr">ref</span>: node.name
        }];
      },
      <span class="hljs-attr">FragmentSpread</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FragmentSpread</span>(<span class="hljs-params">node</span>) </span>{
        state.usedFragments.add(node.name);
        <span class="hljs-keyword">return</span> [{
          <span class="hljs-attr">key</span>: <span class="hljs-string">'__fragments_'</span> + node.name,
          <span class="hljs-attr">ref</span>: node.name
        }];
      }
    }
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitNodeWithSelectionsOnly</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">return</span> flattenArray( <span class="hljs-comment">// $FlowFixMe[incompatible-cast] : selections have already been transformed</span>
  node.selections);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitScalarField</span>(<span class="hljs-params">schema, node, state</span>) </span>{
  <span class="hljs-keyword">var</span> _node$metadata3;

  <span class="hljs-keyword">var</span> requiredMetadata = (_node$metadata3 = node.metadata) === <span class="hljs-literal">null</span> || _node$metadata3 === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$metadata3.required;
  <span class="hljs-keyword">var</span> nodeType = requiredMetadata != <span class="hljs-literal">null</span> ? schema.getNonNullType(node.type) : node.type;
  <span class="hljs-keyword">return</span> [{
    <span class="hljs-attr">key</span>: node.alias,
    <span class="hljs-attr">schemaName</span>: node.name,
    <span class="hljs-attr">value</span>: transformScalarType(schema, nodeType, state)
  }];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLinkedFieldNodeType</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">var</span> _node$metadata4, _node$metadata5;

  <span class="hljs-keyword">var</span> requiredMetadata = (_node$metadata4 = node.metadata) === <span class="hljs-literal">null</span> || _node$metadata4 === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$metadata4.required;

  <span class="hljs-keyword">if</span> (requiredMetadata != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> schema.getNonNullType(node.type);
  }

  <span class="hljs-keyword">if</span> (((_node$metadata5 = node.metadata) === <span class="hljs-literal">null</span> || _node$metadata5 === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$metadata5.childrenCanBubbleNull) === <span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">if</span> (schema.isList(node.type)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-165" id="section-165"></a>
</div>
<p>In a plural field, nulls bubble up to the item, resulting in a list of nullable items.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> schema.mapListItemType(node.type, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inner</span>) </span>{
        <span class="hljs-keyword">return</span> schema.getNullableType(inner);
      });
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isNonNull(node.type)) {
      <span class="hljs-keyword">var</span> nullable = schema.getNullableType(node.type);

      <span class="hljs-keyword">if</span> (schema.isList(nullable)) {
        <span class="hljs-keyword">return</span> schema.getNonNullType(schema.mapListItemType(nullable, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inner</span>) </span>{
          <span class="hljs-keyword">return</span> schema.getNullableType(inner);
        }));
      }

      <span class="hljs-keyword">return</span> nullable;
    }

    <span class="hljs-keyword">return</span> node.type;
  }

  <span class="hljs-keyword">return</span> node.type;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitLinkedField</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">return</span> [{
    <span class="hljs-attr">key</span>: node.alias,
    <span class="hljs-attr">schemaName</span>: node.name,
    <span class="hljs-attr">nodeType</span>: getLinkedFieldNodeType(schema, node),
    <span class="hljs-attr">nodeSelections</span>: selectionsToMap(flattenArray( <span class="hljs-comment">// $FlowFixMe[incompatible-cast] : selections have already been transformed</span>
    node.selections),
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-166" id="section-166"></a>
</div>
<div class="dox">
<div class="summary">
<p>append concreteType to key so overlapping fields with different
concreteTypes don't get overwritten by each other</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-literal">true</span>)
  }];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeRawResponseProp</span>(<span class="hljs-params">schema, _ref2, state, concreteType</span>) </span>{
  <span class="hljs-keyword">var</span> key = _ref2.key,
      schemaName = _ref2.schemaName,
      value = _ref2.value,
      conditional = _ref2.conditional,
      nodeType = _ref2.nodeType,
      nodeSelections = _ref2.nodeSelections,
      kind = _ref2.kind;

  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'ModuleImport'</span>) {
    <span class="hljs-keyword">return</span> t.objectTypeSpreadProperty(t.genericTypeAnnotation(t.identifier(key)));
  }

  <span class="hljs-keyword">if</span> (schemaName === <span class="hljs-string">'__typename'</span> &amp;&amp; concreteType) {
    value = t.stringLiteralTypeAnnotation(concreteType);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeType) {
    value = transformScalarType(schema, nodeType, state, selectionsToRawResponseBabel(schema, [<span class="hljs-built_in">Array</span>.from(nullthrows(nodeSelections).values())], state, schema.isAbstractType(nodeType) || schema.isWrapper(nodeType) ? <span class="hljs-literal">null</span> : schema.getTypeString(nodeType)));
  }

  <span class="hljs-keyword">var</span> typeProperty = readOnlyObjectTypeProperty(key, value);

  <span class="hljs-keyword">if</span> (conditional) {
    typeProperty.optional = <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">return</span> typeProperty;
} <span class="hljs-comment">// Trasform the codegen IR selections into Babel flow types</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionsToRawResponseBabel</span>(<span class="hljs-params">schema, selections, state, nodeTypeName</span>) </span>{
  <span class="hljs-keyword">var</span> baseFields = [];
  <span class="hljs-keyword">var</span> byConcreteType = {};
  flattenArray(selections).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">var</span> concreteType = selection.concreteType;

    <span class="hljs-keyword">if</span> (concreteType) {
      <span class="hljs-keyword">var</span> _byConcreteType$concr2;

      byConcreteType[concreteType] = (_byConcreteType$concr2 = byConcreteType[concreteType]) !== <span class="hljs-literal">null</span> &amp;&amp; _byConcreteType$concr2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _byConcreteType$concr2 : [];
      byConcreteType[concreteType].push(selection);
    } <span class="hljs-keyword">else</span> {
      baseFields.push(selection);
    }
  });
  <span class="hljs-keyword">var</span> types = [];

  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(byConcreteType).length) {
    <span class="hljs-keyword">var</span> baseFieldsMap = selectionsToMap(baseFields);

    <span class="hljs-keyword">var</span> _loop2 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_loop2</span>(<span class="hljs-params">concreteType</span>) </span>{
      <span class="hljs-keyword">var</span> mergedSeletions = <span class="hljs-built_in">Array</span>.from(mergeSelections(baseFieldsMap, selectionsToMap(byConcreteType[concreteType]), <span class="hljs-literal">false</span>).values());
      types.push(exactObjectTypeAnnotation(mergedSeletions.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
        <span class="hljs-keyword">return</span> makeRawResponseProp(schema, selection, state, concreteType);
      })));
      appendLocal3DPayload(types, mergedSeletions, schema, state, concreteType);
    };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> concreteType <span class="hljs-keyword">in</span> byConcreteType) {
      _loop2(concreteType);
    }
  }

  <span class="hljs-keyword">if</span> (baseFields.length &gt; <span class="hljs-number">0</span>) {
    types.push(exactObjectTypeAnnotation(baseFields.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
      <span class="hljs-keyword">return</span> makeRawResponseProp(schema, selection, state, nodeTypeName);
    })));
    appendLocal3DPayload(types, baseFields, schema, state, nodeTypeName);
  }

  <span class="hljs-keyword">return</span> unionTypeAnnotation(types);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendLocal3DPayload</span>(<span class="hljs-params">types, selections, schema, state, currentType</span>) </span>{
  <span class="hljs-keyword">var</span> moduleImport = selections.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sel</span>) </span>{
    <span class="hljs-keyword">return</span> sel.kind === <span class="hljs-string">'ModuleImport'</span>;
  });

  <span class="hljs-keyword">if</span> (moduleImport) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-167" id="section-167"></a>
</div>
<p>Generate an extra opaque type for client 3D fields</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    state.runtimeImports.add(<span class="hljs-string">'Local3DPayload'</span>);
    types.push(t.genericTypeAnnotation(t.identifier(<span class="hljs-string">'Local3DPayload'</span>), t.typeParameterInstantiation([t.stringLiteralTypeAnnotation(nullthrows(moduleImport.documentName)), exactObjectTypeAnnotation(selections.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sel</span>) </span>{
      <span class="hljs-keyword">return</span> sel.schemaName !== <span class="hljs-string">'js'</span>;
    }).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
      <span class="hljs-keyword">return</span> makeRawResponseProp(schema, selection, state, currentType);
    }))])));
  }
} <span class="hljs-comment">// Visitor for generating raw response type</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRawResponseTypeVisitor</span>(<span class="hljs-params">schema, state</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">leave</span>: {
      <span class="hljs-attr">Root</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Root</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> exportType(<span class="hljs-string">""</span>.concat(node.name, <span class="hljs-string">"RawResponse"</span>), selectionsToRawResponseBabel(schema, <span class="hljs-comment">// $FlowFixMe[incompatible-cast] : selections have already been transformed</span>
        node.selections, state, <span class="hljs-literal">null</span>));
      },
      <span class="hljs-attr">InlineFragment</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InlineFragment</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">var</span> typeCondition = node.typeCondition;
        <span class="hljs-keyword">return</span> flattenArray( <span class="hljs-comment">// $FlowFixMe[incompatible-cast] : selections have already been transformed</span>
        node.selections).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">typeSelection</span>) </span>{
          <span class="hljs-keyword">return</span> schema.isAbstractType(typeCondition) ? typeSelection : _objectSpread(_objectSpread({}, typeSelection), {}, {
            <span class="hljs-attr">concreteType</span>: schema.getTypeString(typeCondition)
          });
        });
      },
      <span class="hljs-attr">ScalarField</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ScalarField</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> visitScalarField(schema, node, state);
      },
      <span class="hljs-attr">ClientExtension</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ClientExtension</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> flattenArray( <span class="hljs-comment">// $FlowFixMe[incompatible-cast] : selections have already been transformed</span>
        node.selections).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sel</span>) </span>{
          <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, sel), {}, {
            <span class="hljs-attr">conditional</span>: <span class="hljs-literal">true</span>
          });
        });
      },
      <span class="hljs-attr">LinkedField</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LinkedField</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> visitLinkedField(schema, node);
      },
      <span class="hljs-attr">Condition</span>: visitNodeWithSelectionsOnly,
      <span class="hljs-attr">Defer</span>: visitNodeWithSelectionsOnly,
      <span class="hljs-attr">Stream</span>: visitNodeWithSelectionsOnly,
      <span class="hljs-attr">ModuleImport</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ModuleImport</span>(<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> visitRawResposneModuleImport(schema, node, state);
      },
      <span class="hljs-attr">FragmentSpread</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FragmentSpread</span>(<span class="hljs-params">node</span>) </span>{
         <span class="hljs-literal">true</span> ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'A fragment spread is found when traversing the AST, '</span> + <span class="hljs-string">'make sure you are passing the codegen IR'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-literal">undefined</span>;
      }
    }
  };
} <span class="hljs-comment">// Dedupe the generated type of module selections to reduce file size</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitRawResposneModuleImport</span>(<span class="hljs-params">schema, node, state</span>) </span>{
  <span class="hljs-keyword">var</span> selections = node.selections,
      key = node.name;
  <span class="hljs-keyword">var</span> moduleSelections = selections.filter( <span class="hljs-comment">// $FlowFixMe[prop-missing] selections have already been transformed</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sel</span>) </span>{
    <span class="hljs-keyword">return</span> sel.length &amp;&amp; sel[<span class="hljs-number">0</span>].schemaName === <span class="hljs-string">'js'</span>;
  }).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>{
    <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];
  });

  <span class="hljs-keyword">if</span> (!state.matchFields.has(key)) {
    <span class="hljs-keyword">var</span> ast = selectionsToRawResponseBabel(schema, <span class="hljs-comment">// $FlowFixMe[incompatible-cast] : selections have already been transformed</span>
    node.selections.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sel</span>) </span>{
      <span class="hljs-keyword">return</span> sel.length &gt; <span class="hljs-number">1</span> || sel[<span class="hljs-number">0</span>].schemaName !== <span class="hljs-string">'js'</span>;
    }), state, <span class="hljs-literal">null</span>);
    state.matchFields.set(key, ast);
  }

  <span class="hljs-keyword">return</span> [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(moduleSelections), [{
    <span class="hljs-attr">key</span>: key,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'ModuleImport'</span>,
    <span class="hljs-attr">documentName</span>: node.key
  }]);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionsToMap</span>(<span class="hljs-params">selections, appendType</span>) </span>{
  <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  selections.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">var</span> key = appendType &amp;&amp; selection.concreteType ? <span class="hljs-string">""</span>.concat(selection.key, <span class="hljs-string">"::"</span>).concat(selection.concreteType) : selection.key;
    <span class="hljs-keyword">var</span> previousSel = map.get(key);
    map.set(key, previousSel ? mergeSelection(previousSel, selection) : selection);
  });
  <span class="hljs-keyword">return</span> map;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flattenArray</span>(<span class="hljs-params">arrayOfArrays</span>) </span>{
  <span class="hljs-keyword">var</span> result = [];
  arrayOfArrays.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">array</span>) </span>{
    result.push.apply(result, (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(array));
  });
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateInputObjectTypes</span>(<span class="hljs-params">state</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(state.generatedInputObjectTypes).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">typeIdentifier</span>) </span>{
    <span class="hljs-keyword">var</span> inputObjectType = state.generatedInputObjectTypes[typeIdentifier];
    !(<span class="hljs-keyword">typeof</span> inputObjectType !== <span class="hljs-string">'string'</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayCompilerFlowGenerator: Expected input object type to have been'</span> + <span class="hljs-string">' defined before calling `generateInputObjectTypes`'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> exportType(typeIdentifier, inputObjectType);
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateInputVariablesType</span>(<span class="hljs-params">schema, node, state</span>) </span>{
  <span class="hljs-keyword">return</span> exportType(<span class="hljs-string">""</span>.concat(node.name, <span class="hljs-string">"Variables"</span>), exactObjectTypeAnnotation(node.argumentDefinitions.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">var</span> property = t.objectTypeProperty(t.identifier(arg.name), transformInputType(schema, arg.type, state));

    <span class="hljs-keyword">if</span> (!schema.isNonNull(arg.type)) {
      property.optional = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> property;
  })));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">groupRefs</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">var</span> result = [];
  <span class="hljs-keyword">var</span> refs = [];
  props.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prop</span>) </span>{
    <span class="hljs-keyword">if</span> (prop.ref) {
      refs.push(prop.ref);
    } <span class="hljs-keyword">else</span> {
      result.push(prop);
    }
  });

  <span class="hljs-keyword">if</span> (refs.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">var</span> value = intersectionTypeAnnotation(refs.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ref</span>) </span>{
      <span class="hljs-keyword">return</span> t.genericTypeAnnotation(t.identifier(getOldFragmentTypeName(ref)));
    }));
    result.push({
      <span class="hljs-attr">key</span>: <span class="hljs-string">'$fragmentRefs'</span>,
      <span class="hljs-attr">conditional</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">value</span>: value
    });
  }

  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFragmentImports</span>(<span class="hljs-params">state</span>) </span>{
  <span class="hljs-keyword">var</span> imports = [];

  <span class="hljs-keyword">if</span> (state.usedFragments.size &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">var</span> usedFragments = <span class="hljs-built_in">Array</span>.from(state.usedFragments).sort();

    <span class="hljs-keyword">var</span> _iterator4 = _createForOfIteratorHelper(usedFragments),
        _step4;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">for</span> (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        <span class="hljs-keyword">var</span> usedFragment = _step4.value;
        <span class="hljs-keyword">var</span> fragmentTypeName = getOldFragmentTypeName(usedFragment);

        <span class="hljs-keyword">if</span> (!state.generatedFragments.has(usedFragment)) {
          <span class="hljs-keyword">if</span> (state.useHaste) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-168" id="section-168"></a>
</div>
<p>TODO(T22653277) support non-haste environments when importing
fragments</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            imports.push(importTypes([fragmentTypeName], usedFragment + <span class="hljs-string">'.graphql'</span>));
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.useSingleArtifactDirectory) {
            imports.push(importTypes([fragmentTypeName], <span class="hljs-string">'./'</span> + usedFragment + <span class="hljs-string">'.graphql'</span>));
          } <span class="hljs-keyword">else</span> {
            imports.push(anyTypeAlias(fragmentTypeName));
          }
        }
      }
    } <span class="hljs-keyword">catch</span> (err) {
      _iterator4.e(err);
    } <span class="hljs-keyword">finally</span> {
      _iterator4.f();
    }
  }

  <span class="hljs-keyword">return</span> imports;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEnumDefinitions</span>(<span class="hljs-params">schema, _ref3</span>) </span>{
  <span class="hljs-keyword">var</span> enumsHasteModule = _ref3.enumsHasteModule,
      usedEnums = _ref3.usedEnums,
      noFutureProofEnums = _ref3.noFutureProofEnums;
  <span class="hljs-keyword">var</span> enumNames = <span class="hljs-built_in">Object</span>.keys(usedEnums).sort();

  <span class="hljs-keyword">if</span> (enumNames.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> [];
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> enumsHasteModule === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">return</span> [importTypes(enumNames, enumsHasteModule)];
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> enumsHasteModule === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">return</span> enumNames.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">enumName</span>) </span>{
      <span class="hljs-keyword">return</span> importTypes([enumName], enumsHasteModule(enumName));
    });
  }

  <span class="hljs-keyword">return</span> enumNames.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">var</span> values = [].concat(schema.getEnumValues(usedEnums[name]));
    values.sort();

    <span class="hljs-keyword">if</span> (!noFutureProofEnums) {
      values.push(<span class="hljs-string">'%future added value'</span>);
    }

    <span class="hljs-keyword">return</span> exportType(name, t.unionTypeAnnotation(values.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> t.stringLiteralTypeAnnotation(value);
    })));
  });
} <span class="hljs-comment">// If it's a @refetchable fragment, we generate the $fragmentRef in generated</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-169" id="section-169"></a>
</div>
<p>query, and import it in the fragment to avoid circular dependencies</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRefetchableQueryParentFragmentName</span>(<span class="hljs-params">state, metadata</span>) </span>{
  <span class="hljs-keyword">if</span> (!(metadata === <span class="hljs-literal">null</span> || metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : metadata.isRefetchableQuery) || !state.useHaste &amp;&amp; !state.useSingleArtifactDirectory) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> derivedFrom = metadata === <span class="hljs-literal">null</span> || metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : metadata.derivedFrom;

  <span class="hljs-keyword">if</span> (derivedFrom != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> derivedFrom === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">return</span> derivedFrom;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRefetchableQueryPath</span>(<span class="hljs-params">state, directives</span>) </span>{
  <span class="hljs-keyword">var</span> _directives$find;

  <span class="hljs-keyword">var</span> refetchableQuery;

  <span class="hljs-keyword">if</span> (!state.useHaste &amp;&amp; !state.useSingleArtifactDirectory) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">var</span> refetchableArgs = (_directives$find = directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">d</span>) </span>{
    <span class="hljs-keyword">return</span> d.name === <span class="hljs-string">'refetchable'</span>;
  })) === <span class="hljs-literal">null</span> || _directives$find === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _directives$find.args;

  <span class="hljs-keyword">if</span> (!refetchableArgs) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">var</span> argument = refetchableArgs.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.kind === <span class="hljs-string">'Argument'</span> &amp;&amp; arg.name === <span class="hljs-string">'queryName'</span>;
  });

  <span class="hljs-keyword">if</span> (argument &amp;&amp; argument.value &amp;&amp; argument.value.kind === <span class="hljs-string">'Literal'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> argument.value.value === <span class="hljs-string">'string'</span>) {
    refetchableQuery = argument.value.value;

    <span class="hljs-keyword">if</span> (!state.useHaste) {
      refetchableQuery = <span class="hljs-string">'./'</span> + refetchableQuery;
    }

    refetchableQuery += <span class="hljs-string">'.graphql'</span>;
  }

  <span class="hljs-keyword">return</span> refetchableQuery;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateFragmentRefsForRefetchable</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">var</span> oldFragmentTypeName = getOldFragmentTypeName(name);
  <span class="hljs-keyword">var</span> newFragmentTypeName = getNewFragmentTypeName(name);
  <span class="hljs-keyword">return</span> [declareExportOpaqueType(oldFragmentTypeName, <span class="hljs-string">'FragmentReference'</span>), declareExportOpaqueType(newFragmentTypeName, oldFragmentTypeName)];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFragmentTypes</span>(<span class="hljs-params">name, refetchableQueryPath</span>) </span>{
  <span class="hljs-keyword">var</span> oldFragmentTypeName = getOldFragmentTypeName(name);
  <span class="hljs-keyword">var</span> newFragmentTypeName = getNewFragmentTypeName(name);

  <span class="hljs-keyword">if</span> (refetchableQueryPath) {
    <span class="hljs-keyword">return</span> [importTypes([oldFragmentTypeName, newFragmentTypeName], refetchableQueryPath), exportTypes([oldFragmentTypeName, newFragmentTypeName])];
  }

  <span class="hljs-keyword">return</span> [declareExportOpaqueType(oldFragmentTypeName, <span class="hljs-string">'FragmentReference'</span>), declareExportOpaqueType(newFragmentTypeName, oldFragmentTypeName)];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOldFragmentTypeName</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.concat(name, <span class="hljs-string">"$ref"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNewFragmentTypeName</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.concat(name, <span class="hljs-string">"$fragmentType"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRefTypeName</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.concat(name, <span class="hljs-string">"$key"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDataTypeName</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.concat(name, <span class="hljs-string">"$data"</span>);
}

<span class="hljs-keyword">var</span> FLOW_TRANSFORMS = [RelayDirectiveTransform.transform, MaskTransform.transform, MatchTransform.transform, RequiredFieldTransform.transform, FlattenTransform.transformWithOptions({}), RefetchableFragmentTransform.transform];
<span class="hljs-keyword">var</span> DIRECTIVE_NAME = <span class="hljs-string">'raw_response_type'</span>;
<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">generate</span>: Profiler.instrument(generate, <span class="hljs-string">'RelayFlowGenerator.generate'</span>),
  <span class="hljs-attr">transforms</span>: FLOW_TRANSFORMS,
  <span class="hljs-attr">SCHEMA_EXTENSION</span>: <span class="hljs-string">"directive @"</span>.concat(DIRECTIVE_NAME, <span class="hljs-string">" on QUERY | MUTATION | SUBSCRIPTION"</span>)
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 47 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-170" id="section-170"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> partitionArray = __webpack_require__(<span class="hljs-number">15</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError,
    createCompilerError = _require.createCompilerError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">10</span>),
    RelayFeatureFlags = _require2.RelayFeatureFlags;

<span class="hljs-keyword">var</span> SCHEMA_EXTENSION = <span class="hljs-string">"\n  enum RequiredFieldAction {\n    NONE\n    LOG\n    THROW\n  }\n  directive @required(\n    action: RequiredFieldAction!\n  ) on FIELD\n"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-171" id="section-171"></a>
</div>
<div class="dox">
<div class="summary">
<p>This transform rewrites ScalarField and LinkedField nodes with a @required
directive into fields with the directives stripped and sets the <code>required</code>
and <code>path</code> metadata values.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requiredFieldTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">LinkedField</span>: visitLinkedField,
    <span class="hljs-attr">ScalarField</span>: vistitScalarField,
    <span class="hljs-attr">InlineFragment</span>: visitInlineFragment,
    <span class="hljs-attr">Fragment</span>: visitFragment,
    <span class="hljs-attr">Root</span>: visitRoot
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">schema</span>: schema,
      <span class="hljs-attr">documentName</span>: node.name,
      <span class="hljs-attr">path</span>: [],
      <span class="hljs-attr">pathRequiredMap</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(),
      <span class="hljs-attr">currentNodeRequiredChildren</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(),
      <span class="hljs-attr">requiredChildrenMap</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(),
      <span class="hljs-attr">parentAbstractInlineFragment</span>: <span class="hljs-literal">null</span>
    };
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragment</span>(<span class="hljs-params">fragment, state</span>) </span>{
  <span class="hljs-keyword">return</span> addChildrenCanBubbleMetadata(<span class="hljs-keyword">this</span>.traverse(fragment, state), state);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitRoot</span>(<span class="hljs-params">root, state</span>) </span>{
  <span class="hljs-keyword">return</span> addChildrenCanBubbleMetadata(<span class="hljs-keyword">this</span>.traverse(root, state), state);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitInlineFragment</span>(<span class="hljs-params">fragment, state</span>) </span>{
  <span class="hljs-keyword">var</span> _state$parentAbstract;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-172" id="section-172"></a>
</div>
<p>Ideally we could allow @required when the direct parent inline fragment was
on a concrete type, but we would need to solve this bug in our Flow type
generation first: T65695438</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> parentAbstractInlineFragment = (_state$parentAbstract = state.parentAbstractInlineFragment) !== <span class="hljs-literal">null</span> &amp;&amp; _state$parentAbstract !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _state$parentAbstract : getAbstractInlineFragment(fragment, state.schema);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(fragment, _objectSpread(_objectSpread({}, state), {}, {
    <span class="hljs-attr">parentAbstractInlineFragment</span>: parentAbstractInlineFragment
  }));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAbstractInlineFragment</span>(<span class="hljs-params">fragment, schema</span>) </span>{
  <span class="hljs-keyword">var</span> typeCondition = fragment.typeCondition;

  <span class="hljs-keyword">if</span> (schema.isAbstractType(typeCondition)) {
    <span class="hljs-keyword">return</span> fragment;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
} <span class="hljs-comment">// Convert action to a number so that we can numerically compare their severity.</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getActionSeverity</span>(<span class="hljs-params">action</span>) </span>{
  <span class="hljs-keyword">switch</span> (action) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'NONE'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'LOG'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'THROW'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;

    <span class="hljs-keyword">default</span>:
      action;
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unhandled action type "</span>.concat(action));
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitLinkedField</span>(<span class="hljs-params">field, state</span>) </span>{
  <span class="hljs-keyword">var</span> path = [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(state.path), [field.alias]);

  <span class="hljs-keyword">var</span> newState = _objectSpread(_objectSpread({}, state), {}, {
    <span class="hljs-attr">currentNodeRequiredChildren</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(),
    <span class="hljs-attr">path</span>: path,
    <span class="hljs-attr">parentAbstractInlineFragment</span>: <span class="hljs-literal">null</span>
  });

  <span class="hljs-keyword">var</span> newField = <span class="hljs-keyword">this</span>.traverse(field, newState);
  <span class="hljs-keyword">var</span> pathName = path.join(<span class="hljs-string">'.'</span>);
  assertCompatibleRequiredChildren(field, pathName, newState);
  newField = applyDirectives(newField, pathName, state.documentName);
  assertCompatibleNullability(newField, pathName, newState.pathRequiredMap);
  <span class="hljs-keyword">var</span> directiveMetadata = getRequiredDirectiveMetadata(newField);

  <span class="hljs-keyword">if</span> (directiveMetadata != <span class="hljs-literal">null</span>) {
    assertParentIsNotInvalidInlineFragmet(state.schema, directiveMetadata, state.parentAbstractInlineFragment);
    state.currentNodeRequiredChildren.set(field.alias, newField);
    <span class="hljs-keyword">var</span> severity = getActionSeverity(directiveMetadata.action); <span class="hljs-comment">// Assert that all @required children have at least this severity.</span>

    newState.currentNodeRequiredChildren.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">childField</span>) </span>{
      <span class="hljs-keyword">var</span> childMetadata = getRequiredDirectiveMetadata(childField);

      <span class="hljs-keyword">if</span> (childMetadata == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (getActionSeverity(childMetadata.action) &lt; severity) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"The @required field [1] may not have an `action` less severe than that of its @required parent [2]. [1] should probably be `action: "</span>.concat(directiveMetadata.action, <span class="hljs-string">"`."</span>), [childMetadata.actionLoc, directiveMetadata.actionLoc]);
      }
    });
  }

  state.requiredChildrenMap.set(pathName, newState.currentNodeRequiredChildren);
  <span class="hljs-keyword">return</span> addChildrenCanBubbleMetadata(newField, newState);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">vistitScalarField</span>(<span class="hljs-params">field, state</span>) </span>{
  <span class="hljs-keyword">var</span> pathName = [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(state.path), [field.alias]).join(<span class="hljs-string">'.'</span>);
  <span class="hljs-keyword">var</span> newField = applyDirectives(field, pathName, state.documentName);
  <span class="hljs-keyword">var</span> directiveMetadata = getRequiredDirectiveMetadata(newField);

  <span class="hljs-keyword">if</span> (directiveMetadata != <span class="hljs-literal">null</span>) {
    assertParentIsNotInvalidInlineFragmet(state.schema, directiveMetadata, state.parentAbstractInlineFragment);
    state.currentNodeRequiredChildren.set(field.alias, newField);
  }

  assertCompatibleNullability(newField, pathName, state.pathRequiredMap);
  <span class="hljs-keyword">return</span> newField;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addChildrenCanBubbleMetadata</span>(<span class="hljs-params">node, state</span>) </span>{
  <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(state.currentNodeRequiredChildren.values()),
      _step;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
      <span class="hljs-keyword">var</span> child = _step.value;
      <span class="hljs-keyword">var</span> requiredMetadata = getRequiredDirectiveMetadata(child);

      <span class="hljs-keyword">if</span> (requiredMetadata != <span class="hljs-literal">null</span> &amp;&amp; requiredMetadata.action !== <span class="hljs-string">'THROW'</span>) {
        <span class="hljs-keyword">var</span> metadata = _objectSpread(_objectSpread({}, node.metadata), {}, {
          <span class="hljs-attr">childrenCanBubbleNull</span>: <span class="hljs-literal">true</span>
        });

        <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, node), {}, {
          <span class="hljs-attr">metadata</span>: metadata
        });
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator.f();
  }

  <span class="hljs-keyword">return</span> node;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertParentIsNotInvalidInlineFragmet</span>(<span class="hljs-params">schema, directiveMetadata, parentAbstractInlineFragment</span>) </span>{
  <span class="hljs-keyword">if</span> (parentAbstractInlineFragment == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">var</span> typeCondition = parentAbstractInlineFragment.typeCondition;

  <span class="hljs-keyword">if</span> (schema.isUnion(typeCondition)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'The @required directive [1] may not be used anywhere within an inline fragment on a union type [2].'</span>, [directiveMetadata.directiveLoc, parentAbstractInlineFragment.loc]);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isInterface(typeCondition)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'The @required directive [1] may not be used anywhere within an inline fragment on an interface type [2].'</span>, [directiveMetadata.directiveLoc, parentAbstractInlineFragment.loc]);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Unexpected abstract inline fragment type.'</span>, [parentAbstractInlineFragment.loc]);
  }
} <span class="hljs-comment">// Check that this field's nullability matches all other instances.</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertCompatibleNullability</span>(<span class="hljs-params">field, pathName, pathRequiredMap</span>) </span>{
  <span class="hljs-keyword">var</span> existingField = pathRequiredMap.get(pathName);

  <span class="hljs-keyword">if</span> (existingField == <span class="hljs-literal">null</span>) {
    pathRequiredMap.set(pathName, field);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">var</span> requiredMetadata = getRequiredDirectiveMetadata(field);
  <span class="hljs-keyword">var</span> existingRequiredMetadata = getRequiredDirectiveMetadata(existingField);

  <span class="hljs-keyword">if</span> ((requiredMetadata === <span class="hljs-literal">null</span> || requiredMetadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : requiredMetadata.action) === (existingRequiredMetadata === <span class="hljs-literal">null</span> || existingRequiredMetadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : existingRequiredMetadata.action)) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">if</span> (requiredMetadata == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"The field \""</span>.concat(field.alias, <span class="hljs-string">"\" is @required in [1] but not in [2]."</span>), [existingField.loc, field.loc]);
  }

  <span class="hljs-keyword">if</span> (existingRequiredMetadata == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"The field \""</span>.concat(field.alias, <span class="hljs-string">"\" is @required in [1] but not in [2]."</span>), [field.loc, existingField.loc]);
  }

  <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"The field \""</span>.concat(field.alias, <span class="hljs-string">"\" has a different @required action in [1] than in [2]."</span>), [requiredMetadata.actionLoc, existingRequiredMetadata.actionLoc]);
} <span class="hljs-comment">// Metadata is untyped, so we use this utility function to do the type coersion.</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRequiredDirectiveMetadata</span>(<span class="hljs-params">field</span>) </span>{
  <span class="hljs-keyword">var</span> _field$metadata;

  <span class="hljs-keyword">return</span> (_field$metadata = field.metadata) === <span class="hljs-literal">null</span> || _field$metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _field$metadata.required;
} <span class="hljs-comment">// Check that this field has the same required children as all other instances.</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertCompatibleRequiredChildren</span>(<span class="hljs-params">field, fieldPath, _ref</span>) </span>{
  <span class="hljs-keyword">var</span> currentNodeRequiredChildren = _ref.currentNodeRequiredChildren,
      pathRequiredMap = _ref.pathRequiredMap,
      requiredChildrenMap = _ref.requiredChildrenMap;
  <span class="hljs-keyword">var</span> previouslyRequiredChildren = requiredChildrenMap.get(fieldPath);

  <span class="hljs-keyword">if</span> (previouslyRequiredChildren == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  } <span class="hljs-comment">// Check if this field has a required child field which was previously omitted.</span>


  <span class="hljs-keyword">var</span> _iterator2 = _createForOfIteratorHelper(currentNodeRequiredChildren),
      _step2;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      <span class="hljs-keyword">var</span> _step2$value = _step2.value,
          path = _step2$value[<span class="hljs-number">0</span>],
          childField = _step2$value[<span class="hljs-number">1</span>];

      <span class="hljs-keyword">if</span> (!previouslyRequiredChildren.has(path)) {
        <span class="hljs-keyword">var</span> otherParent = pathRequiredMap.get(fieldPath);

        <span class="hljs-keyword">if</span> (otherParent == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Could not find other parent node at path \""</span>.concat(fieldPath, <span class="hljs-string">"\"."</span>), [childField.loc]);
        }

        <span class="hljs-keyword">throw</span> createMissingRequiredFieldError(childField, otherParent);
      }
    } <span class="hljs-comment">// Check if a previous reference to this field had a required child field which we are missing.</span>

  } <span class="hljs-keyword">catch</span> (err) {
    _iterator2.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator2.f();
  }

  <span class="hljs-keyword">var</span> _iterator3 = _createForOfIteratorHelper(previouslyRequiredChildren),
      _step3;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      <span class="hljs-keyword">var</span> _step3$value = _step3.value,
          _path = _step3$value[<span class="hljs-number">0</span>],
          _childField = _step3$value[<span class="hljs-number">1</span>];

      <span class="hljs-keyword">if</span> (!currentNodeRequiredChildren.has(_path)) {
        <span class="hljs-keyword">throw</span> createMissingRequiredFieldError(_childField, field);
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator3.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator3.f();
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createMissingRequiredFieldError</span>(<span class="hljs-params">requiredChild, missingParent</span>) </span>{
  <span class="hljs-keyword">var</span> alias = requiredChild.alias;
  <span class="hljs-keyword">return</span> createUserError(<span class="hljs-string">"The field \""</span>.concat(alias, <span class="hljs-string">"\" is marked as @required in [1] but is missing in [2]."</span>), [requiredChild.loc, missingParent.loc]);
} <span class="hljs-comment">// TODO T74397896: Remove prefix gating once @required is rolled out more broadly.</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">featureIsEnabled</span>(<span class="hljs-params">documentName</span>) </span>{
  <span class="hljs-keyword">var</span> featureFlag = RelayFeatureFlags.ENABLE_REQUIRED_DIRECTIVES;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> featureFlag === <span class="hljs-string">'boolean'</span>) {
    <span class="hljs-keyword">return</span> featureFlag;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (featureFlag === <span class="hljs-string">'LIMITED'</span>) {
    <span class="hljs-keyword">return</span> documentName.startsWith(<span class="hljs-string">'RelayRequiredTest'</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> featureFlag === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">return</span> featureFlag.split(<span class="hljs-string">'|'</span>).some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prefix</span>) </span>{
      <span class="hljs-keyword">return</span> documentName.startsWith(prefix);
    });
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
} <span class="hljs-comment">// Strip and validate @required directives, and convert them to metadata.</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyDirectives</span>(<span class="hljs-params">field, pathName, documentName</span>) </span>{
  <span class="hljs-keyword">var</span> _partitionArray = partitionArray(field.directives, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'required'</span>;
  }),
      requiredDirectives = _partitionArray[<span class="hljs-number">0</span>],
      otherDirectives = _partitionArray[<span class="hljs-number">1</span>];

  <span class="hljs-keyword">if</span> (requiredDirectives.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> field;
  }

  <span class="hljs-keyword">if</span> (!featureIsEnabled(documentName)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> createUserError( <span class="hljs-comment">// Purposefully don't include details in this error message, since we</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-173" id="section-173"></a>
</div>
<p>don't want folks adopting this feature until it's been tested more.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-string">'The @required directive is experimental and not yet supported for use in product code'</span>, requiredDirectives.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
      <span class="hljs-keyword">return</span> x.loc;
    }));
  }

  <span class="hljs-keyword">if</span> (requiredDirectives.length &gt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> createUserError(<span class="hljs-string">'Did not expect multiple @required directives.'</span>, requiredDirectives.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
      <span class="hljs-keyword">return</span> x.loc;
    }));
  }

  <span class="hljs-keyword">var</span> requiredDirective = requiredDirectives[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> arg = requiredDirective.args[<span class="hljs-number">0</span>]; <span class="hljs-comment">// I would expect this check to be handled by the schema validation, but...</span>

  <span class="hljs-keyword">if</span> (arg == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'The @required directive requires an `action` argument.'</span>, [requiredDirective.loc]);
  }

  <span class="hljs-keyword">if</span> (arg.value.kind !== <span class="hljs-string">'Literal'</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Expected @required `action` argument to be a literal.'</span>, [arg.value.loc]);
  }

  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, field), {}, {
    <span class="hljs-attr">directives</span>: otherDirectives,
    <span class="hljs-attr">metadata</span>: _objectSpread(_objectSpread({}, field.metadata), {}, {
      <span class="hljs-attr">required</span>: {
        <span class="hljs-attr">action</span>: arg.value.value,
        <span class="hljs-attr">actionLoc</span>: arg.loc,
        <span class="hljs-attr">directiveLoc</span>: requiredDirective.loc,
        <span class="hljs-attr">path</span>: pathName
      }
    })
  });
} <span class="hljs-comment">// Transform @required directive to metadata</span>


<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">SCHEMA_EXTENSION</span>: SCHEMA_EXTENSION,
  <span class="hljs-attr">transform</span>: requiredFieldTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 48 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-174" id="section-174"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> t = __webpack_require__(<span class="hljs-number">25</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-175" id="section-175"></a>
</div>
<div class="dox">
<div class="summary">
<p>type NAME = any;</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anyTypeAlias</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> t.typeAlias(t.identifier(name), <span class="hljs-literal">undefined</span>, t.anyTypeAnnotation());
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-176" id="section-176"></a>
</div>
<div class="dox">
<div class="summary">
<p>{|
PROPS
|}</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exactObjectTypeAnnotation</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">var</span> typeAnnotation = t.objectTypeAnnotation(props);
  typeAnnotation.exact = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> typeAnnotation;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-177" id="section-177"></a>
</div>
<div class="dox">
<div class="summary">
<p>{
PROPS
...
}</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inexactObjectTypeAnnotation</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">var</span> typeAnnotation = t.objectTypeAnnotation(props);
  typeAnnotation.inexact = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> typeAnnotation;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-178" id="section-178"></a>
</div>
<div class="dox">
<div class="summary">
<p>export type NAME = TYPE</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exportType</span>(<span class="hljs-params">name, type</span>) </span>{
  <span class="hljs-keyword">return</span> t.exportNamedDeclaration(t.typeAlias(t.identifier(name), <span class="hljs-literal">undefined</span>, type), [], <span class="hljs-literal">undefined</span>);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-179" id="section-179"></a>
</div>
<div class="dox">
<div class="summary">
<p>export type {A, B, C}</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exportTypes</span>(<span class="hljs-params">names</span>) </span>{
  <span class="hljs-keyword">var</span> res = t.exportNamedDeclaration(<span class="hljs-literal">undefined</span>, names.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> t.exportSpecifier(t.identifier(name), t.identifier(name));
  }), <span class="hljs-literal">undefined</span>);
  res.exportKind = <span class="hljs-string">'type'</span>;
  <span class="hljs-keyword">return</span> res;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-180" id="section-180"></a>
</div>
<div class="dox">
<div class="summary">
<p>declare export type NAME = VALUE</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">declareExportOpaqueType</span>(<span class="hljs-params">name, value</span>) </span>{
  <span class="hljs-keyword">return</span> t.declareExportDeclaration(t.declareOpaqueType(t.identifier(name), <span class="hljs-literal">undefined</span>, t.genericTypeAnnotation(t.identifier(value))));
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-181" id="section-181"></a>
</div>
<div class="dox">
<div class="summary">
<p>import type {NAMES[0], NAMES[1], ...} from 'MODULE';</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">importTypes</span>(<span class="hljs-params">names, module</span>) </span>{
  <span class="hljs-keyword">var</span> importDeclaration = t.importDeclaration(names.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">return</span> t.importSpecifier(t.identifier(name), t.identifier(name));
  }), t.stringLiteral(<span class="hljs-built_in">module</span>));
  importDeclaration.importKind = <span class="hljs-string">'type'</span>;
  <span class="hljs-keyword">return</span> importDeclaration;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-182" id="section-182"></a>
</div>
<div class="dox">
<div class="summary">
<p>Create an intersection type if needed.</p>
</div>
<div class="body">
<p>TYPES[0] &amp; TYPES[1] &amp; ...</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersectionTypeAnnotation</span>(<span class="hljs-params">types</span>) </span>{
  !(types.length &gt; <span class="hljs-number">0</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayFlowBabelFactories: cannot create an intersection of 0 types'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> types.length === <span class="hljs-number">1</span> ? types[<span class="hljs-number">0</span>] : t.intersectionTypeAnnotation(types);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lineComments</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">arguments</span>.length, lines = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(_len), _key = <span class="hljs-number">0</span>; _key &lt; _len; _key++) {
    lines[_key] = <span class="hljs-built_in">arguments</span>[_key];
  }

  <span class="hljs-keyword">return</span> lines.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">line</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'CommentLine'</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-string">' '</span> + line
    };
  });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-183" id="section-183"></a>
</div>
<div class="dox">
<div class="summary">
<p>$ReadOnlyArray<TYPE></p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readOnlyArrayOfType</span>(<span class="hljs-params">thing</span>) </span>{
  <span class="hljs-keyword">return</span> t.genericTypeAnnotation(t.identifier(<span class="hljs-string">'$ReadOnlyArray'</span>), t.typeParameterInstantiation([thing]));
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-184" id="section-184"></a>
</div>
<div class="dox">
<div class="summary">
<p>+KEY: VALUE</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readOnlyObjectTypeProperty</span>(<span class="hljs-params">key, value</span>) </span>{
  <span class="hljs-keyword">var</span> prop = t.objectTypeProperty(t.identifier(key), value);
  prop.variance = t.variance(<span class="hljs-string">'plus'</span>);
  <span class="hljs-keyword">return</span> prop;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringLiteralTypeAnnotation</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-keyword">return</span> t.stringLiteralTypeAnnotation(value);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-185" id="section-185"></a>
</div>
<div class="dox">
<div class="summary">
<p>Create a union type if needed.</p>
</div>
<div class="body">
<p>TYPES[0] | TYPES[1] | ...</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unionTypeAnnotation</span>(<span class="hljs-params">types</span>) </span>{
  !(types.length &gt; <span class="hljs-number">0</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayFlowBabelFactories: cannot create a union of 0 types'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> types.length === <span class="hljs-number">1</span> ? types[<span class="hljs-number">0</span>] : t.unionTypeAnnotation(types);
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">anyTypeAlias</span>: anyTypeAlias,
  <span class="hljs-attr">declareExportOpaqueType</span>: declareExportOpaqueType,
  <span class="hljs-attr">exactObjectTypeAnnotation</span>: exactObjectTypeAnnotation,
  <span class="hljs-attr">inexactObjectTypeAnnotation</span>: inexactObjectTypeAnnotation,
  <span class="hljs-attr">exportType</span>: exportType,
  <span class="hljs-attr">exportTypes</span>: exportTypes,
  <span class="hljs-attr">importTypes</span>: importTypes,
  <span class="hljs-attr">intersectionTypeAnnotation</span>: intersectionTypeAnnotation,
  <span class="hljs-attr">lineComments</span>: lineComments,
  <span class="hljs-attr">readOnlyArrayOfType</span>: readOnlyArrayOfType,
  <span class="hljs-attr">readOnlyObjectTypeProperty</span>: readOnlyObjectTypeProperty,
  <span class="hljs-attr">stringLiteralTypeAnnotation</span>: stringLiteralTypeAnnotation,
  <span class="hljs-attr">unionTypeAnnotation</span>: unionTypeAnnotation
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 49 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"util"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 50 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-186" id="section-186"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _yargs = __webpack_require__(<span class="hljs-number">51</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">52</span>),
    main = _require.main;

<span class="hljs-keyword">var</span> RelayConfig;

<span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-187" id="section-187"></a>
</div>
<p>eslint-disable-next-line no-eval</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  RelayConfig = <span class="hljs-built_in">eval</span>(<span class="hljs-string">'require'</span>)(<span class="hljs-string">'relay-config'</span>); <span class="hljs-comment">// eslint-disable-next-line lint/no-unused-catch-bindings</span>
} <span class="hljs-keyword">catch</span> (_) {}

<span class="hljs-keyword">var</span> options = {
  <span class="hljs-attr">schema</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'Path to schema.graphql or schema.json'</span>,
    <span class="hljs-attr">demandOption</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">array</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">src</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'Root directory of application code'</span>,
    <span class="hljs-attr">demandOption</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">array</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">include</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'Directories to include under src'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">array</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">"default"</span>: [<span class="hljs-string">'**'</span>]
  },
  <span class="hljs-attr">exclude</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'Directories to ignore under src'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">array</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">"default"</span>: [<span class="hljs-string">'**/node_modules/**'</span>, <span class="hljs-string">'**/__mocks__/**'</span>, <span class="hljs-string">'**/__generated__/**'</span>]
  },
  <span class="hljs-attr">extensions</span>: {
    <span class="hljs-attr">array</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'File extensions to compile (defaults to extensions provided by the '</span> + <span class="hljs-string">'language plugin)'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>
  },
  <span class="hljs-attr">verbose</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'More verbose logging'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'boolean'</span>,
    <span class="hljs-string">"default"</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">quiet</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'No output to stdout'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'boolean'</span>,
    <span class="hljs-string">"default"</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">watchman</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'Use watchman when not in watch mode'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'boolean'</span>,
    <span class="hljs-string">"default"</span>: <span class="hljs-literal">true</span>
  },
  <span class="hljs-attr">watch</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'If specified, watches files and regenerates on changes'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'boolean'</span>,
    <span class="hljs-string">"default"</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">validate</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'Looks for pending changes and exits with non-zero code instead of '</span> + <span class="hljs-string">'writing to disk'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'boolean'</span>,
    <span class="hljs-string">"default"</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">persistFunction</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'An async function (or path to a module exporting this function) which will persist the query text and return the id.'</span>,
    <span class="hljs-attr">demandOption</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">array</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">persistOutput</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'A path to a .json file where persisted query metadata should be saved. Will use the default implementation (md5 hash) if `persistFunction` is not passed.'</span>,
    <span class="hljs-attr">demandOption</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">array</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">repersist</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'Run the persist function even if the query has not changed.'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'boolean'</span>,
    <span class="hljs-string">"default"</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">noFutureProofEnums</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'This option controls whether or not a catch-all entry is added to enum type definitions '</span> + <span class="hljs-string">'for values that may be added in the future. Enabling this means you will have to update '</span> + <span class="hljs-string">'your application whenever the GraphQL server schema adds new enum values to prevent it '</span> + <span class="hljs-string">'from breaking.'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'boolean'</span>,
    <span class="hljs-string">"default"</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">language</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'The name of the language plugin used for input files and artifacts'</span>,
    <span class="hljs-attr">demandOption</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">array</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-string">"default"</span>: <span class="hljs-string">'javascript'</span>
  },
  <span class="hljs-attr">artifactDirectory</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'A specific directory to output all artifacts to. When enabling this '</span> + <span class="hljs-string">'the babel plugin needs `artifactDirectory` set as well.'</span>,
    <span class="hljs-attr">demandOption</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
    <span class="hljs-attr">array</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">customScalars</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'Mappings from custom scalars in your schema to built-in GraphQL '</span> + <span class="hljs-string">'types, for type emission purposes. (Uses yargs dot-notation, e.g. '</span> + <span class="hljs-string">'--customScalars.URL=String)'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'object'</span>
  },
  <span class="hljs-attr">eagerESModules</span>: {
    <span class="hljs-attr">describe</span>: <span class="hljs-string">'This option enables emitting es modules artifacts.'</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">'boolean'</span>,
    <span class="hljs-string">"default"</span>: <span class="hljs-literal">false</span>
  }
}; <span class="hljs-comment">// Parse CLI args</span>

<span class="hljs-keyword">var</span> yargs = _yargs.usage(<span class="hljs-string">'Create Relay generated files\n\n'</span> + <span class="hljs-string">'$0 --schema &lt;path&gt; --src &lt;path&gt; [--watch]'</span>).options(options).strict(); <span class="hljs-comment">// Load external config</span>


<span class="hljs-keyword">var</span> config = RelayConfig &amp;&amp; RelayConfig.loadConfig();

<span class="hljs-keyword">if</span> (config) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-188" id="section-188"></a>
</div>
<p>Apply externally loaded config through the yargs API so that we can leverage yargs' defaults and have them show up
in the help banner. We add it conditionally otherwise yargs would add new option <code>--config</code> which is confusing for
Relay users (it's not Relay Config file).</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  yargs = yargs.config(config);
}

<span class="hljs-keyword">var</span> argv = yargs.help().argv; <span class="hljs-comment">// Start the application</span>

main(argv)[<span class="hljs-string">"catch"</span>](<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
  <span class="hljs-built_in">console</span>.error(<span class="hljs-built_in">String</span>(error.stack || error));
  process.exit(<span class="hljs-number">1</span>);
});

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 51 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"yargs"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 52 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-189" id="section-189"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _asyncToGenerator = __webpack_require__(<span class="hljs-number">11</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> CodegenRunner = __webpack_require__(<span class="hljs-number">53</span>);

<span class="hljs-keyword">var</span> ConsoleReporter = __webpack_require__(<span class="hljs-number">59</span>);

<span class="hljs-keyword">var</span> DotGraphQLParser = __webpack_require__(<span class="hljs-number">61</span>);

<span class="hljs-keyword">var</span> RelayFileWriter = __webpack_require__(<span class="hljs-number">62</span>);

<span class="hljs-keyword">var</span> RelayIRTransforms = __webpack_require__(<span class="hljs-number">75</span>);

<span class="hljs-keyword">var</span> RelayLanguagePluginJavaScript = __webpack_require__(<span class="hljs-number">112</span>);

<span class="hljs-keyword">var</span> RelaySourceModuleParser = __webpack_require__(<span class="hljs-number">116</span>);

<span class="hljs-keyword">var</span> WatchmanClient = __webpack_require__(<span class="hljs-number">22</span>);

<span class="hljs-keyword">var</span> crypto = __webpack_require__(<span class="hljs-number">13</span>);

<span class="hljs-keyword">var</span> fs = __webpack_require__(<span class="hljs-number">12</span>);

<span class="hljs-keyword">var</span> glob = __webpack_require__(<span class="hljs-number">121</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> path = __webpack_require__(<span class="hljs-number">8</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">7</span>),
    buildClientSchema = _require.buildClientSchema,
    Source = _require.Source,
    printSchema = _require.printSchema;

<span class="hljs-keyword">var</span> commonTransforms = RelayIRTransforms.commonTransforms,
    codegenTransforms = RelayIRTransforms.codegenTransforms,
    fragmentTransforms = RelayIRTransforms.fragmentTransforms,
    printTransforms = RelayIRTransforms.printTransforms,
    queryTransforms = RelayIRTransforms.queryTransforms,
    relaySchemaExtensions = RelayIRTransforms.schemaExtensions;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildWatchExpression</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-keyword">return</span> [<span class="hljs-string">'allof'</span>, [<span class="hljs-string">'type'</span>, <span class="hljs-string">'f'</span>], [<span class="hljs-string">'anyof'</span>].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(config.extensions.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ext</span>) </span>{
    <span class="hljs-keyword">return</span> [<span class="hljs-string">'suffix'</span>, ext];
  }))), [<span class="hljs-string">'anyof'</span>].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(config.include.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">include</span>) </span>{
    <span class="hljs-keyword">return</span> [<span class="hljs-string">'match'</span>, include, <span class="hljs-string">'wholename'</span>];
  })))].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(config.exclude.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">exclude</span>) </span>{
    <span class="hljs-keyword">return</span> [<span class="hljs-string">'not'</span>, [<span class="hljs-string">'match'</span>, exclude, <span class="hljs-string">'wholename'</span>]];
  })));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFilepathsFromGlob</span>(<span class="hljs-params">baseDir, config</span>) </span>{
  <span class="hljs-keyword">var</span> extensions = config.extensions,
      include = config.include,
      exclude = config.exclude;
  <span class="hljs-keyword">var</span> files = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
  include.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inc</span>) </span>{
    <span class="hljs-keyword">return</span> glob.sync(<span class="hljs-string">""</span>.concat(inc, <span class="hljs-string">"/*.+("</span>).concat(extensions.join(<span class="hljs-string">'|'</span>), <span class="hljs-string">")"</span>), {
      <span class="hljs-attr">cwd</span>: baseDir,
      <span class="hljs-attr">ignore</span>: exclude
    }).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">file</span>) </span>{
      <span class="hljs-keyword">return</span> files.add(file);
    });
  });
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(files);
}

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-190" id="section-190"></a>
</div>
<div class="dox">
<div class="summary">
<p>Unless the requested plugin is the builtin <code>javascript</code> one, import a
language plugin as either a CommonJS or ES2015 module.</p>
</div>
<div class="body">
<p>When importing, first check if its a path to an existing file, otherwise
assume its a package and prepend the plugin namespace prefix.</p>
<p>Make sure to always use Node's <code>require</code> function, which otherwise would get
replaced with <code>__webpack_require__</code> when bundled using webpack, by using
<code>eval</code> to get it at runtime.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLanguagePlugin</span>(<span class="hljs-params">language, options</span>) </span>{
  <span class="hljs-keyword">if</span> (language === <span class="hljs-string">'javascript'</span>) {
    <span class="hljs-keyword">return</span> RelayLanguagePluginJavaScript({
      <span class="hljs-attr">eagerESModules</span>: <span class="hljs-built_in">Boolean</span>(options &amp;&amp; options.eagerESModules)
    });
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> languagePlugin;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> language === <span class="hljs-string">'string'</span>) {
      <span class="hljs-keyword">var</span> pluginPath = path.resolve(process.cwd(), language);
      <span class="hljs-keyword">var</span> requirePath = fs.existsSync(pluginPath) ? pluginPath : <span class="hljs-string">"relay-compiler-language-"</span>.concat(language);

      <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-191" id="section-191"></a>
</div>
<p>eslint-disable-next-line no-eval</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        languagePlugin = <span class="hljs-built_in">eval</span>(<span class="hljs-string">'require'</span>)(requirePath);

        <span class="hljs-keyword">if</span> (languagePlugin[<span class="hljs-string">"default"</span>]) {
          languagePlugin = languagePlugin[<span class="hljs-string">"default"</span>];
        }
      } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-keyword">var</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unable to load language plugin "</span>.concat(requirePath, <span class="hljs-string">": "</span>).concat(err.message));
        e.stack = err.stack;
        <span class="hljs-keyword">throw</span> e;
      }
    } <span class="hljs-keyword">else</span> {
      languagePlugin = language;
    }

    <span class="hljs-keyword">if</span> (languagePlugin[<span class="hljs-string">"default"</span>] != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-192" id="section-192"></a>
</div>
<div class="dox">
<div class="summary">
<p>$FlowFixMe[incompatible-type] - Flow no longer considers statics of
functions as any</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">      languagePlugin = languagePlugin[<span class="hljs-string">"default"</span>];
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> languagePlugin === <span class="hljs-string">'function'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-193" id="section-193"></a>
</div>
<p>$FlowFixMe[incompatible-use]</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> languagePlugin();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Expected plugin to be a initializer function.'</span>);
    }
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPersistQueryFunction</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-keyword">var</span> configValue = config.persistFunction;

  <span class="hljs-keyword">if</span> (configValue == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> configValue === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-194" id="section-194"></a>
</div>
<p>eslint-disable-next-line no-eval</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> persistFunction = <span class="hljs-built_in">eval</span>(<span class="hljs-string">'require'</span>)(path.resolve(process.cwd(), configValue));

      <span class="hljs-keyword">if</span> (persistFunction[<span class="hljs-string">"default"</span>]) {
        <span class="hljs-keyword">return</span> persistFunction[<span class="hljs-string">"default"</span>];
      }

      <span class="hljs-keyword">return</span> persistFunction;
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-keyword">var</span> e = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unable to load persistFunction "</span>.concat(configValue, <span class="hljs-string">": "</span>).concat(err.message));
      e.stack = err.stack;
      <span class="hljs-keyword">throw</span> e;
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> configValue === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">return</span> configValue;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Expected persistFunction to be a path string or a function.'</span>);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params">_x</span>) </span>{
  <span class="hljs-keyword">return</span> _main.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_main</span>(<span class="hljs-params"></span>) </span>{
  _main = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">defaultConfig</span>) </span>{
    <span class="hljs-keyword">if</span> (defaultConfig.verbose &amp;&amp; defaultConfig.quiet) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"I can't be quiet and verbose at the same time"</span>);
    }

    <span class="hljs-keyword">var</span> config = getPathBasedConfig(defaultConfig);
    config = <span class="hljs-keyword">yield</span> getWatchConfig(config); <span class="hljs-comment">// Use function from module.exports to be able to mock it for tests</span>

    <span class="hljs-keyword">var</span> codegenRunner = <span class="hljs-built_in">module</span>.exports.getCodegenRunner(config);
    <span class="hljs-keyword">var</span> result = config.watch ? <span class="hljs-keyword">yield</span> codegenRunner.watchAll() : <span class="hljs-keyword">yield</span> codegenRunner.compileAll();

    <span class="hljs-keyword">if</span> (result === <span class="hljs-string">'ERROR'</span>) {
      process.exit(<span class="hljs-number">100</span>);
    }

    <span class="hljs-keyword">if</span> (config.validate &amp;&amp; result !== <span class="hljs-string">'NO_CHANGES'</span>) {
      process.exit(<span class="hljs-number">101</span>);
    }
  });
  <span class="hljs-keyword">return</span> _main.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPathBasedConfig</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-keyword">var</span> schema = path.resolve(process.cwd(), config.schema);

  <span class="hljs-keyword">if</span> (!fs.existsSync(schema)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"--schema path does not exist: "</span>.concat(schema));
  }

  <span class="hljs-keyword">var</span> src = path.resolve(process.cwd(), config.src);

  <span class="hljs-keyword">if</span> (!fs.existsSync(src)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"--src path does not exist: "</span>.concat(src));
  }

  <span class="hljs-keyword">var</span> persistOutput = config.persistOutput;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> persistOutput === <span class="hljs-string">'string'</span>) {
    persistOutput = path.resolve(process.cwd(), persistOutput);
    <span class="hljs-keyword">var</span> persistOutputDir = path.dirname(persistOutput);

    <span class="hljs-keyword">if</span> (!fs.existsSync(persistOutputDir)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"--persistOutput path does not exist: "</span>.concat(persistOutput));
    }
  }

  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, config), {}, {
    <span class="hljs-attr">schema</span>: schema,
    <span class="hljs-attr">src</span>: src,
    <span class="hljs-attr">persistOutput</span>: persistOutput
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWatchConfig</span>(<span class="hljs-params">_x2</span>) </span>{
  <span class="hljs-keyword">return</span> _getWatchConfig.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_getWatchConfig</span>(<span class="hljs-params"></span>) </span>{
  _getWatchConfig = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">config</span>) </span>{
    <span class="hljs-keyword">var</span> watchman = config.watchman &amp;&amp; (<span class="hljs-keyword">yield</span> WatchmanClient.isAvailable());

    <span class="hljs-keyword">if</span> (config.watch) {
      <span class="hljs-keyword">if</span> (!watchman) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Watchman is required to watch for changes. Running with watch mode disabled.'</span>);
        <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, config), {}, {
          <span class="hljs-attr">watch</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">watchman</span>: <span class="hljs-literal">false</span>
        });
      }

      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">module</span>.exports.hasWatchmanRootFile(config.src)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"\n--watch requires that the src directory have a valid watchman \"root\" file.\n\nRoot files can include:\n- A .git/ Git folder\n- A .hg/ Mercurial folder\n- A .watchmanconfig file\n\nEnsure that one such file exists in "</span>.concat(config.src, <span class="hljs-string">" or its parents.\n      "</span>).trim());
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (watchman &amp;&amp; !config.validate) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-195" id="section-195"></a>
</div>
<p>eslint-disable-next-line no-console</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'HINT: pass --watch to keep watching for changes.'</span>);
    }

    <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, config), {}, {
      <span class="hljs-attr">watchman</span>: watchman
    });
  });
  <span class="hljs-keyword">return</span> _getWatchConfig.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCodegenRunner</span>(<span class="hljs-params">config</span>) </span>{
  <span class="hljs-keyword">var</span> _parserConfigs;

  <span class="hljs-keyword">var</span> reporter = <span class="hljs-keyword">new</span> ConsoleReporter({
    <span class="hljs-attr">verbose</span>: config.verbose,
    <span class="hljs-attr">quiet</span>: config.quiet
  });
  <span class="hljs-keyword">var</span> schema = getSchemaSource(config.schema);
  <span class="hljs-keyword">var</span> languagePlugin = getLanguagePlugin(config.language, {
    <span class="hljs-attr">eagerESModules</span>: config.eagerESModules === <span class="hljs-literal">true</span>
  });
  <span class="hljs-keyword">var</span> persistQueryFunction = getPersistQueryFunction(config);
  <span class="hljs-keyword">var</span> inputExtensions = config.extensions || languagePlugin.inputExtensions;
  <span class="hljs-keyword">var</span> outputExtension = languagePlugin.outputExtension;
  <span class="hljs-keyword">var</span> sourceParserName = inputExtensions.join(<span class="hljs-string">'/'</span>);
  <span class="hljs-keyword">var</span> sourceWriterName = outputExtension;
  <span class="hljs-keyword">var</span> sourceModuleParser = RelaySourceModuleParser(languagePlugin.findGraphQLTags, languagePlugin.getFileFilter);
  <span class="hljs-keyword">var</span> providedArtifactDirectory = config.artifactDirectory;
  <span class="hljs-keyword">var</span> artifactDirectory = providedArtifactDirectory != <span class="hljs-literal">null</span> ? path.resolve(process.cwd(), providedArtifactDirectory) : <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> generatedDirectoryName = artifactDirectory !== <span class="hljs-literal">null</span> &amp;&amp; artifactDirectory !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? artifactDirectory : <span class="hljs-string">'__generated__'</span>;
  <span class="hljs-keyword">var</span> sourceSearchOptions = {
    <span class="hljs-attr">extensions</span>: inputExtensions,
    <span class="hljs-attr">include</span>: config.include,
    <span class="hljs-attr">exclude</span>: [<span class="hljs-string">'**/*.graphql.*'</span>].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(config.exclude))
  };
  <span class="hljs-keyword">var</span> graphqlSearchOptions = {
    <span class="hljs-attr">extensions</span>: [<span class="hljs-string">'graphql'</span>],
    <span class="hljs-attr">include</span>: config.include,
    <span class="hljs-attr">exclude</span>: [path.relative(config.src, config.schema)].concat(config.exclude)
  };

  <span class="hljs-keyword">var</span> defaultIsGeneratedFile = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultIsGeneratedFile</span>(<span class="hljs-params">filePath</span>) </span>{
    <span class="hljs-keyword">return</span> filePath.endsWith(<span class="hljs-string">'.graphql.'</span> + outputExtension) &amp;&amp; filePath.includes(generatedDirectoryName);
  };

  <span class="hljs-keyword">var</span> schemaExtensions = languagePlugin.schemaExtensions ? [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(languagePlugin.schemaExtensions), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(relaySchemaExtensions)) : relaySchemaExtensions;
  <span class="hljs-keyword">var</span> parserConfigs = (_parserConfigs = {}, (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(_parserConfigs, sourceParserName, {
    <span class="hljs-attr">baseDir</span>: config.src,
    <span class="hljs-attr">getFileFilter</span>: sourceModuleParser.getFileFilter,
    <span class="hljs-attr">getParser</span>: sourceModuleParser.getParser,
    <span class="hljs-attr">getSchemaSource</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSchemaSource</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> schema;
    },
    <span class="hljs-attr">schemaExtensions</span>: schemaExtensions,
    <span class="hljs-attr">watchmanExpression</span>: config.watchman ? buildWatchExpression(sourceSearchOptions) : <span class="hljs-literal">null</span>,
    <span class="hljs-attr">filepaths</span>: config.watchman ? <span class="hljs-literal">null</span> : getFilepathsFromGlob(config.src, sourceSearchOptions)
  }), (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(_parserConfigs, <span class="hljs-string">"graphql"</span>, {
    <span class="hljs-attr">baseDir</span>: config.src,
    <span class="hljs-attr">getParser</span>: DotGraphQLParser.getParser,
    <span class="hljs-attr">getSchemaSource</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSchemaSource</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> schema;
    },
    <span class="hljs-attr">schemaExtensions</span>: schemaExtensions,
    <span class="hljs-attr">watchmanExpression</span>: config.watchman ? buildWatchExpression(graphqlSearchOptions) : <span class="hljs-literal">null</span>,
    <span class="hljs-attr">filepaths</span>: config.watchman ? <span class="hljs-literal">null</span> : getFilepathsFromGlob(config.src, graphqlSearchOptions)
  }), _parserConfigs);
  <span class="hljs-keyword">var</span> writerConfigs = (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])({}, sourceWriterName, {
    <span class="hljs-attr">writeFiles</span>: getRelayFileWriter(config.src, languagePlugin, config.noFutureProofEnums, artifactDirectory, config.persistOutput, config.customScalars, persistQueryFunction, config.repersist),
    <span class="hljs-attr">isGeneratedFile</span>: languagePlugin.isGeneratedFile ? languagePlugin.isGeneratedFile : defaultIsGeneratedFile,
    <span class="hljs-attr">parser</span>: sourceParserName,
    <span class="hljs-attr">baseParsers</span>: [<span class="hljs-string">'graphql'</span>]
  });
  <span class="hljs-keyword">var</span> codegenRunner = <span class="hljs-keyword">new</span> CodegenRunner({
    <span class="hljs-attr">reporter</span>: reporter,
    <span class="hljs-attr">parserConfigs</span>: parserConfigs,
    <span class="hljs-attr">writerConfigs</span>: writerConfigs,
    <span class="hljs-attr">onlyValidate</span>: config.validate,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-196" id="section-196"></a>
</div>
<p>TODO: allow passing in a flag or detect?</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    sourceControl: <span class="hljs-literal">null</span>
  });
  <span class="hljs-keyword">return</span> codegenRunner;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultPersistFunction</span>(<span class="hljs-params">text</span>) </span>{
  <span class="hljs-keyword">var</span> hasher = crypto.createHash(<span class="hljs-string">'md5'</span>);
  hasher.update(text);
  <span class="hljs-keyword">var</span> id = hasher.digest(<span class="hljs-string">'hex'</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(id);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRelayFileWriter</span>(<span class="hljs-params">baseDir, languagePlugin, noFutureProofEnums, outputDir, persistedQueryPath, customScalars, persistFunction, repersist</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _ref2 = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">_ref</span>) </span>{
      <span class="hljs-keyword">var</span> onlyValidate = _ref.onlyValidate,
          schema = _ref.schema,
          documents = _ref.documents,
          baseDocuments = _ref.baseDocuments,
          sourceControl = _ref.sourceControl,
          reporter = _ref.reporter;
      <span class="hljs-keyword">var</span> persistQuery;
      <span class="hljs-keyword">var</span> queryMap;

      <span class="hljs-keyword">if</span> (persistFunction != <span class="hljs-literal">null</span> || persistedQueryPath != <span class="hljs-literal">null</span>) {
        queryMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
        <span class="hljs-keyword">var</span> persistImplmentation = persistFunction || defaultPersistFunction;

        persistQuery = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> _persistQuery = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">text</span>) </span>{
            <span class="hljs-keyword">var</span> id = <span class="hljs-keyword">yield</span> persistImplmentation(text);
            !(<span class="hljs-keyword">typeof</span> id === <span class="hljs-string">'string'</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'Expected persist function to return a string, got `%s`.'</span>, id) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
            queryMap.set(id, text);
            <span class="hljs-keyword">return</span> id;
          });

          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">persistQuery</span>(<span class="hljs-params">_x4</span>) </span>{
            <span class="hljs-keyword">return</span> _persistQuery.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
          }

          <span class="hljs-keyword">return</span> persistQuery;
        }();
      }

      <span class="hljs-keyword">var</span> schemaExtensions = languagePlugin.schemaExtensions ? [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(languagePlugin.schemaExtensions), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(relaySchemaExtensions)) : relaySchemaExtensions;
      <span class="hljs-keyword">var</span> results = <span class="hljs-keyword">yield</span> RelayFileWriter.writeAll({
        <span class="hljs-attr">config</span>: {
          <span class="hljs-attr">baseDir</span>: baseDir,
          <span class="hljs-attr">compilerTransforms</span>: {
            <span class="hljs-attr">commonTransforms</span>: commonTransforms,
            <span class="hljs-attr">codegenTransforms</span>: codegenTransforms,
            <span class="hljs-attr">fragmentTransforms</span>: fragmentTransforms,
            <span class="hljs-attr">printTransforms</span>: printTransforms,
            <span class="hljs-attr">queryTransforms</span>: queryTransforms
          },
          <span class="hljs-attr">customScalars</span>: customScalars || {},
          <span class="hljs-attr">formatModule</span>: languagePlugin.formatModule,
          <span class="hljs-attr">optionalInputFieldsForFlow</span>: [],
          <span class="hljs-attr">schemaExtensions</span>: schemaExtensions,
          <span class="hljs-attr">useHaste</span>: <span class="hljs-literal">false</span>,
          <span class="hljs-attr">noFutureProofEnums</span>: noFutureProofEnums,
          <span class="hljs-attr">extension</span>: languagePlugin.outputExtension,
          <span class="hljs-attr">typeGenerator</span>: languagePlugin.typeGenerator,
          <span class="hljs-attr">outputDir</span>: outputDir,
          <span class="hljs-attr">persistQuery</span>: persistQuery,
          <span class="hljs-attr">repersist</span>: repersist
        },
        <span class="hljs-attr">onlyValidate</span>: onlyValidate,
        <span class="hljs-attr">schema</span>: schema,
        <span class="hljs-attr">baseDocuments</span>: baseDocuments,
        <span class="hljs-attr">documents</span>: documents,
        <span class="hljs-attr">reporter</span>: reporter,
        <span class="hljs-attr">sourceControl</span>: sourceControl,
        <span class="hljs-attr">languagePlugin</span>: languagePlugin
      });

      <span class="hljs-keyword">if</span> (queryMap != <span class="hljs-literal">null</span> &amp;&amp; persistedQueryPath != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> object = {};

        <span class="hljs-keyword">if</span> (fs.existsSync(persistedQueryPath)) {
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">var</span> prevText = fs.readFileSync(persistedQueryPath, <span class="hljs-string">'utf8'</span>);
            <span class="hljs-keyword">var</span> prevData = <span class="hljs-built_in">JSON</span>.parse(prevText);

            <span class="hljs-keyword">if</span> (prevData != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> prevData === <span class="hljs-string">'object'</span>) {
              object = prevData;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"Invalid data in persisted query file '"</span>.concat(persistedQueryPath, <span class="hljs-string">"', expected an object."</span>));
            }
          } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-built_in">console</span>.error(error);
          }
        }

        <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(queryMap.entries()),
            _step;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
            <span class="hljs-keyword">var</span> _step$value = _step.value,
                id = _step$value[<span class="hljs-number">0</span>],
                _text = _step$value[<span class="hljs-number">1</span>];
            object[id] = _text;
          }
        } <span class="hljs-keyword">catch</span> (err) {
          _iterator.e(err);
        } <span class="hljs-keyword">finally</span> {
          _iterator.f();
        }

        <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.stringify(object, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);
        fs.writeFileSync(persistedQueryPath, data, <span class="hljs-string">'utf8'</span>);
      }

      <span class="hljs-keyword">return</span> results;
    });

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_x3</span>) </span>{
      <span class="hljs-keyword">return</span> _ref2.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    };
  }();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSchemaSource</span>(<span class="hljs-params">schemaPath</span>) </span>{
  <span class="hljs-keyword">var</span> source = fs.readFileSync(schemaPath, <span class="hljs-string">'utf8'</span>);

  <span class="hljs-keyword">if</span> (path.extname(schemaPath) === <span class="hljs-string">'.json'</span>) {
    source = printSchema(buildClientSchema(<span class="hljs-built_in">JSON</span>.parse(source).data));
  }

  source = <span class="hljs-string">"\n  directive @include(if: Boolean) on FRAGMENT_SPREAD | FIELD | INLINE_FRAGMENT\n  directive @skip(if: Boolean) on FRAGMENT_SPREAD | FIELD | INLINE_FRAGMENT\n\n  "</span>.concat(source, <span class="hljs-string">"\n  "</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Source(source, schemaPath);
} <span class="hljs-comment">// Ensure that a watchman "root" file exists in the given directory</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-197" id="section-197"></a>
</div>
<p>or a parent so that it can be watched</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> WATCHMAN_ROOT_FILES = [<span class="hljs-string">'.git'</span>, <span class="hljs-string">'.hg'</span>, <span class="hljs-string">'.watchmanconfig'</span>];

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasWatchmanRootFile</span>(<span class="hljs-params">testPath</span>) </span>{
  <span class="hljs-keyword">while</span> (path.dirname(testPath) !== testPath) {
    <span class="hljs-keyword">if</span> (WATCHMAN_ROOT_FILES.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">file</span>) </span>{
      <span class="hljs-keyword">return</span> fs.existsSync(path.join(testPath, file));
    })) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    testPath = path.dirname(testPath);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">getCodegenRunner</span>: getCodegenRunner,
  <span class="hljs-attr">getLanguagePlugin</span>: getLanguagePlugin,
  <span class="hljs-attr">getWatchConfig</span>: getWatchConfig,
  <span class="hljs-attr">hasWatchmanRootFile</span>: hasWatchmanRootFile,
  <span class="hljs-attr">main</span>: main
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 53 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-198" id="section-198"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _asyncToGenerator = __webpack_require__(<span class="hljs-number">11</span>);

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> CodegenDirectory = __webpack_require__(<span class="hljs-number">26</span>);

<span class="hljs-keyword">var</span> CodegenWatcher = __webpack_require__(<span class="hljs-number">54</span>);

<span class="hljs-keyword">var</span> GraphQLWatchmanClient = __webpack_require__(<span class="hljs-number">22</span>);

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> path = __webpack_require__(<span class="hljs-number">8</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">57</span>),
    createSchema = _require.create;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-199" id="section-199"></a>
</div>
<div class="dox">
<div class="summary">
<p>$FlowFixMe[untyped-import] - importing immutable, which is untyped (and flow
is sad about it)</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">14</span>),
    ImmutableMap = _require2.Map;

<span class="hljs-keyword">var</span> CodegenRunner = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-200" id="section-200"></a>
</div>
<p>parser =&gt; writers that are affected by it</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CodegenRunner</span>(<span class="hljs-params">options</span>) </span>{
    <span class="hljs-keyword">var</span> _this = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">this</span>.parsers = {};
    <span class="hljs-keyword">this</span>.parserConfigs = options.parserConfigs;
    <span class="hljs-keyword">this</span>.writerConfigs = options.writerConfigs;
    <span class="hljs-keyword">this</span>.onlyValidate = options.onlyValidate;
    <span class="hljs-keyword">this</span>.onComplete = options.onComplete;
    <span class="hljs-keyword">this</span>._reporter = options.reporter;
    <span class="hljs-keyword">this</span>._sourceControl = options.sourceControl;
    <span class="hljs-keyword">this</span>.parserWriters = {};

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _parser <span class="hljs-keyword">in</span> options.parserConfigs) {
      <span class="hljs-keyword">this</span>.parserWriters[_parser] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    }

    <span class="hljs-keyword">var</span> _loop = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_loop</span>(<span class="hljs-params">_writer</span>) </span>{
      <span class="hljs-keyword">var</span> config = options.writerConfigs[_writer];
      config.baseParsers &amp;&amp; config.baseParsers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parser</span>) </span>{
        <span class="hljs-keyword">return</span> _this.parserWriters[parser].add(_writer);
      });

      _this.parserWriters[config.parser].add(_writer);
    };

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _writer <span class="hljs-keyword">in</span> options.writerConfigs) {
      _loop(_writer);
    }
  }

  <span class="hljs-keyword">var</span> _proto = CodegenRunner.prototype;

  _proto.compileAll = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _compileAll = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-201" id="section-201"></a>
</div>
<p>reset the parsers</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">this</span>.parsers = {};

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> parserName <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.parserConfigs) {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.parseEverything(parserName);
        } <span class="hljs-keyword">catch</span> (e) {
          <span class="hljs-keyword">this</span>._reporter.reportError(<span class="hljs-string">'CodegenRunner.compileAll'</span>, e);

          <span class="hljs-keyword">return</span> <span class="hljs-string">'ERROR'</span>;
        }
      }

      <span class="hljs-keyword">var</span> hasChanges = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> writerName <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.writerConfigs) {
        <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.write(writerName);

        <span class="hljs-keyword">if</span> (result === <span class="hljs-string">'ERROR'</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-string">'ERROR'</span>;
        }

        <span class="hljs-keyword">if</span> (result === <span class="hljs-string">'HAS_CHANGES'</span>) {
          hasChanges = <span class="hljs-literal">true</span>;
        }
      }

      <span class="hljs-keyword">return</span> hasChanges ? <span class="hljs-string">'HAS_CHANGES'</span> : <span class="hljs-string">'NO_CHANGES'</span>;
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileAll</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> _compileAll.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    <span class="hljs-keyword">return</span> compileAll;
  }();

  _proto.compile = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _compile = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">writerName</span>) </span>{
      <span class="hljs-keyword">var</span> _this2 = <span class="hljs-keyword">this</span>;

      <span class="hljs-keyword">var</span> writerConfig = <span class="hljs-keyword">this</span>.writerConfigs[writerName];
      <span class="hljs-keyword">var</span> parsers = [writerConfig.parser];

      <span class="hljs-keyword">if</span> (writerConfig.baseParsers) {
        writerConfig.baseParsers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parser</span>) </span>{
          <span class="hljs-keyword">return</span> parsers.push(parser);
        });
      } <span class="hljs-comment">// Don't bother resetting the parsers</span>


      <span class="hljs-keyword">yield</span> Profiler.asyncContext(<span class="hljs-string">'CodegenRunner:parseEverything'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(parsers.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parser</span>) </span>{
          <span class="hljs-keyword">return</span> _this2.parseEverything(parser);
        }));
      });
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.write(writerName);
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compile</span>(<span class="hljs-params">_x</span>) </span>{
      <span class="hljs-keyword">return</span> _compile.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    <span class="hljs-keyword">return</span> compile;
  }();

  _proto.getDirtyWriters = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDirtyWriters</span>(<span class="hljs-params">filePaths</span>) </span>{
    <span class="hljs-keyword">var</span> _this3 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">return</span> Profiler.asyncContext(<span class="hljs-string">'CodegenRunner:getDirtyWriters'</span>, <span class="hljs-comment">/*#__PURE__*/</span>_asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> dirtyWriters = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(); <span class="hljs-comment">// Check if any files are in the output</span>

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> configName <span class="hljs-keyword">in</span> _this3.writerConfigs) {
        <span class="hljs-keyword">var</span> config = _this3.writerConfigs[configName];

        <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(filePaths),
            _step;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
            <span class="hljs-keyword">var</span> _filePath = _step.value;

            <span class="hljs-keyword">if</span> (config.isGeneratedFile(_filePath)) {
              dirtyWriters.add(configName);
            }
          }
        } <span class="hljs-keyword">catch</span> (err) {
          _iterator.e(err);
        } <span class="hljs-keyword">finally</span> {
          _iterator.f();
        }
      } <span class="hljs-comment">// Check for files in the input</span>


      <span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.all(<span class="hljs-built_in">Object</span>.keys(_this3.parserConfigs).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parserConfigName</span>) </span>{
        <span class="hljs-keyword">return</span> Profiler.waitFor(<span class="hljs-string">'Watchman:query'</span>, <span class="hljs-comment">/*#__PURE__*/</span>_asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> GraphQLWatchmanClient();
          <span class="hljs-keyword">var</span> config = _this3.parserConfigs[parserConfigName];
          <span class="hljs-keyword">var</span> dirs = <span class="hljs-keyword">yield</span> client.watchProject(config.baseDir);
          <span class="hljs-keyword">var</span> relativeFilePaths = filePaths.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">filePath</span>) </span>{
            <span class="hljs-keyword">return</span> path.relative(config.baseDir, filePath);
          });
          <span class="hljs-keyword">var</span> query = {
            <span class="hljs-attr">expression</span>: [<span class="hljs-string">'allof'</span>, config.watchmanExpression, [<span class="hljs-string">'name'</span>, relativeFilePaths, <span class="hljs-string">'wholename'</span>]],
            <span class="hljs-attr">fields</span>: [<span class="hljs-string">'exists'</span>],
            <span class="hljs-attr">relative_root</span>: dirs.relativePath
          };
          <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">yield</span> client.command(<span class="hljs-string">'query'</span>, dirs.root, query);
          client.end();

          <span class="hljs-keyword">if</span> (result.files.length &gt; <span class="hljs-number">0</span>) {
            _this3.parserWriters[parserConfigName].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">writerName</span>) </span>{
              <span class="hljs-keyword">return</span> dirtyWriters.add(writerName);
            });
          }
        }));
      }));
      <span class="hljs-keyword">return</span> dirtyWriters;
    }));
  };

  _proto.parseEverything = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _parseEverything = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">parserName</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parsers[parserName]) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-202" id="section-202"></a>
</div>
<p>no need to parse</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> parserConfig = <span class="hljs-keyword">this</span>.parserConfigs[parserName];
      <span class="hljs-keyword">this</span>.parsers[parserName] = parserConfig.getParser(parserConfig.baseDir);
      <span class="hljs-keyword">var</span> filter = parserConfig.getFileFilter ? parserConfig.getFileFilter(parserConfig.baseDir) : anyFileFilter;

      <span class="hljs-keyword">if</span> (parserConfig.filepaths &amp;&amp; parserConfig.watchmanExpression) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Provide either `watchmanExpression` or `filepaths` but not both.'</span>);
      }

      <span class="hljs-keyword">var</span> files;

      <span class="hljs-keyword">if</span> (parserConfig.watchmanExpression) {
        files = <span class="hljs-keyword">yield</span> CodegenWatcher.queryFiles(parserConfig.baseDir, parserConfig.watchmanExpression, filter);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parserConfig.filepaths) {
        files = <span class="hljs-keyword">yield</span> CodegenWatcher.queryFilepaths(parserConfig.baseDir, parserConfig.filepaths, filter);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Either `watchmanExpression` or `filepaths` is required to query files'</span>);
      }

      <span class="hljs-keyword">this</span>.parseFileChanges(parserName, files);
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseEverything</span>(<span class="hljs-params">_x2</span>) </span>{
      <span class="hljs-keyword">return</span> _parseEverything.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    <span class="hljs-keyword">return</span> parseEverything;
  }();

  _proto.parseFileChanges = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseFileChanges</span>(<span class="hljs-params">parserName, files</span>) </span>{
    <span class="hljs-keyword">var</span> _this4 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">return</span> Profiler.run(<span class="hljs-string">'CodegenRunner.parseFileChanges'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> parser = _this4.parsers[parserName]; <span class="hljs-comment">// this maybe should be await parser.parseFiles(files);</span>

      parser.parseFiles(files);
    });
  } <span class="hljs-comment">// We cannot do incremental writes right now.</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-203" id="section-203"></a>
</div>
<p>When we can, this could be writeChanges(writerName, parserName, parsedDefinitions)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  ;

  _proto.write = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">write</span>(<span class="hljs-params">writerName</span>) </span>{
    <span class="hljs-keyword">var</span> _this5 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">return</span> Profiler.asyncContext(<span class="hljs-string">'CodegenRunner.write'</span>, <span class="hljs-comment">/*#__PURE__*/</span>_asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">try</span> {
        _this5._reporter.reportMessage(<span class="hljs-string">"\nWriting "</span>.concat(writerName));

        <span class="hljs-keyword">var</span> _this5$writerConfigs$ = _this5.writerConfigs[writerName],
            writeFiles = _this5$writerConfigs$.writeFiles,
            _parser2 = _this5$writerConfigs$.parser,
            baseParsers = _this5$writerConfigs$.baseParsers,
            isGeneratedFile = _this5$writerConfigs$.isGeneratedFile;
        <span class="hljs-keyword">var</span> baseDocuments = ImmutableMap();

        <span class="hljs-keyword">if</span> (baseParsers) {
          baseParsers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">baseParserName</span>) </span>{
            !(_this5.parsers[baseParserName] != <span class="hljs-literal">null</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'Trying to access an uncompiled base parser config: %s'</span>, baseParserName) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
            baseDocuments = baseDocuments.merge(_this5.parsers[baseParserName].documents());
          });
        }

        <span class="hljs-keyword">var</span> _this5$parserConfigs$ = _this5.parserConfigs[_parser2],
            _baseDir = _this5$parserConfigs$.baseDir,
            generatedDirectoriesWatchmanExpression = _this5$parserConfigs$.generatedDirectoriesWatchmanExpression;
        <span class="hljs-keyword">var</span> generatedDirectories = [];

        <span class="hljs-keyword">if</span> (generatedDirectoriesWatchmanExpression) {
          <span class="hljs-keyword">var</span> relativePaths = <span class="hljs-keyword">yield</span> CodegenWatcher.queryDirectories(_baseDir, generatedDirectoriesWatchmanExpression);
          generatedDirectories = relativePaths.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>{
            <span class="hljs-keyword">return</span> path.join(_baseDir, x);
          });
        } <span class="hljs-comment">// always create a new writer: we have to write everything anyways</span>


        <span class="hljs-keyword">var</span> documents = _this5.parsers[_parser2].documents();

        <span class="hljs-keyword">var</span> schema = Profiler.run(<span class="hljs-string">'getSchema'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">return</span> createSchema(_this5.parserConfigs[_parser2].getSchemaSource(), baseDocuments.toArray(), _this5.parserConfigs[_parser2].schemaExtensions);
        });
        <span class="hljs-keyword">var</span> outputDirectories = <span class="hljs-keyword">yield</span> writeFiles({
          <span class="hljs-attr">onlyValidate</span>: _this5.onlyValidate,
          <span class="hljs-attr">schema</span>: schema,
          <span class="hljs-attr">documents</span>: documents,
          <span class="hljs-attr">baseDocuments</span>: baseDocuments,
          <span class="hljs-attr">generatedDirectories</span>: generatedDirectories,
          <span class="hljs-attr">sourceControl</span>: _this5._sourceControl,
          <span class="hljs-attr">reporter</span>: _this5._reporter
        });

        <span class="hljs-keyword">var</span> _iterator2 = _createForOfIteratorHelper(outputDirectories.values()),
            _step2;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">for</span> (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            <span class="hljs-keyword">var</span> dir = _step2.value;
            <span class="hljs-keyword">var</span> all = [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(dir.changes.created), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(dir.changes.updated), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(dir.changes.deleted), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(dir.changes.unchanged));

            <span class="hljs-keyword">var</span> _iterator3 = _createForOfIteratorHelper(all),
                _step3;

            <span class="hljs-keyword">try</span> {
              <span class="hljs-keyword">for</span> (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                <span class="hljs-keyword">var</span> filename = _step3.value;

                <span class="hljs-keyword">var</span> _filePath2 = dir.getPath(filename);

                !isGeneratedFile(_filePath2) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'CodegenRunner: %s returned false for isGeneratedFile, '</span> + <span class="hljs-string">'but was in generated directory'</span>, _filePath2) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
              }
            } <span class="hljs-keyword">catch</span> (err) {
              _iterator3.e(err);
            } <span class="hljs-keyword">finally</span> {
              _iterator3.f();
            }
          }
        } <span class="hljs-keyword">catch</span> (err) {
          _iterator2.e(err);
        } <span class="hljs-keyword">finally</span> {
          _iterator2.f();
        }

        <span class="hljs-keyword">var</span> onCompleteCallback = _this5.onComplete;

        <span class="hljs-keyword">if</span> (onCompleteCallback != <span class="hljs-literal">null</span>) {
          onCompleteCallback(<span class="hljs-built_in">Array</span>.from(outputDirectories.values()));
        }

        <span class="hljs-keyword">var</span> combinedChanges = CodegenDirectory.combineChanges(<span class="hljs-built_in">Array</span>.from(outputDirectories.values()));

        _this5._reporter.reportMessage(CodegenDirectory.formatChanges(combinedChanges, {
          <span class="hljs-attr">onlyValidate</span>: _this5.onlyValidate
        }));

        <span class="hljs-keyword">return</span> CodegenDirectory.hasChanges(combinedChanges) ? <span class="hljs-string">'HAS_CHANGES'</span> : <span class="hljs-string">'NO_CHANGES'</span>;
      } <span class="hljs-keyword">catch</span> (e) {
        _this5._reporter.reportError(<span class="hljs-string">'CodegenRunner.write'</span>, e);

        <span class="hljs-keyword">return</span> <span class="hljs-string">'ERROR'</span>;
      }
    }));
  };

  _proto.watchAll = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _watchAll = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-204" id="section-204"></a>
</div>
<p>get everything set up for watching</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.compileAll();

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> parserName <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.parserConfigs) {
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.watch(parserName);
      }
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watchAll</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> _watchAll.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    <span class="hljs-keyword">return</span> watchAll;
  }();

  _proto.watch = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _watch = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">parserName</span>) </span>{
      <span class="hljs-keyword">var</span> _this6 = <span class="hljs-keyword">this</span>;

      <span class="hljs-keyword">var</span> parserConfig = <span class="hljs-keyword">this</span>.parserConfigs[parserName];

      <span class="hljs-keyword">if</span> (!parserConfig.watchmanExpression) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'`watchmanExpression` is required to watch files'</span>);
      } <span class="hljs-comment">// watchCompile starts with a full set of files as the changes</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-205" id="section-205"></a>
</div>
<p>But as we need to set everything up due to potential parser dependencies,
we should prevent the first watch callback from doing anything.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

      <span class="hljs-keyword">var</span> firstChange = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">yield</span> CodegenWatcher.watchCompile(parserConfig.baseDir, parserConfig.watchmanExpression, parserConfig.getFileFilter ? parserConfig.getFileFilter(parserConfig.baseDir) : anyFileFilter, <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> _ref4 = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">files</span>) </span>{
          !(_this6.parsers[parserName] != <span class="hljs-literal">null</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'Trying to watch an uncompiled parser config: %s'</span>, parserName) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;

          <span class="hljs-keyword">if</span> (firstChange) {
            firstChange = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">var</span> dependentWriters = [];

          _this6.parserWriters[parserName].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">writer</span>) </span>{
            <span class="hljs-keyword">return</span> dependentWriters.push(writer);
          });

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (!_this6.parsers[parserName]) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-206" id="section-206"></a>
</div>
<p>have to load the parser and make sure all of its dependents are set</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">              <span class="hljs-keyword">yield</span> _this6.parseEverything(parserName);
            } <span class="hljs-keyword">else</span> {
              _this6.parseFileChanges(parserName, files);
            }

            <span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.all(dependentWriters.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">writer</span>) </span>{
              <span class="hljs-keyword">return</span> _this6.write(writer);
            }));
          } <span class="hljs-keyword">catch</span> (error) {
            _this6._reporter.reportError(<span class="hljs-string">'CodegenRunner.watch'</span>, error);
          }

          _this6._reporter.reportMessage(<span class="hljs-string">"Watching for changes to "</span>.concat(parserName, <span class="hljs-string">"..."</span>));
        });

        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_x4</span>) </span>{
          <span class="hljs-keyword">return</span> _ref4.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        };
      }());

      <span class="hljs-keyword">this</span>._reporter.reportMessage(<span class="hljs-string">"Watching for changes to "</span>.concat(parserName, <span class="hljs-string">"..."</span>));
    });

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watch</span>(<span class="hljs-params">_x3</span>) </span>{
      <span class="hljs-keyword">return</span> _watch.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    <span class="hljs-keyword">return</span> watch;
  }();

  <span class="hljs-keyword">return</span> CodegenRunner;
}();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anyFileFilter</span>(<span class="hljs-params">file</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-built_in">module</span>.exports = CodegenRunner;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 54 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-207" id="section-207"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _asyncToGenerator = __webpack_require__(<span class="hljs-number">11</span>);

<span class="hljs-keyword">var</span> GraphQLWatchmanClient = __webpack_require__(<span class="hljs-number">22</span>);

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>);

<span class="hljs-keyword">var</span> crypto = __webpack_require__(<span class="hljs-number">13</span>);

<span class="hljs-keyword">var</span> fs = __webpack_require__(<span class="hljs-number">12</span>);

<span class="hljs-keyword">var</span> path = __webpack_require__(<span class="hljs-number">8</span>);

<span class="hljs-keyword">var</span> SUBSCRIPTION_NAME = <span class="hljs-string">'graphql-codegen'</span>;
<span class="hljs-keyword">var</span> QUERY_RETRIES = <span class="hljs-number">3</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryFiles</span>(<span class="hljs-params">_x, _x2, _x3</span>) </span>{
  <span class="hljs-keyword">return</span> _queryFiles.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_queryFiles</span>(<span class="hljs-params"></span>) </span>{
  _queryFiles = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">baseDir, expression, filter</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span> Profiler.waitFor(<span class="hljs-string">'Watchman:query'</span>, <span class="hljs-comment">/*#__PURE__*/</span>_asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> GraphQLWatchmanClient(QUERY_RETRIES);

      <span class="hljs-keyword">var</span> _await$<span class="hljs-built_in">Promise</span>$all = <span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.all([client.watchProject(baseDir), getFields(client)]),
          watchResp = _await$<span class="hljs-built_in">Promise</span>$all[<span class="hljs-number">0</span>],
          fields = _await$<span class="hljs-built_in">Promise</span>$all[<span class="hljs-number">1</span>];

      <span class="hljs-keyword">var</span> resp = <span class="hljs-keyword">yield</span> client.command(<span class="hljs-string">'query'</span>, watchResp.root, {
        <span class="hljs-attr">expression</span>: expression,
        <span class="hljs-attr">fields</span>: fields,
        <span class="hljs-attr">relative_root</span>: watchResp.relativePath
      });
      client.end();
      <span class="hljs-keyword">return</span> updateFiles(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(), baseDir, filter, resp.files);
    }));
  });
  <span class="hljs-keyword">return</span> _queryFiles.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryDirectories</span>(<span class="hljs-params">_x4, _x5</span>) </span>{
  <span class="hljs-keyword">return</span> _queryDirectories.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_queryDirectories</span>(<span class="hljs-params"></span>) </span>{
  _queryDirectories = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">baseDir, expression</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span> Profiler.waitFor(<span class="hljs-string">'Watchman:query'</span>, <span class="hljs-comment">/*#__PURE__*/</span>_asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> GraphQLWatchmanClient();
      <span class="hljs-keyword">var</span> watchResp = <span class="hljs-keyword">yield</span> client.watchProject(baseDir);
      <span class="hljs-keyword">var</span> resp = <span class="hljs-keyword">yield</span> client.command(<span class="hljs-string">'query'</span>, watchResp.root, {
        <span class="hljs-attr">expression</span>: expression,
        <span class="hljs-attr">fields</span>: [<span class="hljs-string">'name'</span>],
        <span class="hljs-attr">relative_root</span>: watchResp.relativePath
      });
      client.end();
      <span class="hljs-keyword">return</span> resp.files;
    }));
  });
  <span class="hljs-keyword">return</span> _queryDirectories.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFields</span>(<span class="hljs-params">_x6</span>) </span>{
  <span class="hljs-keyword">return</span> _getFields.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
} <span class="hljs-comment">// For use when not using Watchman.</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_getFields</span>(<span class="hljs-params"></span>) </span>{
  _getFields = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">client</span>) </span>{
    <span class="hljs-keyword">var</span> fields = [<span class="hljs-string">'name'</span>, <span class="hljs-string">'exists'</span>];

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">yield</span> client.hasCapability(<span class="hljs-string">'field-content.sha1hex'</span>)) {
      fields.push(<span class="hljs-string">'content.sha1hex'</span>);
    }

    <span class="hljs-keyword">return</span> fields;
  });
  <span class="hljs-keyword">return</span> _getFields.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryFilepaths</span>(<span class="hljs-params">_x7, _x8, _x9</span>) </span>{
  <span class="hljs-keyword">return</span> _queryFilepaths.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-208" id="section-208"></a>
</div>
<div class="dox">
<div class="summary">
<p>Provides a simplified API to the watchman API.
Given some base directory and a list of subdirectories it calls the callback
with watchman change events on file changes.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_queryFilepaths</span>(<span class="hljs-params"></span>) </span>{
  _queryFilepaths = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">baseDir, filepaths, filter</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-209" id="section-209"></a>
</div>
<p>Construct WatchmanChange objects as an intermediate step before
calling updateFiles to produce file content.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> files = filepaths.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">filepath</span>) </span>{
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">name</span>: filepath,
        <span class="hljs-attr">exists</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-string">'content.sha1hex'</span>: <span class="hljs-literal">null</span>
      };
    });
    <span class="hljs-keyword">return</span> updateFiles(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(), baseDir, filter, files);
  });
  <span class="hljs-keyword">return</span> _queryFilepaths.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watch</span>(<span class="hljs-params">_x10, _x11, _x12</span>) </span>{
  <span class="hljs-keyword">return</span> _watch.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_watch</span>(<span class="hljs-params"></span>) </span>{
  _watch = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">baseDir, expression, callback</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span> Profiler.waitFor(<span class="hljs-string">'Watchman:subscribe'</span>, <span class="hljs-comment">/*#__PURE__*/</span>_asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> GraphQLWatchmanClient();
      <span class="hljs-keyword">var</span> watchResp = <span class="hljs-keyword">yield</span> client.watchProject(baseDir);
      <span class="hljs-keyword">yield</span> makeSubscription(client, watchResp.root, watchResp.relativePath, expression, callback);
    }));
  });
  <span class="hljs-keyword">return</span> _watch.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeSubscription</span>(<span class="hljs-params">_x13, _x14, _x15, _x16, _x17</span>) </span>{
  <span class="hljs-keyword">return</span> _makeSubscription.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-210" id="section-210"></a>
</div>
<div class="dox">
<div class="summary">
<p>Further simplifies <code>watch</code> and calls the callback on every change with a
full list of files that match the conditions.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_makeSubscription</span>(<span class="hljs-params"></span>) </span>{
  _makeSubscription = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">client, root, relativePath, expression, callback</span>) </span>{
    client.on(<span class="hljs-string">'subscription'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resp</span>) </span>{
      <span class="hljs-keyword">if</span> (resp.subscription === SUBSCRIPTION_NAME) {
        callback(resp);
      }
    });
    <span class="hljs-keyword">var</span> fields = <span class="hljs-keyword">yield</span> getFields(client);
    <span class="hljs-keyword">yield</span> client.command(<span class="hljs-string">'subscribe'</span>, root, SUBSCRIPTION_NAME, {
      <span class="hljs-attr">expression</span>: expression,
      <span class="hljs-attr">fields</span>: fields,
      <span class="hljs-attr">relative_root</span>: relativePath
    });
  });
  <span class="hljs-keyword">return</span> _makeSubscription.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watchFiles</span>(<span class="hljs-params">_x18, _x19, _x20, _x21</span>) </span>{
  <span class="hljs-keyword">return</span> _watchFiles.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-211" id="section-211"></a>
</div>
<div class="dox">
<div class="summary">
<p>Similar to watchFiles, but takes an async function. The <code>compile</code> function
is awaited and not called in parallel. If multiple changes are triggered
before a compile finishes, the latest version is called after the compile
finished.</p>
</div>
<div class="body">
<p>TODO: Consider changing from a Promise to abortable, so we can abort mid
compilation.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_watchFiles</span>(<span class="hljs-params"></span>) </span>{
  _watchFiles = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">baseDir, expression, filter, callback</span>) </span>{
    <span class="hljs-keyword">var</span> files = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">yield</span> watch(baseDir, expression, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">changes</span>) </span>{
      <span class="hljs-keyword">if</span> (!changes.files) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-212" id="section-212"></a>
</div>
<p>Watchmen fires a change without files when a watchman state changes,
for example during an hg update.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span>;
      }

      files = updateFiles(files, baseDir, filter, changes.files);
      callback(files);
    });
  });
  <span class="hljs-keyword">return</span> _watchFiles.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watchCompile</span>(<span class="hljs-params">_x22, _x23, _x24, _x25</span>) </span>{
  <span class="hljs-keyword">return</span> _watchCompile.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_watchCompile</span>(<span class="hljs-params"></span>) </span>{
  _watchCompile = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">baseDir, expression, filter, compile</span>) </span>{
    <span class="hljs-keyword">var</span> compiling = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> needsCompiling = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> latestFiles = <span class="hljs-literal">null</span>;
    watchFiles(baseDir, expression, filter, <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> _ref5 = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">files</span>) </span>{
        needsCompiling = <span class="hljs-literal">true</span>;
        latestFiles = files;

        <span class="hljs-keyword">if</span> (compiling) {
          <span class="hljs-keyword">return</span>;
        }

        compiling = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">while</span> (needsCompiling) {
          needsCompiling = <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">yield</span> compile(latestFiles);
        }

        compiling = <span class="hljs-literal">false</span>;
      });

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_x26</span>) </span>{
        <span class="hljs-keyword">return</span> _ref5.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      };
    }());
  });
  <span class="hljs-keyword">return</span> _watchCompile.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateFiles</span>(<span class="hljs-params">files, baseDir, filter, fileChanges</span>) </span>{
  <span class="hljs-keyword">var</span> fileMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  files.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">file</span>) </span>{
    file.exists &amp;&amp; fileMap.set(file.relPath, file);
  });
  fileChanges.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref</span>) </span>{
    <span class="hljs-keyword">var</span> name = _ref.name,
        exists = _ref.exists,
        hash = _ref[<span class="hljs-string">'content.sha1hex'</span>];
    <span class="hljs-keyword">var</span> shouldRemove = !exists;

    <span class="hljs-keyword">if</span> (!shouldRemove) {
      <span class="hljs-keyword">var</span> _file = {
        <span class="hljs-attr">exists</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">relPath</span>: name,
        <span class="hljs-attr">hash</span>: hash || hashFile(path.join(baseDir, name))
      };

      <span class="hljs-keyword">if</span> (filter(_file)) {
        fileMap.set(name, _file);
      } <span class="hljs-keyword">else</span> {
        shouldRemove = <span class="hljs-literal">true</span>;
      }
    }

    shouldRemove &amp;&amp; fileMap.set(name, {
      <span class="hljs-attr">exists</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">relPath</span>: name
    });
  });
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(fileMap.values());
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hashFile</span>(<span class="hljs-params">filename</span>) </span>{
  <span class="hljs-keyword">var</span> content = fs.readFileSync(filename);
  <span class="hljs-keyword">return</span> crypto.createHash(<span class="hljs-string">'sha1'</span>).update(content).digest(<span class="hljs-string">'hex'</span>);
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">queryDirectories</span>: queryDirectories,
  <span class="hljs-attr">queryFiles</span>: queryFiles,
  <span class="hljs-attr">queryFilepaths</span>: queryFilepaths,
  <span class="hljs-attr">watch</span>: watch,
  <span class="hljs-attr">watchFiles</span>: watchFiles,
  <span class="hljs-attr">watchCompile</span>: watchCompile
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 55 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"child_process"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 56 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fb-watchman"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 57 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-213" id="section-213"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _inheritsLoose2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">58</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">9</span>),
    isSchemaDefinitionAST = _require2.isSchemaDefinitionAST;

<span class="hljs-keyword">var</span> _require3 = __webpack_require__(<span class="hljs-number">7</span>),
    GraphQLFloat = _require3.GraphQLFloat,
    GraphQLInt = _require3.GraphQLInt,
    GraphQLBoolean = _require3.GraphQLBoolean,
    GraphQLString = _require3.GraphQLString,
    GraphQLID = _require3.GraphQLID,
    parse = _require3.parse,
    parseType = _require3.parseType,
    print = _require3.print,
    valueFromASTUntyped = _require3.valueFromASTUntyped;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-214" id="section-214"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> Type = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Type</span>(<span class="hljs-params">name, isClient</span>) </span>{
    <span class="hljs-keyword">this</span>.name = name;
    <span class="hljs-keyword">this</span>.isClient = isClient;
  }

  <span class="hljs-keyword">var</span> _proto = Type.prototype;

  _proto.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toString</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
  };

  _proto.toJSON = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toJSON</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(<span class="hljs-keyword">this</span>);
  };

  <span class="hljs-keyword">return</span> Type;
}();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-215" id="section-215"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> ScalarType = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_Type</span>) </span>{
  (<span class="hljs-number">0</span>, _inheritsLoose2[<span class="hljs-string">"default"</span>])(ScalarType, _Type);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ScalarType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> _Type.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) || <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-keyword">return</span> ScalarType;
}(Type);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-216" id="section-216"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> EnumType = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_Type2</span>) </span>{
  (<span class="hljs-number">0</span>, _inheritsLoose2[<span class="hljs-string">"default"</span>])(EnumType, _Type2);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EnumType</span>(<span class="hljs-params">name, values, isClient</span>) </span>{
    <span class="hljs-keyword">var</span> _this;

    _this = _Type2.call(<span class="hljs-keyword">this</span>, name, isClient) || <span class="hljs-keyword">this</span>;
    _this.values = values;
    <span class="hljs-keyword">return</span> _this;
  }

  <span class="hljs-keyword">return</span> EnumType;
}(Type);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-217" id="section-217"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> UnionType = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_Type3</span>) </span>{
  (<span class="hljs-number">0</span>, _inheritsLoose2[<span class="hljs-string">"default"</span>])(UnionType, _Type3);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UnionType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> _Type3.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) || <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-keyword">return</span> UnionType;
}(Type);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-218" id="section-218"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> ObjectType = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_Type4</span>) </span>{
  (<span class="hljs-number">0</span>, _inheritsLoose2[<span class="hljs-string">"default"</span>])(ObjectType, _Type4);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ObjectType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> _Type4.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) || <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-keyword">return</span> ObjectType;
}(Type);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-219" id="section-219"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> InputObjectType = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_Type5</span>) </span>{
  (<span class="hljs-number">0</span>, _inheritsLoose2[<span class="hljs-string">"default"</span>])(InputObjectType, _Type5);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InputObjectType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> _Type5.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) || <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-keyword">return</span> InputObjectType;
}(Type);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-220" id="section-220"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> InterfaceType = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_Type6</span>) </span>{
  (<span class="hljs-number">0</span>, _inheritsLoose2[<span class="hljs-string">"default"</span>])(InterfaceType, _Type6);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InterfaceType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> _Type6.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>) || <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-keyword">return</span> InterfaceType;
}(Type);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-221" id="section-221"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> List = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">this</span>.ofType = type;
    <span class="hljs-keyword">this</span>._typeString = <span class="hljs-string">"["</span>.concat(<span class="hljs-built_in">String</span>(<span class="hljs-keyword">this</span>.ofType), <span class="hljs-string">"]"</span>);
  }

  <span class="hljs-keyword">var</span> _proto2 = List.prototype;

  _proto2.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toString</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._typeString;
  };

  _proto2.toJSON = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toJSON</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toString();
  };

  <span class="hljs-keyword">return</span> List;
}();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-222" id="section-222"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> NonNull = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NonNull</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">this</span>.ofType = type;
    <span class="hljs-keyword">this</span>._typeString = <span class="hljs-string">""</span>.concat(<span class="hljs-built_in">String</span>(<span class="hljs-keyword">this</span>.ofType), <span class="hljs-string">"!"</span>);
  }

  <span class="hljs-keyword">var</span> _proto3 = NonNull.prototype;

  _proto3.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toString</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._typeString;
  };

  _proto3.toJSON = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toJSON</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.toString();
  };

  <span class="hljs-keyword">return</span> NonNull;
}();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-223" id="section-223"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> Field = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Field</span>(<span class="hljs-params">schema, name, type, belongsTo, args, directives, isClient</span>) </span>{
  <span class="hljs-keyword">this</span>.name = name;
  <span class="hljs-keyword">this</span>.type = type;
  <span class="hljs-keyword">this</span>.belongsTo = belongsTo;
  <span class="hljs-keyword">this</span>.isClient = isClient;
  <span class="hljs-keyword">this</span>.args = parseInputArgumentDefinitionsMap(schema, args);
  <span class="hljs-keyword">this</span>.directives = directives;
};
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-224" id="section-224"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unwrap</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> NonNull || type <span class="hljs-keyword">instanceof</span> List) {
    <span class="hljs-keyword">return</span> unwrap(type.ofType);
  }

  <span class="hljs-keyword">return</span> type;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-225" id="section-225"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasConcreteTypeThatImplements</span>(<span class="hljs-params">schema, type, interfaceType</span>) </span>{
  <span class="hljs-keyword">return</span> _isAbstractType(type) &amp;&amp; getConcreteTypes(schema, type).some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">concreteType</span>) </span>{
    <span class="hljs-keyword">return</span> schema.implementsInterface(schema.assertCompositeType(concreteType), interfaceType);
  });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-226" id="section-226"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getConcreteTypes</span>(<span class="hljs-params">schema, type</span>) </span>{
  <span class="hljs-keyword">var</span> concreteTypes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
  schema.getPossibleTypes(type).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">possibleType</span>) </span>{
    <span class="hljs-keyword">if</span> (_isObject(possibleType)) {
      concreteTypes.add(possibleType);
    }
  });
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(concreteTypes);
}

<span class="hljs-keyword">var</span> TYPENAME_FIELD = <span class="hljs-string">'__typename'</span>;
<span class="hljs-keyword">var</span> CLIENT_ID_FIELD = <span class="hljs-string">'__id'</span>;
<span class="hljs-keyword">var</span> QUERY_TYPE_KEY = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'Query'</span>);
<span class="hljs-keyword">var</span> MUTATION_TYPE_KEY = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'Mutation'</span>);
<span class="hljs-keyword">var</span> SUBSCRIPTION_TYPE_KEY = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'Subscription'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isScalar</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> ScalarType;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isObject</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> ObjectType;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isEnum</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> EnumType;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isUnion</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> UnionType;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isInputObject</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> InputObjectType;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isInterface</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> InterfaceType;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isWrapper</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> List || type <span class="hljs-keyword">instanceof</span> NonNull;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBaseType</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> ScalarType || type <span class="hljs-keyword">instanceof</span> ObjectType || type <span class="hljs-keyword">instanceof</span> EnumType || type <span class="hljs-keyword">instanceof</span> UnionType || type <span class="hljs-keyword">instanceof</span> InputObjectType || type <span class="hljs-keyword">instanceof</span> InterfaceType;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isAbstractType</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> UnionType || type <span class="hljs-keyword">instanceof</span> InterfaceType;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isCompositeType</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> ObjectType || type <span class="hljs-keyword">instanceof</span> UnionType || type <span class="hljs-keyword">instanceof</span> InterfaceType;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_isInputType</span>(<span class="hljs-params">type</span>) </span>{
  <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> InputObjectType || type <span class="hljs-keyword">instanceof</span> ScalarType || type <span class="hljs-keyword">instanceof</span> EnumType;
}

<span class="hljs-keyword">var</span> Schema = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-227" id="section-227"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Schema</span>(<span class="hljs-params">typeMap</span>) </span>{
    <span class="hljs-keyword">var</span> _this2 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">this</span>._typeMap = typeMap;
    <span class="hljs-keyword">this</span>._typeWrappersMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">this</span>._fieldsMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">this</span>._typeNameMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">this</span>._clientIdMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">this</span>._directiveMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(typeMap.getDirectives().map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> [directive.name, {
        <span class="hljs-attr">locations</span>: directive.locations,
        <span class="hljs-attr">args</span>: parseInputArgumentDefinitions(_this2, directive.args),
        <span class="hljs-attr">name</span>: directive.name,
        <span class="hljs-attr">isClient</span>: directive.isClient
      }];
    }));
  }

  <span class="hljs-keyword">var</span> _proto4 = Schema.prototype;

  _proto4.getTypes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTypes</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._typeMap.getTypes();
  };

  _proto4.getTypeFromAST = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTypeFromAST</span>(<span class="hljs-params">typeNode</span>) </span>{
    <span class="hljs-keyword">if</span> (typeNode.kind === <span class="hljs-string">'NonNullType'</span>) {
      <span class="hljs-keyword">var</span> innerType = <span class="hljs-keyword">this</span>.getTypeFromAST(typeNode.type);

      <span class="hljs-keyword">if</span> (!innerType) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (innerType <span class="hljs-keyword">instanceof</span> NonNull) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Unable to wrap non-nullable type with non-null wrapper.'</span>);
      }

      <span class="hljs-keyword">var</span> cacheKey = <span class="hljs-string">""</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(innerType), <span class="hljs-string">"!"</span>);

      <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">this</span>._typeWrappersMap.get(cacheKey);

      <span class="hljs-keyword">if</span> (type) {
        <span class="hljs-keyword">return</span> type;
      }

      type = <span class="hljs-keyword">new</span> NonNull(innerType);

      <span class="hljs-keyword">this</span>._typeWrappersMap.set(cacheKey, type);

      <span class="hljs-keyword">return</span> type;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (typeNode.kind === <span class="hljs-string">'ListType'</span>) {
      <span class="hljs-keyword">var</span> _innerType = <span class="hljs-keyword">this</span>.getTypeFromAST(typeNode.type);

      <span class="hljs-keyword">if</span> (!_innerType) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> _cacheKey = <span class="hljs-string">"["</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(_innerType), <span class="hljs-string">"]"</span>);

      <span class="hljs-keyword">var</span> _type = <span class="hljs-keyword">this</span>._typeWrappersMap.get(_cacheKey);

      <span class="hljs-keyword">if</span> (_type) {
        <span class="hljs-keyword">return</span> _type;
      }

      _type = <span class="hljs-keyword">new</span> List(_innerType);

      <span class="hljs-keyword">this</span>._typeWrappersMap.set(_cacheKey, _type);

      <span class="hljs-keyword">return</span> _type;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._typeMap.getTypeByName(typeNode.name.value);
  };

  _proto4._getRawType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_getRawType</span>(<span class="hljs-params">typeName</span>) </span>{
    <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">this</span>._typeWrappersMap.get(typeName);

    <span class="hljs-keyword">if</span> (type) {
      <span class="hljs-keyword">return</span> type;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> typeName === <span class="hljs-string">'string'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getTypeFromAST(parseType(typeName));
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> operationType;

      <span class="hljs-keyword">if</span> (typeName === QUERY_TYPE_KEY) {
        operationType = <span class="hljs-keyword">this</span>._typeMap.getQueryType();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (typeName === MUTATION_TYPE_KEY) {
        operationType = <span class="hljs-keyword">this</span>._typeMap.getMutationType();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (typeName === SUBSCRIPTION_TYPE_KEY) {
        operationType = <span class="hljs-keyword">this</span>._typeMap.getSubscriptionType();
      }

      <span class="hljs-keyword">if</span> (operationType <span class="hljs-keyword">instanceof</span> ObjectType) {
        <span class="hljs-keyword">return</span> operationType;
      }
    }
  };

  _proto4.getTypeFromString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTypeFromString</span>(<span class="hljs-params">typeName</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._getRawType(typeName);
  };

  _proto4.expectTypeFromString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectTypeFromString</span>(<span class="hljs-params">typeName</span>) </span>{
    <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">this</span>.getTypeFromString(typeName);

    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unknown type: '"</span>.concat(typeName, <span class="hljs-string">"'."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.expectTypeFromAST = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectTypeFromAST</span>(<span class="hljs-params">ast</span>) </span>{
    <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">this</span>.getTypeFromAST(ast);

    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unknown type: '"</span>.concat(print(ast), <span class="hljs-string">"'."</span>), <span class="hljs-literal">null</span>, [ast]);
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.getNonNullType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNonNullType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> NonNull) {
      <span class="hljs-keyword">return</span> type;
    }

    <span class="hljs-keyword">var</span> cacheKey = <span class="hljs-string">""</span>.concat(<span class="hljs-built_in">String</span>(type), <span class="hljs-string">"!"</span>);

    <span class="hljs-keyword">var</span> nonNullType = <span class="hljs-keyword">this</span>._typeWrappersMap.get(cacheKey);

    <span class="hljs-keyword">if</span> (nonNullType) {
      <span class="hljs-keyword">return</span> nonNullType;
    }

    nonNullType = <span class="hljs-keyword">new</span> NonNull(type);

    <span class="hljs-keyword">this</span>._typeWrappersMap.set(cacheKey, nonNullType);

    <span class="hljs-keyword">return</span> nonNullType;
  };

  _proto4.getRawType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRawType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> unwrap(type);
  };

  _proto4.getNullableType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNullableType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> NonNull) {
      <span class="hljs-keyword">return</span> type.ofType;
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.getListItemType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getListItemType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> List) {
      <span class="hljs-keyword">return</span> type.ofType;
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.mapListItemType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapListItemType</span>(<span class="hljs-params">type, mapper</span>) </span>{
    <span class="hljs-keyword">if</span> (!(type <span class="hljs-keyword">instanceof</span> List)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Expected List type'</span>);
    }

    <span class="hljs-keyword">var</span> innerType = mapper(type.ofType);
    <span class="hljs-keyword">var</span> cacheKey = <span class="hljs-string">"["</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(innerType), <span class="hljs-string">"]"</span>);

    <span class="hljs-keyword">var</span> newType = <span class="hljs-keyword">this</span>._typeWrappersMap.get(cacheKey);

    <span class="hljs-keyword">if</span> (newType) {
      <span class="hljs-keyword">return</span> newType;
    }

    newType = <span class="hljs-keyword">new</span> List(innerType);

    <span class="hljs-keyword">this</span>._typeWrappersMap.set(cacheKey, newType);

    <span class="hljs-keyword">return</span> newType;
  };

  _proto4.areEqualTypes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">areEqualTypes</span>(<span class="hljs-params">typeA, typeB</span>) </span>{
    <span class="hljs-keyword">if</span> (typeA === typeB) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (typeA <span class="hljs-keyword">instanceof</span> NonNull &amp;&amp; typeB <span class="hljs-keyword">instanceof</span> NonNull) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.areEqualTypes(typeA.ofType, typeB.ofType);
    }

    <span class="hljs-keyword">if</span> (typeA <span class="hljs-keyword">instanceof</span> List &amp;&amp; typeB <span class="hljs-keyword">instanceof</span> List) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.areEqualTypes(typeA.ofType, typeB.ofType);
    }

    <span class="hljs-keyword">if</span> (isBaseType(typeA) &amp;&amp; isBaseType(typeB)) {
      <span class="hljs-keyword">return</span> typeA.name === typeB.name;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-228" id="section-228"></a>
</div>
<div class="dox">
<div class="summary">
<p>Determine if the given type may implement the named type:</p>
<ul>
<li>it is the named type</li>
<li>it implements the named interface</li>
<li>it is an abstract type and <em>some</em> of its concrete types may
implement the named type</li>
</ul>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  ;

  _proto4.mayImplement = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mayImplement</span>(<span class="hljs-params">type, interfaceType</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.areEqualTypes(type, interfaceType) || <span class="hljs-keyword">this</span>.implementsInterface(type, interfaceType) || <span class="hljs-keyword">this</span>.isAbstractType(type) &amp;&amp; hasConcreteTypeThatImplements(<span class="hljs-keyword">this</span>, type, interfaceType);
  };

  _proto4.implementsInterface = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">implementsInterface</span>(<span class="hljs-params">type, interfaceType</span>) </span>{
    <span class="hljs-keyword">var</span> _this3 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getInterfaces(type).some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">typeInterface</span>) </span>{
      <span class="hljs-keyword">return</span> _this3.areEqualTypes(typeInterface, interfaceType);
    });
  };

  _proto4.canHaveSelections = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canHaveSelections</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isObject(type) || <span class="hljs-keyword">this</span>.isInterface(type);
  };

  _proto4.getTypeString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTypeString</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> type.toString();
  };

  _proto4.isTypeSubTypeOf = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTypeSubTypeOf</span>(<span class="hljs-params">maybeSubType, superType</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-229" id="section-229"></a>
</div>
<p>Equivalent type is a valid subtype</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (maybeSubType === superType) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-comment">// If superType is non-null, maybeSubType must also be non-null.</span>


    <span class="hljs-keyword">if</span> (superType <span class="hljs-keyword">instanceof</span> NonNull) {
      <span class="hljs-keyword">if</span> (maybeSubType <span class="hljs-keyword">instanceof</span> NonNull) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isTypeSubTypeOf(maybeSubType.ofType, superType.ofType);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (maybeSubType <span class="hljs-keyword">instanceof</span> NonNull) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-230" id="section-230"></a>
</div>
<p>If superType is nullable, maybeSubType may be non-null or nullable.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isTypeSubTypeOf(maybeSubType.ofType, superType);
    } <span class="hljs-comment">// If superType type is a list, maybeSubType type must also be a list.</span>


    <span class="hljs-keyword">if</span> (superType <span class="hljs-keyword">instanceof</span> List) {
      <span class="hljs-keyword">if</span> (maybeSubType <span class="hljs-keyword">instanceof</span> List) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isTypeSubTypeOf(maybeSubType.ofType, superType.ofType);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (maybeSubType <span class="hljs-keyword">instanceof</span> List) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-231" id="section-231"></a>
</div>
<p>If superType is not a list, maybeSubType must also be not a list.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-comment">// If superType type is an abstract type, maybeSubType type may be a currently</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-232" id="section-232"></a>
</div>
<p>possible object type.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isAbstractType(superType) &amp;&amp; <span class="hljs-keyword">this</span>.isObject(maybeSubType) &amp;&amp; <span class="hljs-keyword">this</span>.isPossibleType(<span class="hljs-keyword">this</span>.assertAbstractType(superType), <span class="hljs-keyword">this</span>.assertObjectType(maybeSubType))) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-comment">// Otherwise, maybeSubType is not a valid subtype of the superType.</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-233" id="section-233"></a>
</div>
<div class="dox">
<div class="summary">
<p>Provided two composite types, determine if they &quot;overlap&quot;. Two composite
types overlap when the Sets of possible concrete types for each intersect.</p>
</div>
<div class="body">
<p>This is often used to determine if a fragment of a given type could possibly
be visited in a context of another type.</p>
<p>This function is commutative.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  ;

  _proto4.doTypesOverlap = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doTypesOverlap</span>(<span class="hljs-params">typeA, typeB</span>) </span>{
    <span class="hljs-keyword">var</span> _this4 = <span class="hljs-keyword">this</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-234" id="section-234"></a>
</div>
<p>Equivalent types overlap</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (typeA === typeB) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (_isAbstractType(typeA)) {
      <span class="hljs-keyword">if</span> (_isAbstractType(typeB)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-235" id="section-235"></a>
</div>
<p>If both types are abstract, then determine if there is any intersection
between possible concrete types of each.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">this</span>.getPossibleTypes(typeA)).some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
          <span class="hljs-keyword">if</span> (_isObject(type)) {
            <span class="hljs-keyword">return</span> _this4.isPossibleType(typeB, type);
          }
        });
      } <span class="hljs-comment">// Determine if the latter type is a possible concrete type of the former.</span>


      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isPossibleType(typeA, typeB);
    }

    <span class="hljs-keyword">if</span> (_isAbstractType(typeB)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-236" id="section-236"></a>
</div>
<p>Determine if the former type is a possible concrete type of the latter.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isPossibleType(typeB, typeA);
    } <span class="hljs-comment">// Otherwise the types do not overlap.</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  _proto4.isPossibleType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPossibleType</span>(<span class="hljs-params">superType, maybeSubType</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._typeMap.getPossibleTypeSet(superType).has(maybeSubType);
  };

  _proto4.assertScalarFieldType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertScalarFieldType</span>(<span class="hljs-params">type</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-237" id="section-237"></a>
</div>
<p>Scalar type fields can be wrappers / or can be scalars/enums</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (_isWrapper(type) &amp;&amp; !_isScalar(unwrap(type)) &amp;&amp; !_isEnum(unwrap(type)) || !_isWrapper(type) &amp;&amp; !_isScalar(type) &amp;&amp; !_isEnum(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-built_in">String</span>(type), <span class="hljs-string">" to be a Scalar or Enum type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertLinkedFieldType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertLinkedFieldType</span>(<span class="hljs-params">type</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-238" id="section-238"></a>
</div>
<p>Linked Field types can be wrappers / or can be composite types</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (_isWrapper(type) &amp;&amp; !_isCompositeType(unwrap(type)) || !_isWrapper(type) &amp;&amp; !_isCompositeType(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-built_in">String</span>(type), <span class="hljs-string">" to be a Object, Interface or a Union Type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertInputType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertInputType</span>(<span class="hljs-params">type</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-239" id="section-239"></a>
</div>
<p>Input type fields can be wrappers / or can be scalars/enums</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">if</span> (_isWrapper(type) &amp;&amp; !_isInputType(unwrap(type)) || !_isWrapper(type) &amp;&amp; !_isInputType(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-built_in">String</span>(type), <span class="hljs-string">" to be a Input, Scalar or Enum type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.asCompositeType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asCompositeType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (_isCompositeType(type)) {
      <span class="hljs-keyword">return</span> type;
    }
  };

  _proto4.asInputType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asInputType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (_isWrapper(type) &amp;&amp; _isInputType(unwrap(type)) || !_isWrapper(type) &amp;&amp; _isInputType(type)) {
      <span class="hljs-keyword">return</span> type;
    }
  };

  _proto4.asScalarFieldType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asScalarFieldType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (_isScalar(type) || _isEnum(type)) {
      <span class="hljs-keyword">return</span> type;
    }
  };

  _proto4.assertScalarType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertScalarType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isScalar(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">" to be a scalar type, got "</span>).concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">"."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertObjectType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertObjectType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isObject(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">" to be an object type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertInputObjectType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertInputObjectType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isInputObject(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">" to be an input type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.asInputObjectType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asInputObjectType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isInputObject(type)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertInterfaceType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertInterfaceType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isInterface(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">" to be an interface type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertCompositeType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertCompositeType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isCompositeType(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">" to be a composite type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertAbstractType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertAbstractType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isAbstractType(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">" to be an abstract type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertLeafType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertLeafType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isLeafType(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">" to be a leaf type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertUnionType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertUnionType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isUnion(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">" to be a union type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertEnumType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertEnumType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isEnum(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-built_in">String</span>(type), <span class="hljs-string">" to be an enum type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertIntType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertIntType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isScalar(type) || !<span class="hljs-keyword">this</span>.isInt(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-built_in">String</span>(type), <span class="hljs-string">" to be an 'Int' type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertFloatType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertFloatType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isScalar(type) || !<span class="hljs-keyword">this</span>.isFloat(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">" to be a 'Float' type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertBooleanType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertBooleanType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isScalar(type) || !<span class="hljs-keyword">this</span>.isBoolean(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">" to be a 'Boolean' type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertStringType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertStringType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isScalar(type) || !<span class="hljs-keyword">this</span>.isString(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">" to be a 'String' type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.assertIdType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertIdType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!_isScalar(type) || !<span class="hljs-keyword">this</span>.isId(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Expected "</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">" to be an ID type."</span>));
    }

    <span class="hljs-keyword">return</span> type;
  };

  _proto4.expectBooleanType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectBooleanType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.assertScalarType(<span class="hljs-keyword">this</span>.expectTypeFromString(<span class="hljs-string">'Boolean'</span>));
  };

  _proto4.expectIntType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectIntType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.assertScalarType(<span class="hljs-keyword">this</span>.expectTypeFromString(<span class="hljs-string">'Int'</span>));
  };

  _proto4.expectFloatType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectFloatType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.assertScalarType(<span class="hljs-keyword">this</span>.expectTypeFromString(<span class="hljs-string">'Float'</span>));
  };

  _proto4.expectStringType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectStringType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.assertScalarType(<span class="hljs-keyword">this</span>.expectTypeFromString(<span class="hljs-string">'String'</span>));
  };

  _proto4.expectIdType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectIdType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.assertScalarType(<span class="hljs-keyword">this</span>.expectTypeFromString(<span class="hljs-string">'ID'</span>));
  };

  _proto4.getQueryType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getQueryType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> queryType = <span class="hljs-keyword">this</span>._getRawType(QUERY_TYPE_KEY);

    <span class="hljs-keyword">if</span> (queryType &amp;&amp; _isObject(queryType)) {
      <span class="hljs-keyword">return</span> queryType;
    }
  };

  _proto4.getMutationType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMutationType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> mutationType = <span class="hljs-keyword">this</span>._getRawType(MUTATION_TYPE_KEY);

    <span class="hljs-keyword">if</span> (mutationType &amp;&amp; _isObject(mutationType)) {
      <span class="hljs-keyword">return</span> mutationType;
    }
  };

  _proto4.getSubscriptionType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSubscriptionType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> subscriptionType = <span class="hljs-keyword">this</span>._getRawType(SUBSCRIPTION_TYPE_KEY);

    <span class="hljs-keyword">if</span> (subscriptionType &amp;&amp; _isObject(subscriptionType)) {
      <span class="hljs-keyword">return</span> subscriptionType;
    }
  };

  _proto4.expectQueryType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectQueryType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> queryType = <span class="hljs-keyword">this</span>.getQueryType();

    <span class="hljs-keyword">if</span> (queryType == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Query type is not defined on the Schema'</span>);
    }

    <span class="hljs-keyword">return</span> queryType;
  };

  _proto4.expectMutationType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectMutationType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> mutationType = <span class="hljs-keyword">this</span>.getMutationType();

    <span class="hljs-keyword">if</span> (mutationType == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Mutation type is not defined the Schema'</span>);
    }

    <span class="hljs-keyword">return</span> mutationType;
  };

  _proto4.expectSubscriptionType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectSubscriptionType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> subscriptionType = <span class="hljs-keyword">this</span>.getSubscriptionType();

    <span class="hljs-keyword">if</span> (subscriptionType == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Subscription type is not defined the Schema'</span>);
    }

    <span class="hljs-keyword">return</span> subscriptionType;
  };

  _proto4.isNonNull = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNonNull</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> NonNull;
  };

  _proto4.isList = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isList</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> type <span class="hljs-keyword">instanceof</span> List;
  };

  _proto4.isWrapper = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isWrapper</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> _isWrapper(type);
  };

  _proto4.isScalar = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isScalar</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> _isScalar(type);
  };

  _proto4.isObject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> _isObject(type);
  };

  _proto4.isEnum = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEnum</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> _isEnum(type);
  };

  _proto4.isUnion = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUnion</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> _isUnion(type);
  };

  _proto4.isInputObject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInputObject</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> _isInputObject(type);
  };

  _proto4.isInterface = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInterface</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> _isInterface(type);
  };

  _proto4.isInputType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInputType</span>(<span class="hljs-params">type</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-240" id="section-240"></a>
</div>
<p>Wrappers can be input types (so it's save to check unwrapped type here)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> _isInputType(type) || _isWrapper(type) &amp;&amp; _isInputType(unwrap(type));
  };

  _proto4.isCompositeType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isCompositeType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> _isCompositeType(type);
  };

  _proto4.isAbstractType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAbstractType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> _isAbstractType(type);
  };

  _proto4.isLeafType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLeafType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isScalar(type) || <span class="hljs-keyword">this</span>.isEnum(type);
  };

  _proto4.isId = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isId</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ScalarType) {
      <span class="hljs-keyword">return</span> type.name === <span class="hljs-string">'ID'</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  _proto4.isInt = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isInt</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ScalarType) {
      <span class="hljs-keyword">return</span> type.name === <span class="hljs-string">'Int'</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  _proto4.isFloat = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFloat</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ScalarType) {
      <span class="hljs-keyword">return</span> type.name === <span class="hljs-string">'Float'</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  _proto4.isBoolean = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBoolean</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ScalarType) {
      <span class="hljs-keyword">return</span> type.name === <span class="hljs-string">'Boolean'</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  _proto4.isString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isString</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ScalarType) {
      <span class="hljs-keyword">return</span> type.name === <span class="hljs-string">'String'</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  _proto4.hasField = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasField</span>(<span class="hljs-params">type, fieldName</span>) </span>{
    <span class="hljs-keyword">var</span> canHaveTypename = <span class="hljs-keyword">this</span>.isObject(type) || <span class="hljs-keyword">this</span>.isAbstractType(type); <span class="hljs-comment">// Special case for __typename field</span>

    <span class="hljs-keyword">if</span> (canHaveTypename &amp;&amp; (fieldName === TYPENAME_FIELD || fieldName === CLIENT_ID_FIELD)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ObjectType || type <span class="hljs-keyword">instanceof</span> InterfaceType) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._typeMap.getField(type, fieldName) != <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> InputObjectType) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._typeMap.getInputField(type, fieldName) != <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  _proto4.hasId = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasId</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hasField(type, <span class="hljs-string">'id'</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> idField = <span class="hljs-keyword">this</span>.expectField(type, <span class="hljs-string">'id'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.areEqualTypes(<span class="hljs-keyword">this</span>.getNullableType(<span class="hljs-keyword">this</span>.getFieldType(idField)), <span class="hljs-keyword">this</span>.expectIdType());
  };

  _proto4.getFields = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFields</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">var</span> fieldsMap = <span class="hljs-keyword">this</span>._getFieldsMap(type);

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(fieldsMap.values());
  };

  _proto4._getFieldsMap = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_getFieldsMap</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">var</span> cachedMap = <span class="hljs-keyword">this</span>._fieldsMap.get(type);

    <span class="hljs-keyword">if</span> (cachedMap != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> cachedMap;
    }

    <span class="hljs-keyword">var</span> fieldsMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ObjectType || type <span class="hljs-keyword">instanceof</span> InterfaceType) {
      <span class="hljs-keyword">var</span> fields = <span class="hljs-keyword">this</span>._typeMap.getFieldMap(type);

      <span class="hljs-keyword">if</span> (fields) {
        <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(fields),
            _step;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
            <span class="hljs-keyword">var</span> _step$value = _step.value,
                fieldName = _step$value[<span class="hljs-number">0</span>],
                fieldDefinition = _step$value[<span class="hljs-number">1</span>];
            <span class="hljs-keyword">var</span> fieldType = <span class="hljs-keyword">this</span>.expectTypeFromAST(fieldDefinition.type);
            fieldsMap.set(fieldName, <span class="hljs-keyword">new</span> Field(<span class="hljs-keyword">this</span>, fieldName, fieldType, <span class="hljs-keyword">this</span>.assertCompositeType(type), fieldDefinition.arguments, fieldDefinition.directives, fieldDefinition.isClient));
          }
        } <span class="hljs-keyword">catch</span> (err) {
          _iterator.e(err);
        } <span class="hljs-keyword">finally</span> {
          _iterator.f();
        }
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> InputObjectType) {
      <span class="hljs-keyword">var</span> _fields = <span class="hljs-keyword">this</span>._typeMap.getInputFieldMap(type);

      <span class="hljs-keyword">if</span> (_fields) {
        <span class="hljs-keyword">var</span> _iterator2 = _createForOfIteratorHelper(_fields),
            _step2;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">for</span> (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            <span class="hljs-keyword">var</span> _step2$value = _step2.value,
                _fieldName = _step2$value[<span class="hljs-number">0</span>],
                typeNode = _step2$value[<span class="hljs-number">1</span>];

            <span class="hljs-keyword">var</span> _fieldType = <span class="hljs-keyword">this</span>.expectTypeFromAST(typeNode);

            fieldsMap.set(_fieldName, <span class="hljs-keyword">new</span> Field(<span class="hljs-keyword">this</span>, _fieldName, _fieldType, type, [], <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>));
          }
        } <span class="hljs-keyword">catch</span> (err) {
          _iterator2.e(err);
        } <span class="hljs-keyword">finally</span> {
          _iterator2.f();
        }
      }
    }

    <span class="hljs-keyword">if</span> (fieldsMap.size === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"_getFieldsMap: Type '"</span>.concat(type.name, <span class="hljs-string">"' should have fields."</span>));
    }

    <span class="hljs-keyword">this</span>._fieldsMap.set(type, fieldsMap);

    <span class="hljs-keyword">return</span> fieldsMap;
  };

  _proto4.getFieldByName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldByName</span>(<span class="hljs-params">type, fieldName</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hasField(type, fieldName)) {
      <span class="hljs-keyword">return</span>;
    } <span class="hljs-comment">// A "special" case for __typename and __id fields - which should</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-241" id="section-241"></a>
</div>
<p>not be in the list of type fields, but should be fine to select</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

    <span class="hljs-keyword">if</span> (fieldName === TYPENAME_FIELD) {
      <span class="hljs-keyword">var</span> typename = <span class="hljs-keyword">this</span>._typeNameMap.get(type);

      <span class="hljs-keyword">if</span> (!typename) {
        typename = <span class="hljs-keyword">new</span> Field(<span class="hljs-keyword">this</span>, TYPENAME_FIELD, <span class="hljs-keyword">this</span>.getNonNullType(<span class="hljs-keyword">this</span>.expectStringType()), type, [], <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);

        <span class="hljs-keyword">this</span>._typeNameMap.set(type, typename);
      }

      <span class="hljs-keyword">return</span> typename;
    }

    <span class="hljs-keyword">if</span> (fieldName === CLIENT_ID_FIELD) {
      <span class="hljs-keyword">var</span> clientId = <span class="hljs-keyword">this</span>._clientIdMap.get(type);

      <span class="hljs-keyword">if</span> (!clientId) {
        clientId = <span class="hljs-keyword">new</span> Field(<span class="hljs-keyword">this</span>, CLIENT_ID_FIELD, <span class="hljs-keyword">this</span>.getNonNullType(<span class="hljs-keyword">this</span>.expectIdType()), type, [], <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);

        <span class="hljs-keyword">this</span>._clientIdMap.set(type, clientId);
      }

      <span class="hljs-keyword">return</span> clientId;
    }

    <span class="hljs-keyword">if</span> (_isUnion(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unexpected union type '"</span>.concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">"' in the 'getFieldByName(...)'. Expected type with fields"</span>));
    }

    <span class="hljs-keyword">var</span> fieldsMap = <span class="hljs-keyword">this</span>._getFieldsMap(type);

    <span class="hljs-keyword">return</span> fieldsMap.get(fieldName);
  };

  _proto4.expectField = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expectField</span>(<span class="hljs-params">type, fieldName</span>) </span>{
    <span class="hljs-keyword">var</span> field = <span class="hljs-keyword">this</span>.getFieldByName(type, fieldName);

    <span class="hljs-keyword">if</span> (!field) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unknown field '"</span>.concat(fieldName, <span class="hljs-string">"' on type '"</span>).concat(<span class="hljs-keyword">this</span>.getTypeString(type), <span class="hljs-string">"'."</span>));
    }

    <span class="hljs-keyword">return</span> field;
  };

  _proto4.getFieldConfig = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldConfig</span>(<span class="hljs-params">field</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">type</span>: field.type,
      <span class="hljs-attr">args</span>: <span class="hljs-built_in">Array</span>.from(field.args.values())
    };
  };

  _proto4.getFieldName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldName</span>(<span class="hljs-params">field</span>) </span>{
    <span class="hljs-keyword">return</span> field.name;
  };

  _proto4.getFieldType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldType</span>(<span class="hljs-params">field</span>) </span>{
    <span class="hljs-keyword">return</span> field.type;
  };

  _proto4.getFieldParentType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldParentType</span>(<span class="hljs-params">field</span>) </span>{
    <span class="hljs-keyword">return</span> field.belongsTo;
  };

  _proto4.getFieldArgs = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldArgs</span>(<span class="hljs-params">field</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(field.args.values());
  };

  _proto4.getFieldArgByName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldArgByName</span>(<span class="hljs-params">field, argName</span>) </span>{
    <span class="hljs-keyword">return</span> field.args.get(argName);
  };

  _proto4.getEnumValues = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEnumValues</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> type.values;
  };

  _proto4.getUnionTypes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUnionTypes</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">this</span>._typeMap.getPossibleTypeSet(type));
  };

  _proto4.getInterfaces = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInterfaces</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ObjectType) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._typeMap.getInterfaces(type);
    }

    <span class="hljs-keyword">return</span> [];
  };

  _proto4.getPossibleTypes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPossibleTypes</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._typeMap.getPossibleTypeSet(type);
  };

  _proto4.getFetchableFieldName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFetchableFieldName</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._typeMap.getFetchableFieldName(type);
  };

  _proto4.parseLiteral = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseLiteral</span>(<span class="hljs-params">type, valueNode</span>) </span>{
    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> EnumType &amp;&amp; valueNode.kind === <span class="hljs-string">'EnumValue'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parseValue(type, valueNode.value);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ScalarType) {
      <span class="hljs-keyword">if</span> (valueNode.kind === <span class="hljs-string">'BooleanValue'</span> &amp;&amp; type.name === <span class="hljs-string">'Boolean'</span>) {
        <span class="hljs-keyword">return</span> GraphQLBoolean.parseLiteral(valueNode);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueNode.kind === <span class="hljs-string">'FloatValue'</span> &amp;&amp; type.name === <span class="hljs-string">'Float'</span>) {
        <span class="hljs-keyword">return</span> GraphQLFloat.parseLiteral(valueNode);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueNode.kind === <span class="hljs-string">'IntValue'</span> &amp;&amp; (type.name === <span class="hljs-string">'Int'</span> || type.name === <span class="hljs-string">'ID'</span> || type.name === <span class="hljs-string">'Float'</span>)) {
        <span class="hljs-keyword">return</span> GraphQLInt.parseLiteral(valueNode);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueNode.kind === <span class="hljs-string">'StringValue'</span> &amp;&amp; (type.name === <span class="hljs-string">'String'</span> || type.name === <span class="hljs-string">'ID'</span>)) {
        <span class="hljs-keyword">return</span> GraphQLString.parseLiteral(valueNode);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isDefaultScalar(type.name)) {
        <span class="hljs-keyword">return</span> valueFromASTUntyped(valueNode);
      }
    }
  };

  _proto4.parseValue = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseValue</span>(<span class="hljs-params">type, value</span>) </span>{
    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> EnumType) {
      <span class="hljs-keyword">return</span> type.values.includes(value) ? value : <span class="hljs-literal">undefined</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ScalarType) {
      <span class="hljs-keyword">switch</span> (type.name) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'Boolean'</span>:
          <span class="hljs-keyword">return</span> GraphQLBoolean.parseValue(value);

        <span class="hljs-keyword">case</span> <span class="hljs-string">'Float'</span>:
          <span class="hljs-keyword">return</span> GraphQLFloat.parseValue(value);

        <span class="hljs-keyword">case</span> <span class="hljs-string">'Int'</span>:
          <span class="hljs-keyword">return</span> GraphQLInt.parseValue(value);

        <span class="hljs-keyword">case</span> <span class="hljs-string">'String'</span>:
          <span class="hljs-keyword">return</span> GraphQLString.parseValue(value);

        <span class="hljs-keyword">case</span> <span class="hljs-string">'ID'</span>:
          <span class="hljs-keyword">return</span> GraphQLID.parseValue(value);

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> value;
      }
    }
  };

  _proto4.serialize = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serialize</span>(<span class="hljs-params">type, value</span>) </span>{
    <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> EnumType) {
      <span class="hljs-keyword">return</span> type.values.includes(value) ? value : <span class="hljs-literal">undefined</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> ScalarType) {
      <span class="hljs-keyword">switch</span> (type.name) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'Boolean'</span>:
          <span class="hljs-keyword">return</span> GraphQLBoolean.serialize(value);

        <span class="hljs-keyword">case</span> <span class="hljs-string">'Float'</span>:
          <span class="hljs-keyword">return</span> GraphQLFloat.serialize(value);

        <span class="hljs-keyword">case</span> <span class="hljs-string">'Int'</span>:
          <span class="hljs-keyword">return</span> GraphQLInt.serialize(value);

        <span class="hljs-keyword">case</span> <span class="hljs-string">'String'</span>:
          <span class="hljs-keyword">return</span> GraphQLString.serialize(value);

        <span class="hljs-keyword">case</span> <span class="hljs-string">'ID'</span>:
          <span class="hljs-keyword">return</span> GraphQLID.serialize(value);

        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> value;
      }
    }
  };

  _proto4.getDirectives = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDirectives</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">this</span>._directiveMap.values());
  };

  _proto4.getDirective = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDirective</span>(<span class="hljs-params">directiveName</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._directiveMap.get(directiveName);
  };

  _proto4.isServerType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isServerType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">var</span> unwrapped = unwrap(type);
    <span class="hljs-keyword">return</span> unwrapped.isClient === <span class="hljs-literal">false</span>;
  };

  _proto4.isServerField = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isServerField</span>(<span class="hljs-params">field</span>) </span>{
    <span class="hljs-keyword">return</span> field.isClient === <span class="hljs-literal">false</span>;
  };

  _proto4.isServerDirective = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isServerDirective</span>(<span class="hljs-params">directiveName</span>) </span>{
    <span class="hljs-keyword">var</span> directive = <span class="hljs-keyword">this</span>._directiveMap.get(directiveName);

    <span class="hljs-keyword">return</span> (directive === <span class="hljs-literal">null</span> || directive === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : directive.isClient) === <span class="hljs-literal">false</span>;
  };

  _proto4.isServerDefinedField = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isServerDefinedField</span>(<span class="hljs-params">type, field</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isAbstractType(type) &amp;&amp; field.directives.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref</span>) </span>{
      <span class="hljs-keyword">var</span> name = _ref.name;
      <span class="hljs-keyword">return</span> name === <span class="hljs-string">'fixme_fat_interface'</span>;
    }) || <span class="hljs-keyword">this</span>.hasField(type, field.name) &amp;&amp; <span class="hljs-keyword">this</span>.isServerField(<span class="hljs-keyword">this</span>.expectField(type, field.name));
  };

  _proto4.isClientDefinedField = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isClientDefinedField</span>(<span class="hljs-params">type, field</span>) </span>{
    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.isServerDefinedField(type, field);
  };

  _proto4.extend = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>(<span class="hljs-params">extensions</span>) </span>{
    <span class="hljs-keyword">var</span> doc = <span class="hljs-built_in">Array</span>.isArray(extensions) ? parse(extensions.join(<span class="hljs-string">'\n'</span>)) : extensions;
    <span class="hljs-keyword">var</span> schemaExtensions = [];
    doc.definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
      <span class="hljs-keyword">if</span> (isSchemaDefinitionAST(definition)) {
        schemaExtensions.push(definition);
      }
    });

    <span class="hljs-keyword">if</span> (schemaExtensions.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Schema(<span class="hljs-keyword">this</span>._typeMap.extend(schemaExtensions));
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-keyword">return</span> Schema;
}();

<span class="hljs-keyword">var</span> TypeMap = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TypeMap</span>(<span class="hljs-params">source, extensions</span>) </span>{
    <span class="hljs-keyword">this</span>._types = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">'ID'</span>, <span class="hljs-keyword">new</span> ScalarType(<span class="hljs-string">'ID'</span>, <span class="hljs-literal">false</span>)], [<span class="hljs-string">'String'</span>, <span class="hljs-keyword">new</span> ScalarType(<span class="hljs-string">'String'</span>, <span class="hljs-literal">false</span>)], [<span class="hljs-string">'Boolean'</span>, <span class="hljs-keyword">new</span> ScalarType(<span class="hljs-string">'Boolean'</span>, <span class="hljs-literal">false</span>)], [<span class="hljs-string">'Float'</span>, <span class="hljs-keyword">new</span> ScalarType(<span class="hljs-string">'Float'</span>, <span class="hljs-literal">false</span>)], [<span class="hljs-string">'Int'</span>, <span class="hljs-keyword">new</span> ScalarType(<span class="hljs-string">'Int'</span>, <span class="hljs-literal">false</span>)]]);
    <span class="hljs-keyword">this</span>._typeInterfaces = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">this</span>._unionTypes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">this</span>._interfaceImplementations = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">this</span>._fields = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">this</span>._inputFields = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">this</span>._directives = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">'include'</span>, {
      <span class="hljs-attr">name</span>: <span class="hljs-string">'include'</span>,
      <span class="hljs-attr">isClient</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">locations</span>: [<span class="hljs-string">'FIELD'</span>, <span class="hljs-string">'FRAGMENT_SPREAD'</span>, <span class="hljs-string">'INLINE_FRAGMENT'</span>],
      <span class="hljs-attr">args</span>: [{
        <span class="hljs-attr">name</span>: <span class="hljs-string">'if'</span>,
        <span class="hljs-attr">typeNode</span>: parseType(<span class="hljs-string">'Boolean!'</span>),
        <span class="hljs-attr">defaultValue</span>: <span class="hljs-literal">undefined</span>
      }]
    }], [<span class="hljs-string">'skip'</span>, {
      <span class="hljs-attr">name</span>: <span class="hljs-string">'skip'</span>,
      <span class="hljs-attr">isClient</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">locations</span>: [<span class="hljs-string">'FIELD'</span>, <span class="hljs-string">'FRAGMENT_SPREAD'</span>, <span class="hljs-string">'INLINE_FRAGMENT'</span>],
      <span class="hljs-attr">args</span>: [{
        <span class="hljs-attr">name</span>: <span class="hljs-string">'if'</span>,
        <span class="hljs-attr">typeNode</span>: parseType(<span class="hljs-string">'Boolean!'</span>),
        <span class="hljs-attr">defaultValue</span>: <span class="hljs-literal">undefined</span>
      }]
    }], [<span class="hljs-string">'deprecated'</span>, {
      <span class="hljs-attr">name</span>: <span class="hljs-string">'deprecated'</span>,
      <span class="hljs-attr">isClient</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">locations</span>: [<span class="hljs-string">'FIELD_DEFINITION'</span>, <span class="hljs-string">'ENUM_VALUE'</span>],
      <span class="hljs-attr">args</span>: [{
        <span class="hljs-attr">name</span>: <span class="hljs-string">'reason'</span>,
        <span class="hljs-attr">typeNode</span>: parseType(<span class="hljs-string">'String'</span>),
        <span class="hljs-attr">defaultValue</span>: {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'StringValue'</span>,
          <span class="hljs-attr">value</span>: <span class="hljs-string">'No longer supported'</span>
        }
      }]
    }]]);
    <span class="hljs-keyword">this</span>._queryTypeName = <span class="hljs-string">'Query'</span>;
    <span class="hljs-keyword">this</span>._mutationTypeName = <span class="hljs-string">'Mutation'</span>;
    <span class="hljs-keyword">this</span>._subscriptionTypeName = <span class="hljs-string">'Subscription'</span>;
    <span class="hljs-keyword">this</span>._source = source;
    <span class="hljs-keyword">this</span>._extensions = extensions;
    <span class="hljs-keyword">this</span>._fetchable = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

    <span class="hljs-keyword">this</span>._parse(source);

    <span class="hljs-keyword">this</span>._extend(extensions);
  }

  <span class="hljs-keyword">var</span> _proto5 = TypeMap.prototype;

  _proto5._parse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_parse</span>(<span class="hljs-params">source</span>) </span>{
    <span class="hljs-keyword">var</span> _this5 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> <span class="hljs-built_in">document</span> = parse(source, {
      <span class="hljs-attr">noLocation</span>: <span class="hljs-literal">true</span>
    });
    <span class="hljs-built_in">document</span>.definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
      <span class="hljs-keyword">switch</span> (definition.kind) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'SchemaDefinition'</span>:
          {
            _this5._parseSchemaDefinition(definition);

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">'ScalarTypeDefinition'</span>:
          {
            _this5._parseScalarNode(definition, <span class="hljs-literal">false</span>);

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">'EnumTypeDefinition'</span>:
          {
            _this5._parseEnumNode(definition, <span class="hljs-literal">false</span>);

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">'ObjectTypeDefinition'</span>:
          {
            _this5._parseObjectTypeNode(definition, <span class="hljs-literal">false</span>);

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">'InputObjectTypeDefinition'</span>:
          {
            _this5._parseInputObjectTypeNode(definition, <span class="hljs-literal">false</span>);

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">'UnionTypeDefinition'</span>:
          {
            _this5._parseUnionNode(definition, <span class="hljs-literal">false</span>);

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">'InterfaceTypeDefinition'</span>:
          {
            _this5._parseInterfaceNode(definition, <span class="hljs-literal">false</span>);

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">'DirectiveDefinition'</span>:
          {
            _this5._parseDirective(definition, <span class="hljs-literal">false</span>);

            <span class="hljs-keyword">break</span>;
          }
      }
    });
  };

  _proto5._parseSchemaDefinition = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_parseSchemaDefinition</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">var</span> _this6 = <span class="hljs-keyword">this</span>;

    node.operationTypes.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">operationType</span>) </span>{
      <span class="hljs-keyword">switch</span> (operationType.operation) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'query'</span>:
          _this6._queryTypeName = operationType.type.name.value;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'mutation'</span>:
          _this6._mutationTypeName = operationType.type.name.value;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'subscription'</span>:
          _this6._subscriptionTypeName = operationType.type.name.value;
          <span class="hljs-keyword">break</span>;
      }
    });
  };

  _proto5._parseScalarNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_parseScalarNode</span>(<span class="hljs-params">node, isClient</span>) </span>{
    <span class="hljs-keyword">var</span> name = node.name.value;

    <span class="hljs-keyword">if</span> (!isDefaultScalar(name) &amp;&amp; <span class="hljs-keyword">this</span>._types.has(name)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"_parseScalarNode: Duplicate definition for type "</span>.concat(name, <span class="hljs-string">"."</span>), <span class="hljs-literal">null</span>, [node]);
    }

    <span class="hljs-keyword">this</span>._types.set(name, <span class="hljs-keyword">new</span> ScalarType(name, isClient));
  };

  _proto5._parseEnumNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_parseEnumNode</span>(<span class="hljs-params">node, isClient</span>) </span>{
    <span class="hljs-keyword">var</span> name = node.name.value;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._types.has(name)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"_parseEnumNode: Duplicate definition for type "</span>.concat(name, <span class="hljs-string">"."</span>), <span class="hljs-literal">null</span>, [node]);
    } <span class="hljs-comment">// SDL doesn't have information about the actual ENUM values</span>


    <span class="hljs-keyword">var</span> values = node.values ? node.values.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
      <span class="hljs-keyword">return</span> value.name.value;
    }) : [];

    <span class="hljs-keyword">this</span>._types.set(name, <span class="hljs-keyword">new</span> EnumType(name, values, isClient));
  };

  _proto5._parseObjectTypeNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_parseObjectTypeNode</span>(<span class="hljs-params">node, isClient</span>) </span>{
    <span class="hljs-keyword">var</span> _this7 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> _this$_types$<span class="hljs-keyword">get</span>;

    var name = node.name.value; // Objects may be created by _parseUnionNode

    var type = (_this$_types$<span class="hljs-keyword">get</span> = this._types.<span class="hljs-keyword">get</span>(name)) !== null &amp;&amp; _this$_types$<span class="hljs-keyword">get</span> !== void 0 ? _this$_types$<span class="hljs-keyword">get</span> : new ObjectType(name, isClient);

    if (!(type instanceof ObjectType)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"_parseObjectTypeNode: Expected object type, got "</span>.concat(<span class="hljs-built_in">String</span>(type)), <span class="hljs-literal">null</span>, [node]);
    }

    <span class="hljs-keyword">if</span> (type.isClient !== isClient) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"_parseObjectTypeNode: Cannot create object type '"</span>.concat(name, <span class="hljs-string">"' defined as a client type."</span>), <span class="hljs-literal">null</span>, [node]);
    }

    <span class="hljs-keyword">var</span> typeInterfaces = [];
    node.interfaces &amp;&amp; node.interfaces.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">interfaceTypeNode</span>) </span>{
      <span class="hljs-keyword">var</span> _this$_interfaceImple;

      <span class="hljs-keyword">var</span> interfaceName = interfaceTypeNode.name.value;

      <span class="hljs-keyword">var</span> interfaceType = _this7._types.get(interfaceName);

      <span class="hljs-keyword">if</span> (!interfaceType) {
        interfaceType = <span class="hljs-keyword">new</span> InterfaceType(interfaceName, isClient);

        _this7._types.set(interfaceName, interfaceType);
      }

      <span class="hljs-keyword">if</span> (!(interfaceType <span class="hljs-keyword">instanceof</span> InterfaceType)) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'_parseObjectTypeNode: Expected interface type'</span>, <span class="hljs-literal">null</span>, [interfaceTypeNode]);
      }

      <span class="hljs-keyword">var</span> implementations = (_this$_interfaceImple = _this7._interfaceImplementations.get(interfaceType)) !== <span class="hljs-literal">null</span> &amp;&amp; _this$_interfaceImple !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _this$_interfaceImple : <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
      implementations.add(type);

      _this7._interfaceImplementations.set(interfaceType, implementations);

      typeInterfaces.push(interfaceType);
    });
    <span class="hljs-keyword">var</span> fetchable = <span class="hljs-literal">null</span>;
    node.directives &amp;&amp; node.directives.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directiveNode</span>) </span>{
      <span class="hljs-keyword">if</span> (directiveNode.name.value === <span class="hljs-string">'fetchable'</span>) {
        <span class="hljs-keyword">var</span> field_name_arg = directiveNode.arguments &amp;&amp; directiveNode.arguments.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
          <span class="hljs-keyword">return</span> arg.name.value === <span class="hljs-string">'field_name'</span>;
        });

        <span class="hljs-keyword">if</span> (field_name_arg != <span class="hljs-literal">null</span> &amp;&amp; field_name_arg.value.kind === <span class="hljs-string">'StringValue'</span>) {
          fetchable = {
            <span class="hljs-attr">field_name</span>: field_name_arg.value.value
          };
        }
      }
    });

    <span class="hljs-keyword">this</span>._typeInterfaces.set(type, typeInterfaces);

    <span class="hljs-keyword">this</span>._types.set(name, type);

    <span class="hljs-keyword">if</span> (fetchable != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">this</span>._fetchable.set(type, fetchable);
    }

    node.fields &amp;&amp; <span class="hljs-keyword">this</span>._handleTypeFieldsStrict(type, node.fields, isClient);
  };

  _proto5._parseInputObjectTypeNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_parseInputObjectTypeNode</span>(<span class="hljs-params">node, isClient</span>) </span>{
    <span class="hljs-keyword">var</span> name = node.name.value;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._types.has(name)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'_parseInputObjectTypeNode: Unable to parse schema file. Duplicate definition for object type'</span>, <span class="hljs-literal">null</span>, [node]);
    }

    <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">new</span> InputObjectType(name, isClient);

    <span class="hljs-keyword">this</span>._types.set(name, type);

    <span class="hljs-keyword">this</span>._parseInputObjectFields(type, node);
  };

  _proto5._parseUnionNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_parseUnionNode</span>(<span class="hljs-params">node, isClient</span>) </span>{
    <span class="hljs-keyword">var</span> _this8 = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> name = node.name.value;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._types.has(name)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'_parseUnionNode: Unable to parse schema file. Duplicate definition for object type'</span>, <span class="hljs-literal">null</span>, [node]);
    }

    <span class="hljs-keyword">var</span> union = <span class="hljs-keyword">new</span> UnionType(name, isClient);

    <span class="hljs-keyword">this</span>._types.set(name, union);

    <span class="hljs-keyword">this</span>._unionTypes.set(union, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(node.types ? node.types.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">typeInUnion</span>) </span>{
      <span class="hljs-keyword">var</span> _this$_types$get2;

      <span class="hljs-keyword">var</span> typeInUnionName = typeInUnion.name.value;
      <span class="hljs-keyword">var</span> object = (_this$_types$get2 = _this8._types.get(typeInUnionName)) !== <span class="hljs-literal">null</span> &amp;&amp; _this$_types$get2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _this$_types$get2 : <span class="hljs-keyword">new</span> ObjectType(typeInUnionName, <span class="hljs-literal">false</span>);

      <span class="hljs-keyword">if</span> (!(object <span class="hljs-keyword">instanceof</span> ObjectType)) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'_parseUnionNode: Expected object type'</span>, <span class="hljs-literal">null</span>, [typeInUnion]);
      }

      _this8._types.set(typeInUnionName, object);

      <span class="hljs-keyword">return</span> object;
    }) : []));
  };

  _proto5._parseInterfaceNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_parseInterfaceNode</span>(<span class="hljs-params">node, isClient</span>) </span>{
    <span class="hljs-keyword">var</span> name = node.name.value;

    <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">this</span>._types.get(name);

    <span class="hljs-keyword">if</span> (!type) {
      type = <span class="hljs-keyword">new</span> InterfaceType(name, isClient);

      <span class="hljs-keyword">this</span>._types.set(name, type);
    }

    <span class="hljs-keyword">if</span> (!(type <span class="hljs-keyword">instanceof</span> InterfaceType)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"_parseInterfaceNode: Expected interface type. Got "</span>.concat(<span class="hljs-built_in">String</span>(type)), <span class="hljs-literal">null</span>, [node]);
    }

    <span class="hljs-keyword">if</span> (type.isClient !== isClient) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"_parseInterfaceNode: Cannot create interface '"</span>.concat(name, <span class="hljs-string">"' defined as a client interface"</span>), <span class="hljs-literal">null</span>, [node]);
    }

    node.fields &amp;&amp; <span class="hljs-keyword">this</span>._handleTypeFieldsStrict(type, node.fields, isClient);
  };

  _proto5._handleTypeFieldsStrict = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_handleTypeFieldsStrict</span>(<span class="hljs-params">type, fields, isClient</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._fields.has(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'_handleTypeFieldsStrict: Unable to parse schema file. Duplicate definition for object type'</span>);
    }

    <span class="hljs-keyword">this</span>._handleTypeFields(type, fields, isClient);
  };

  _proto5._handleTypeFields = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_handleTypeFields</span>(<span class="hljs-params">type, fields, isClient</span>) </span>{
    <span class="hljs-keyword">var</span> _this$_fields$<span class="hljs-keyword">get</span>;

    var fieldsMap = (_this$_fields$<span class="hljs-keyword">get</span> = this._fields.<span class="hljs-keyword">get</span>(type)) !== null &amp;&amp; _this$_fields$<span class="hljs-keyword">get</span> !== void 0 ? _this$_fields$<span class="hljs-keyword">get</span> : new Map();
    fields.forEach(function (fieldNode) {
      <span class="hljs-keyword">var</span> fieldName = fieldNode.name.value;

      <span class="hljs-keyword">if</span> (fieldsMap.has(fieldName)) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"_handleTypeFields: Duplicate definition for field '"</span>.concat(fieldName, <span class="hljs-string">"'."</span>));
      }

      fieldsMap.set(fieldName, {
        <span class="hljs-attr">arguments</span>: fieldNode.arguments ? fieldNode.arguments.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">name</span>: arg.name.value,
            <span class="hljs-attr">typeNode</span>: arg.type,
            <span class="hljs-attr">defaultValue</span>: arg.defaultValue
          };
        }) : [],
        <span class="hljs-attr">directives</span>: fieldNode.directives ? fieldNode.directives.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">name</span>: directive.name.value,
            <span class="hljs-attr">args</span>: directive.arguments ? directive.arguments.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
              <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">name</span>: arg.name.value,
                <span class="hljs-attr">value</span>: arg.value
              };
            }) : []
          };
        }) : <span class="hljs-literal">null</span>,
        <span class="hljs-attr">type</span>: fieldNode.type,
        <span class="hljs-attr">isClient</span>: isClient
      });
    });

    <span class="hljs-keyword">this</span>._fields.set(type, fieldsMap);
  };

  _proto5._parseInputObjectFields = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_parseInputObjectFields</span>(<span class="hljs-params">type, node</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._inputFields.has(type)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'_parseInputObjectFields: Unable to parse schema file. Duplicate definition for type'</span>, <span class="hljs-literal">null</span>, [node]);
    }

    <span class="hljs-keyword">var</span> fields = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

    <span class="hljs-keyword">if</span> (node.fields) {
      node.fields.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fieldNode</span>) </span>{
        fields.set(fieldNode.name.value, fieldNode.type);
      });
    }

    <span class="hljs-keyword">this</span>._inputFields.set(type, fields);
  };

  _proto5._parseDirective = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_parseDirective</span>(<span class="hljs-params">node, isClient</span>) </span>{
    <span class="hljs-keyword">var</span> name = node.name.value;

    <span class="hljs-keyword">this</span>._directives.set(name, {
      <span class="hljs-attr">name</span>: name,
      <span class="hljs-attr">args</span>: node.arguments ? node.arguments.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">name</span>: arg.name.value,
          <span class="hljs-attr">typeNode</span>: arg.type,
          <span class="hljs-attr">defaultValue</span>: arg.defaultValue
        };
      }) : [],
      <span class="hljs-attr">locations</span>: node.locations.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">location</span>) </span>{
        <span class="hljs-keyword">switch</span> (location.value) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">'QUERY'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'MUTATION'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'SUBSCRIPTION'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'FIELD'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'FRAGMENT_DEFINITION'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'FRAGMENT_SPREAD'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'INLINE_FRAGMENT'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'VARIABLE_DEFINITION'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'SCHEMA'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'SCALAR'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'OBJECT'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'FIELD_DEFINITION'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'ARGUMENT_DEFINITION'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'INTERFACE'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'UNION'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'ENUM'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'ENUM_VALUE'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'INPUT_OBJECT'</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-string">'INPUT_FIELD_DEFINITION'</span>:
            <span class="hljs-keyword">return</span> location.value;

          <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Invalid directive location'</span>);
        }
      }),
      <span class="hljs-attr">isClient</span>: isClient
    });
  };

  _proto5._parseObjectTypeExtension = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_parseObjectTypeExtension</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">this</span>._types.get(node.name.value);

    <span class="hljs-keyword">if</span> (!(type <span class="hljs-keyword">instanceof</span> ObjectType)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"_parseObjectTypeExtension: Expected to find type with the name '"</span>.concat(node.name.value, <span class="hljs-string">"'"</span>), <span class="hljs-literal">null</span>, [node]);
    }

    node.fields &amp;&amp; <span class="hljs-keyword">this</span>._handleTypeFields(type, node.fields, <span class="hljs-literal">true</span>
    <span class="hljs-comment">/** client fields */</span>
    );
  };

  _proto5._parseInterfaceTypeExtension = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_parseInterfaceTypeExtension</span>(<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">var</span> type = <span class="hljs-keyword">this</span>._types.get(node.name.value);

    <span class="hljs-keyword">if</span> (!(type <span class="hljs-keyword">instanceof</span> InterfaceType)) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'_parseInterfaceTypeExtension: Expected to have an interface type'</span>);
    }

    node.fields &amp;&amp; <span class="hljs-keyword">this</span>._handleTypeFields(type, node.fields, <span class="hljs-literal">true</span>);
  };

  _proto5._extend = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_extend</span>(<span class="hljs-params">extensions</span>) </span>{
    <span class="hljs-keyword">var</span> _this9 = <span class="hljs-keyword">this</span>;

    extensions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
      <span class="hljs-keyword">if</span> (definition.kind === <span class="hljs-string">'ObjectTypeDefinition'</span>) {
        _this9._parseObjectTypeNode(definition, <span class="hljs-literal">true</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (definition.kind === <span class="hljs-string">'InterfaceTypeDefinition'</span>) {
        _this9._parseInterfaceNode(definition, <span class="hljs-literal">true</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (definition.kind === <span class="hljs-string">'ScalarTypeDefinition'</span>) {
        _this9._parseScalarNode(definition, <span class="hljs-literal">true</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (definition.kind === <span class="hljs-string">'EnumTypeDefinition'</span>) {
        _this9._parseEnumNode(definition, <span class="hljs-literal">true</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (definition.kind === <span class="hljs-string">'InterfaceTypeExtension'</span>) {
        _this9._parseInterfaceTypeExtension(definition);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (definition.kind === <span class="hljs-string">'ObjectTypeExtension'</span>) {
        _this9._parseObjectTypeExtension(definition);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (definition.kind === <span class="hljs-string">'DirectiveDefinition'</span>) {
        _this9._parseDirective(definition, <span class="hljs-literal">true</span>
        <span class="hljs-comment">/* client directive */</span>
        );
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unexpected extension kind: '"</span>.concat(definition.kind, <span class="hljs-string">"'"</span>), <span class="hljs-literal">null</span>, [definition]);
      }
    });
  };

  _proto5.getTypes = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTypes</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">this</span>._types.values());
  };

  _proto5.getTypeByName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTypeByName</span>(<span class="hljs-params">typename</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._types.get(typename);
  };

  _proto5.getInterfaces = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInterfaces</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">var</span> _this$_typeInterfaces;

    <span class="hljs-keyword">return</span> (_this$_typeInterfaces = <span class="hljs-keyword">this</span>._typeInterfaces.get(type)) !== <span class="hljs-literal">null</span> &amp;&amp; _this$_typeInterfaces !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _this$_typeInterfaces : [];
  };

  _proto5.getPossibleTypeSet = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPossibleTypeSet</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">set</span>;

    if (type instanceof InterfaceType) {
      <span class="hljs-keyword">var</span> _this$_interfaceImple2;

      <span class="hljs-keyword">set</span> = (_this$_interfaceImple2 = this._interfaceImplementations.<span class="hljs-keyword">get</span>(type)) !== null &amp;&amp; _this$_interfaceImple2 !== void 0 ? _this$_interfaceImple2 : new Set();
    } else if (type instanceof UnionType) {
      <span class="hljs-keyword">var</span> _this$_unionTypes$<span class="hljs-keyword">get</span>;

      <span class="hljs-keyword">set</span> = (_this$_unionTypes$<span class="hljs-keyword">get</span> = this._unionTypes.<span class="hljs-keyword">get</span>(type)) !== null &amp;&amp; _this$_unionTypes$<span class="hljs-keyword">get</span> !== void 0 ? _this$_unionTypes$<span class="hljs-keyword">get</span> : new Set();
    } else {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Invalid type supplied to "getPossibleTypeSet"'</span>);
    }

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">set</span>) {
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Unable to find possible types for "</span>.concat(type.name));
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">set</span>;
  };

  _proto5.getFetchableFieldName = function getFetchableFieldName(type) {
    <span class="hljs-keyword">var</span> _this$_fetchable$<span class="hljs-keyword">get</span>$, _this$_fetchable$<span class="hljs-keyword">get</span>;

    return (_this$_fetchable$<span class="hljs-keyword">get</span>$ = (_this$_fetchable$<span class="hljs-keyword">get</span> = this._fetchable.<span class="hljs-keyword">get</span>(type)) === null || _this$_fetchable$<span class="hljs-keyword">get</span> === void 0 ? void 0 : _this$_fetchable$<span class="hljs-keyword">get</span>.field_name) !== null &amp;&amp; _this$_fetchable$<span class="hljs-keyword">get</span>$ !== void 0 ? _this$_fetchable$<span class="hljs-keyword">get</span>$ : null;
  };

  _proto5.getQueryType = function getQueryType() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._types.get(<span class="hljs-keyword">this</span>._queryTypeName);
  };

  _proto5.getMutationType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMutationType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._types.get(<span class="hljs-keyword">this</span>._mutationTypeName);
  };

  _proto5.getSubscriptionType = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSubscriptionType</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._types.get(<span class="hljs-keyword">this</span>._subscriptionTypeName);
  };

  _proto5.getField = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getField</span>(<span class="hljs-params">type, fieldName</span>) </span>{
    <span class="hljs-keyword">var</span> fields = <span class="hljs-keyword">this</span>._fields.get(type);

    <span class="hljs-keyword">if</span> (fields) {
      <span class="hljs-keyword">return</span> fields.get(fieldName);
    }
  };

  _proto5.getFieldMap = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFieldMap</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._fields.get(type);
  };

  _proto5.getInputField = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInputField</span>(<span class="hljs-params">type, fieldName</span>) </span>{
    <span class="hljs-keyword">var</span> inputFields = <span class="hljs-keyword">this</span>._inputFields.get(type);

    <span class="hljs-keyword">if</span> (inputFields) {
      <span class="hljs-keyword">return</span> inputFields.get(fieldName);
    }
  };

  _proto5.getInputFieldMap = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInputFieldMap</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._inputFields.get(type);
  };

  _proto5.getDirectives = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDirectives</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">this</span>._directives.values());
  };

  _proto5.extend = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>(<span class="hljs-params">extensions</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TypeMap(<span class="hljs-keyword">this</span>._source, <span class="hljs-keyword">this</span>._extensions.concat(extensions));
  };

  <span class="hljs-keyword">return</span> TypeMap;
}();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">baseSchema, schemaExtensionDocuments, schemaExtensions</span>) </span>{
  <span class="hljs-keyword">var</span> extensions = [];
  schemaExtensions &amp;&amp; schemaExtensions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) </span>{
    <span class="hljs-keyword">var</span> doc = parse(source, {
      <span class="hljs-attr">noLocation</span>: <span class="hljs-literal">true</span>
    });
    doc.definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
      <span class="hljs-keyword">if</span> (isSchemaDefinitionAST(definition)) {
        extensions.push(definition);
      }
    });
  });
  schemaExtensionDocuments &amp;&amp; schemaExtensionDocuments.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
    doc.definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
      <span class="hljs-keyword">if</span> (isSchemaDefinitionAST(definition)) {
        extensions.push(definition);
      }
    });
  });
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Schema(<span class="hljs-keyword">new</span> TypeMap(baseSchema, extensions));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseInputArgumentDefinitions</span>(<span class="hljs-params">schema, args</span>) </span>{
  <span class="hljs-keyword">return</span> args.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">var</span> argType = schema.assertInputType(schema.expectTypeFromAST(arg.typeNode));
    <span class="hljs-keyword">var</span> defaultValue;
    <span class="hljs-keyword">var</span> defaultValueNode = arg.defaultValue;

    <span class="hljs-keyword">if</span> (defaultValueNode != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> nullableType = schema.getNullableType(argType);
      <span class="hljs-keyword">var</span> isNullable = schema.isNonNull(argType) === <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">if</span> (isNullable &amp;&amp; defaultValueNode.kind === <span class="hljs-string">'NullValue'</span>) {
        defaultValue = <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (nullableType <span class="hljs-keyword">instanceof</span> ScalarType || nullableType <span class="hljs-keyword">instanceof</span> EnumType) {
          defaultValue = schema.parseLiteral(nullableType, defaultValueNode);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nullableType <span class="hljs-keyword">instanceof</span> List &amp;&amp; defaultValueNode.kind === <span class="hljs-string">'ListValue'</span> || nullableType <span class="hljs-keyword">instanceof</span> InputObjectType &amp;&amp; defaultValueNode.kind === <span class="hljs-string">'ObjectValue'</span>) {
          defaultValue = valueFromASTUntyped(defaultValueNode);
        }
      }

      <span class="hljs-keyword">if</span> (defaultValue === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"parseInputArgumentDefinitions: Unexpected default value: "</span>.concat(<span class="hljs-built_in">String</span>(defaultValueNode), <span class="hljs-string">". Expected to have a value of type "</span>).concat(<span class="hljs-built_in">String</span>(nullableType), <span class="hljs-string">"."</span>));
      }
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">name</span>: arg.name,
      <span class="hljs-attr">type</span>: argType,
      <span class="hljs-attr">defaultValue</span>: defaultValue
    };
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseInputArgumentDefinitionsMap</span>(<span class="hljs-params">schema, args</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(parseInputArgumentDefinitions(schema, args).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> [arg.name, arg];
  }));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDefaultScalar</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'ID'</span>, <span class="hljs-string">'String'</span>, <span class="hljs-string">'Boolean'</span>, <span class="hljs-string">'Int'</span>, <span class="hljs-string">'Float'</span>]).has(name);
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">create</span>: create
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 58 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/runtime/helpers/inheritsLoose"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 59 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-242" id="section-242"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> chalk = __webpack_require__(<span class="hljs-number">60</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMemoryUsageString</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> chalk.blue(<span class="hljs-built_in">Math</span>.round(process.memoryUsage().heapUsed / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">'Mb'</span>);
}

<span class="hljs-keyword">var</span> ConsoleReporter = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ConsoleReporter</span>(<span class="hljs-params">options</span>) </span>{
    <span class="hljs-keyword">this</span>._verbose = options.verbose;
    <span class="hljs-keyword">this</span>._quiet = options.quiet;
  }

  <span class="hljs-keyword">var</span> _proto = ConsoleReporter.prototype;

  _proto.reportMessage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reportMessage</span>(<span class="hljs-params">message</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._quiet) {
      process.stdout.write(message + <span class="hljs-string">'\n'</span>);
    }
  };

  _proto.reportTime = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reportTime</span>(<span class="hljs-params">name, ms</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._verbose &amp;&amp; !<span class="hljs-keyword">this</span>._quiet) {
      <span class="hljs-keyword">var</span> time = ms === <span class="hljs-number">0</span> ? chalk.gray(<span class="hljs-string">' &lt;1ms'</span>) : ms &lt; <span class="hljs-number">1000</span> ? chalk.blue(leftPad(<span class="hljs-number">5</span>, ms + <span class="hljs-string">'ms'</span>)) : chalk.red(<span class="hljs-built_in">Math</span>.floor(ms / <span class="hljs-number">10</span>) / <span class="hljs-number">100</span> + <span class="hljs-string">'s'</span>);
      process.stdout.write(<span class="hljs-string">'  '</span> + time + <span class="hljs-string">' '</span> + chalk.gray(name) + <span class="hljs-string">' ['</span> + getMemoryUsageString() + <span class="hljs-string">']\n'</span>);
    }
  };

  _proto.reportError = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reportError</span>(<span class="hljs-params">caughtLocation, error</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._quiet) {
      process.stdout.write(chalk.red(<span class="hljs-string">'ERROR:\n'</span> + error.message + <span class="hljs-string">'\n'</span>));

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._verbose) {
        <span class="hljs-keyword">var</span> frames = error.stack.match(<span class="hljs-regexp">/^ {4}at .*$/gm</span>);

        <span class="hljs-keyword">if</span> (frames) {
          process.stdout.write(chalk.gray(<span class="hljs-string">'From: '</span> + caughtLocation + <span class="hljs-string">'\n'</span> + frames.join(<span class="hljs-string">'\n'</span>) + <span class="hljs-string">'\n'</span>));
        }
      }
    }
  };

  <span class="hljs-keyword">return</span> ConsoleReporter;
}();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">leftPad</span>(<span class="hljs-params">len, str</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len - str.length + <span class="hljs-number">1</span>).join(<span class="hljs-string">' '</span>) + str;
}

<span class="hljs-built_in">module</span>.exports = ConsoleReporter;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 60 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"chalk"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 61 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-243" id="section-243"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> ASTCache = __webpack_require__(<span class="hljs-number">27</span>);

<span class="hljs-keyword">var</span> fs = __webpack_require__(<span class="hljs-number">12</span>);

<span class="hljs-keyword">var</span> path = __webpack_require__(<span class="hljs-number">8</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">7</span>),
    parse = _require.parse,
    Source = _require.Source;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseFile</span>(<span class="hljs-params">baseDir, file</span>) </span>{
  <span class="hljs-keyword">var</span> text = fs.readFileSync(path.join(baseDir, file.relPath), <span class="hljs-string">'utf8'</span>);
  <span class="hljs-keyword">return</span> parse(<span class="hljs-keyword">new</span> Source(text, file.relPath), {
    <span class="hljs-attr">experimentalFragmentVariables</span>: <span class="hljs-literal">true</span>
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParser</span>(<span class="hljs-params">baseDir</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ASTCache({
    <span class="hljs-attr">baseDir</span>: baseDir,
    <span class="hljs-attr">parse</span>: parseFile
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">parseFile</span>: parseFile,
  <span class="hljs-attr">getParser</span>: getParser
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 62 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-244" id="section-244"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _asyncToGenerator = __webpack_require__(<span class="hljs-number">11</span>);

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> ASTConvert = __webpack_require__(<span class="hljs-number">63</span>);

<span class="hljs-keyword">var</span> CodegenDirectory = __webpack_require__(<span class="hljs-number">26</span>);

<span class="hljs-keyword">var</span> CompilerContext = __webpack_require__(<span class="hljs-number">23</span>);

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>);

<span class="hljs-keyword">var</span> RelayParser = __webpack_require__(<span class="hljs-number">28</span>);

<span class="hljs-keyword">var</span> compileRelayArtifacts = __webpack_require__(<span class="hljs-number">65</span>);

<span class="hljs-keyword">var</span> graphql = __webpack_require__(<span class="hljs-number">7</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> md5 = __webpack_require__(<span class="hljs-number">24</span>);

<span class="hljs-keyword">var</span> nullthrows = __webpack_require__(<span class="hljs-number">16</span>);

<span class="hljs-keyword">var</span> path = __webpack_require__(<span class="hljs-number">8</span>);

<span class="hljs-keyword">var</span> writeRelayGeneratedFile = __webpack_require__(<span class="hljs-number">70</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">74</span>),
    getReaderSourceDefinitionName = _require.getReaderSourceDefinitionName;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">9</span>),
    isExecutableDefinitionAST = _require2.isExecutableDefinitionAST;

<span class="hljs-keyword">var</span> _require3 = __webpack_require__(<span class="hljs-number">14</span>),
    ImmutableMap = _require3.Map;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileAll</span>(<span class="hljs-params">_ref</span>) </span>{
  <span class="hljs-keyword">var</span> baseDir = _ref.baseDir,
      baseDocuments = _ref.baseDocuments,
      schema = _ref.schema,
      compilerTransforms = _ref.compilerTransforms,
      documents = _ref.documents,
      reporter = _ref.reporter,
      typeGenerator = _ref.typeGenerator;
  <span class="hljs-keyword">var</span> definitions = ASTConvert.convertASTDocumentsWithBase(schema, baseDocuments, documents, RelayParser.transform);
  <span class="hljs-keyword">var</span> compilerContext = <span class="hljs-keyword">new</span> CompilerContext(schema).addAll(definitions);
  <span class="hljs-keyword">var</span> transformedTypeContext = compilerContext.applyTransforms(typeGenerator.transforms, reporter);
  <span class="hljs-keyword">var</span> transformedQueryContext = compilerContext.applyTransforms([].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(compilerTransforms.commonTransforms), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(compilerTransforms.queryTransforms)), reporter);
  <span class="hljs-keyword">var</span> artifacts = compileRelayArtifacts(compilerContext, compilerTransforms, reporter);
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">artifacts</span>: artifacts,
    <span class="hljs-attr">definitions</span>: definitions,
    <span class="hljs-attr">transformedQueryContext</span>: transformedQueryContext,
    <span class="hljs-attr">transformedTypeContext</span>: transformedTypeContext
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeAll</span>(<span class="hljs-params">_ref2</span>) </span>{
  <span class="hljs-keyword">var</span> writerConfig = _ref2.config,
      onlyValidate = _ref2.onlyValidate,
      baseDocuments = _ref2.baseDocuments,
      documents = _ref2.documents,
      schema = _ref2.schema,
      reporter = _ref2.reporter,
      sourceControl = _ref2.sourceControl,
      languagePlugin = _ref2.languagePlugin;
  <span class="hljs-keyword">return</span> Profiler.asyncContext(<span class="hljs-string">'RelayFileWriter.writeAll'</span>, <span class="hljs-comment">/*#__PURE__*/</span>_asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _compileAll = compileAll({
      <span class="hljs-attr">schema</span>: schema,
      <span class="hljs-attr">baseDir</span>: writerConfig.baseDir,
      <span class="hljs-attr">baseDocuments</span>: baseDocuments.valueSeq().toArray(),
      <span class="hljs-attr">compilerTransforms</span>: writerConfig.compilerTransforms,
      <span class="hljs-attr">documents</span>: documents.valueSeq().toArray(),
      <span class="hljs-attr">reporter</span>: reporter,
      <span class="hljs-attr">typeGenerator</span>: writerConfig.typeGenerator
    }),
        artifactsWithBase = _compileAll.artifacts,
        transformedTypeContext = _compileAll.transformedTypeContext,
        transformedQueryContext = _compileAll.transformedQueryContext; <span class="hljs-comment">// Build a context from all the documents</span>


    <span class="hljs-keyword">var</span> baseDefinitionNames = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    baseDocuments.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
      doc.definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">def</span>) </span>{
        <span class="hljs-keyword">if</span> (isExecutableDefinitionAST(def) &amp;&amp; def.name) {
          baseDefinitionNames.add(def.name.value);
        }
      });
    }); <span class="hljs-comment">// remove nodes that are present in the base or that derive from nodes</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-245" id="section-245"></a>
</div>
<p>in the base</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">var</span> artifacts = artifactsWithBase.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref3</span>) </span>{
      <span class="hljs-keyword">var</span> _definition = _ref3[<span class="hljs-number">0</span>],
          node = _ref3[<span class="hljs-number">1</span>];
      <span class="hljs-keyword">var</span> sourceName = getReaderSourceDefinitionName(node);
      <span class="hljs-keyword">return</span> !baseDefinitionNames.has(sourceName);
    });
    <span class="hljs-keyword">var</span> artifactMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(artifacts.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref4</span>) </span>{
      <span class="hljs-keyword">var</span> _definition = _ref4[<span class="hljs-number">0</span>],
          node = _ref4[<span class="hljs-number">1</span>];
      <span class="hljs-keyword">return</span> [node.kind === <span class="hljs-string">'Request'</span> ? node.params.name : node.name, node];
    }));
    <span class="hljs-keyword">var</span> definitionsMeta = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

    <span class="hljs-keyword">var</span> getDefinitionMeta = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDefinitionMeta</span>(<span class="hljs-params">definitionName</span>) </span>{
      <span class="hljs-keyword">var</span> artifact = nullthrows(artifactMap.get(definitionName));
      <span class="hljs-keyword">var</span> sourceName = getReaderSourceDefinitionName(artifact);
      <span class="hljs-keyword">var</span> definitionMeta = definitionsMeta.get(sourceName);
      !definitionMeta ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayFileWriter: Could not determine source for definition: `%s`.'</span>, definitionName) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> definitionMeta;
    };

    documents.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, filePath</span>) </span>{
      doc.definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">def</span>) </span>{
        <span class="hljs-keyword">if</span> (def.name) {
          definitionsMeta.set(def.name.value, {
            <span class="hljs-attr">dir</span>: path.join(writerConfig.baseDir, path.dirname(filePath)),
            <span class="hljs-attr">ast</span>: def
          });
        }
      });
    });
    <span class="hljs-keyword">var</span> allOutputDirectories = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

    <span class="hljs-keyword">var</span> addCodegenDir = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCodegenDir</span>(<span class="hljs-params">dirPath</span>) </span>{
      <span class="hljs-keyword">var</span> codegenDir = <span class="hljs-keyword">new</span> CodegenDirectory(dirPath, {
        <span class="hljs-attr">onlyValidate</span>: onlyValidate,
        <span class="hljs-attr">filesystem</span>: writerConfig.filesystem
      });
      allOutputDirectories.set(dirPath, codegenDir);
      <span class="hljs-keyword">return</span> codegenDir;
    };

    <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(writerConfig.generatedDirectories || []),
        _step;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
        <span class="hljs-keyword">var</span> existingDirectory = _step.value;
        addCodegenDir(existingDirectory);
      }
    } <span class="hljs-keyword">catch</span> (err) {
      _iterator.e(err);
    } <span class="hljs-keyword">finally</span> {
      _iterator.f();
    }

    <span class="hljs-keyword">var</span> configOutputDirectory;

    <span class="hljs-keyword">if</span> (writerConfig.outputDir) {
      configOutputDirectory = addCodegenDir(writerConfig.outputDir);
    }

    <span class="hljs-keyword">var</span> getGeneratedDirectory = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGeneratedDirectory</span>(<span class="hljs-params">definitionName</span>) </span>{
      <span class="hljs-keyword">if</span> (configOutputDirectory) {
        <span class="hljs-keyword">return</span> configOutputDirectory;
      }

      <span class="hljs-keyword">var</span> generatedPath = path.join(getDefinitionMeta(definitionName).dir, <span class="hljs-string">'__generated__'</span>);
      <span class="hljs-keyword">var</span> cachedDir = allOutputDirectories.get(generatedPath);

      <span class="hljs-keyword">if</span> (!cachedDir) {
        cachedDir = addCodegenDir(generatedPath);
      }

      <span class="hljs-keyword">return</span> cachedDir;
    };

    <span class="hljs-keyword">var</span> formatModule = Profiler.instrument(writerConfig.formatModule, <span class="hljs-string">'RelayFileWriter:formatModule'</span>);
    <span class="hljs-keyword">var</span> persistQuery = writerConfig.persistQuery ? Profiler.instrumentWait(writerConfig.persistQuery, <span class="hljs-string">'RelayFileWriter:persistQuery'</span>) : <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.all(artifacts.map( <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> _ref7 = _asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params">_ref5</span>) </span>{
          <span class="hljs-keyword">var</span> _writerConfig$repersi, _writerConfig$writeQu;

          <span class="hljs-keyword">var</span> definition = _ref5[<span class="hljs-number">0</span>],
              node = _ref5[<span class="hljs-number">1</span>];
          <span class="hljs-keyword">var</span> nodeName = node.kind === <span class="hljs-string">'Request'</span> ? node.params.name : node.name;

          <span class="hljs-keyword">if</span> (baseDefinitionNames.has(nodeName)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-246" id="section-246"></a>
</div>
<p>don't add definitions that were part of base context</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">var</span> typeNode = transformedTypeContext.get(nodeName);
          <span class="hljs-keyword">var</span> typeText = typeNode ? writerConfig.typeGenerator.generate(schema, typeNode, {
            <span class="hljs-attr">customScalars</span>: writerConfig.customScalars,
            <span class="hljs-attr">enumsHasteModule</span>: writerConfig.enumsHasteModule,
            <span class="hljs-attr">optionalInputFields</span>: writerConfig.optionalInputFieldsForFlow,
            <span class="hljs-attr">useHaste</span>: writerConfig.useHaste,
            <span class="hljs-attr">useSingleArtifactDirectory</span>: !!writerConfig.outputDir,
            <span class="hljs-attr">noFutureProofEnums</span>: writerConfig.noFutureProofEnums,
            <span class="hljs-attr">normalizationIR</span>: definition.kind === <span class="hljs-string">'Request'</span> ? definition.root : <span class="hljs-literal">undefined</span>
          }) : <span class="hljs-string">''</span>;
          <span class="hljs-keyword">var</span> sourceHash = Profiler.run(<span class="hljs-string">'hashGraphQL'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> md5(graphql.print(getDefinitionMeta(nodeName).ast));
          });
          <span class="hljs-keyword">yield</span> writeRelayGeneratedFile(schema, getGeneratedDirectory(nodeName), definition, node, formatModule, typeText, persistQuery, sourceHash, writerConfig.extension, writerConfig.printModuleDependency, (_writerConfig$repersi = writerConfig.repersist) !== <span class="hljs-literal">null</span> &amp;&amp; _writerConfig$repersi !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _writerConfig$repersi : <span class="hljs-literal">false</span>, (_writerConfig$writeQu = writerConfig.writeQueryParameters) !== <span class="hljs-literal">null</span> &amp;&amp; _writerConfig$writeQu !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _writerConfig$writeQu : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span>(<span class="hljs-params"></span>) </span>{}, languagePlugin);
        });

        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_x</span>) </span>{
          <span class="hljs-keyword">return</span> _ref7.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        };
      }()));
      <span class="hljs-keyword">var</span> generateExtraFiles = writerConfig.generateExtraFiles;

      <span class="hljs-keyword">if</span> (generateExtraFiles) {
        Profiler.run(<span class="hljs-string">'RelayFileWriter:generateExtraFiles'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
          <span class="hljs-keyword">var</span> configDirectory = writerConfig.outputDir;
          generateExtraFiles(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dir</span>) </span>{
            <span class="hljs-keyword">var</span> outputDirectory = dir || configDirectory;
            !outputDirectory ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayFileWriter: cannot generate extra files without specifying '</span> + <span class="hljs-string">'an outputDir in the config or passing it in.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">var</span> outputDir = allOutputDirectories.get(outputDirectory);

            <span class="hljs-keyword">if</span> (!outputDir) {
              outputDir = addCodegenDir(outputDirectory);
            }

            <span class="hljs-keyword">return</span> outputDir;
          }, transformedQueryContext, getGeneratedDirectory);
        });
      }

      allOutputDirectories.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">dir</span>) </span>{
        dir.deleteExtraFiles(languagePlugin === <span class="hljs-literal">null</span> || languagePlugin === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : languagePlugin.keepExtraFile);
      });

      <span class="hljs-keyword">if</span> (sourceControl &amp;&amp; !onlyValidate) {
        <span class="hljs-keyword">yield</span> CodegenDirectory.sourceControlAddRemove(sourceControl, <span class="hljs-built_in">Array</span>.from(allOutputDirectories.values()));
      }
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">var</span> details;

      <span class="hljs-keyword">try</span> {
        details = <span class="hljs-built_in">JSON</span>.parse(error.message);
      } <span class="hljs-keyword">catch</span> (_) {} <span class="hljs-comment">// eslint-disable-line lint/no-unused-catch-bindings</span>


      <span class="hljs-keyword">if</span> (details &amp;&amp; details.name === <span class="hljs-string">'GraphQL2Exception'</span> &amp;&amp; details.message) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'GraphQL error writing modules:\n'</span> + details.message);
      }

      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Error writing modules:\n'</span> + <span class="hljs-built_in">String</span>(error.stack || error));
    }

    <span class="hljs-keyword">return</span> allOutputDirectories;
  }));
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">writeAll</span>: writeAll
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 63 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-247" id="section-247"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">9</span>),
    isExecutableDefinitionAST = _require.isExecutableDefinitionAST,
    isSchemaDefinitionAST = _require.isSchemaDefinitionAST;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">7</span>),
    extendSchema = _require2.extendSchema,
    parse = _require2.parse,
    print = _require2.print,
    visit = _require2.visit;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertASTDocuments</span>(<span class="hljs-params">schema, documents, transform</span>) </span>{
  <span class="hljs-keyword">return</span> Profiler.run(<span class="hljs-string">'ASTConvert.convertASTDocuments'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> definitions = definitionsFromDocuments(documents);
    <span class="hljs-keyword">var</span> astDefinitions = [];
    documents.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
      doc.definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
        <span class="hljs-keyword">if</span> (isExecutableDefinitionAST(definition)) {
          astDefinitions.push(definition);
        }
      });
    });
    <span class="hljs-keyword">return</span> convertASTDefinitions(schema, definitions, transform);
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertASTDocumentsWithBase</span>(<span class="hljs-params">schema, baseDocuments, documents, transform</span>) </span>{
  <span class="hljs-keyword">return</span> Profiler.run(<span class="hljs-string">'ASTConvert.convertASTDocumentsWithBase'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> baseDefinitions = definitionsFromDocuments(baseDocuments);
    <span class="hljs-keyword">var</span> definitions = definitionsFromDocuments(documents);
    <span class="hljs-keyword">var</span> requiredDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">var</span> baseMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    baseDefinitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
      <span class="hljs-keyword">if</span> (isExecutableDefinitionAST(definition)) {
        <span class="hljs-keyword">var</span> definitionName = definition.name &amp;&amp; definition.name.value; <span class="hljs-comment">// If there's no name, no reason to put in the map</span>

        <span class="hljs-keyword">if</span> (definitionName != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (baseMap.has(definitionName)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Duplicate definition of '"</span>.concat(definitionName, <span class="hljs-string">"'."</span>));
          }

          baseMap.set(definitionName, definition);
        }
      }
    });
    <span class="hljs-keyword">var</span> definitionsToVisit = [];
    definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
      <span class="hljs-keyword">if</span> (isExecutableDefinitionAST(definition)) {
        definitionsToVisit.push(definition);
      }
    });

    <span class="hljs-keyword">while</span> (definitionsToVisit.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> definition = definitionsToVisit.pop();
      <span class="hljs-keyword">var</span> name = definition.name &amp;&amp; definition.name.value;

      <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">if</span> (requiredDefinitions.has(name)) {
        <span class="hljs-keyword">if</span> (requiredDefinitions.get(name) !== definition) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Duplicate definition of '"</span>.concat(name, <span class="hljs-string">"'."</span>));
        }

        <span class="hljs-keyword">continue</span>;
      }

      requiredDefinitions.set(name, definition);
      visit(definition, {
        <span class="hljs-attr">FragmentSpread</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FragmentSpread</span>(<span class="hljs-params">spread</span>) </span>{
          <span class="hljs-keyword">var</span> baseDefinition = baseMap.get(spread.name.value);

          <span class="hljs-keyword">if</span> (baseDefinition) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-248" id="section-248"></a>
</div>
<p>We only need to add those definitions not already included
in definitions</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">            definitionsToVisit.push(baseDefinition);
          }
        }
      });
    }

    <span class="hljs-keyword">var</span> definitionsToConvert = [];
    requiredDefinitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
      <span class="hljs-keyword">return</span> definitionsToConvert.push(definition);
    });
    <span class="hljs-keyword">return</span> convertASTDefinitions(schema, definitionsToConvert, transform);
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertASTDefinitions</span>(<span class="hljs-params">schema, definitions, transform</span>) </span>{
  <span class="hljs-keyword">var</span> operationDefinitions = [];
  definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
    <span class="hljs-keyword">if</span> (isExecutableDefinitionAST(definition)) {
      operationDefinitions.push(definition);
    }
  });
  <span class="hljs-keyword">return</span> transform(schema, operationDefinitions);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">definitionsFromDocuments</span>(<span class="hljs-params">documents</span>) </span>{
  <span class="hljs-keyword">var</span> definitions = [];
  documents.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
    doc.definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
      <span class="hljs-keyword">return</span> definitions.push(definition);
    });
  });
  <span class="hljs-keyword">return</span> definitions;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-249" id="section-249"></a>
</div>
<div class="dox">
<div class="summary">
<p>Extends a GraphQLSchema with a list of schema extensions in string form.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformASTSchema</span>(<span class="hljs-params">schema, schemaExtensions</span>) </span>{
  <span class="hljs-keyword">return</span> Profiler.run(<span class="hljs-string">'ASTConvert.transformASTSchema'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (schemaExtensions.length === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> schema;
    }

    <span class="hljs-keyword">var</span> extension = schemaExtensions.join(<span class="hljs-string">'\n'</span>);
    <span class="hljs-keyword">return</span> cachedExtend(schema, extension, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> extendSchema(schema, parse(extension));
    });
  });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-250" id="section-250"></a>
</div>
<div class="dox">
<div class="summary">
<p>Extends a GraphQLSchema with a list of schema extensions in AST form.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extendASTSchema</span>(<span class="hljs-params">baseSchema, documents</span>) </span>{
  <span class="hljs-keyword">return</span> Profiler.run(<span class="hljs-string">'ASTConvert.extendASTSchema'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> schemaExtensions = [];
    documents.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
      doc.definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
        <span class="hljs-keyword">if</span> (isSchemaDefinitionAST(definition)) {
          schemaExtensions.push(definition);
        }
      });
    });

    <span class="hljs-keyword">if</span> (schemaExtensions.length === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> baseSchema;
    }

    <span class="hljs-keyword">var</span> key = schemaExtensions.map(print).join(<span class="hljs-string">'\n'</span>);
    <span class="hljs-keyword">return</span> cachedExtend(baseSchema, key, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> extendSchema(baseSchema, {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Document'</span>,
        <span class="hljs-attr">definitions</span>: schemaExtensions
      }, <span class="hljs-comment">// TODO T24511737 figure out if this is dangerous</span>
      {
        <span class="hljs-attr">assumeValid</span>: <span class="hljs-literal">true</span>
      });
    });
  });
}

<span class="hljs-keyword">var</span> extendedSchemas = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cachedExtend</span>(<span class="hljs-params">schema, key, compute</span>) </span>{
  <span class="hljs-keyword">var</span> cache = extendedSchemas.get(schema);

  <span class="hljs-keyword">if</span> (!cache) {
    cache = {};
    extendedSchemas.set(schema, cache);
  }

  <span class="hljs-keyword">var</span> extendedSchema = cache[key];

  <span class="hljs-keyword">if</span> (!extendedSchema) {
    extendedSchema = compute();
    cache[key] = extendedSchema;
  }

  <span class="hljs-keyword">return</span> extendedSchema;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">convertASTDocuments</span>: convertASTDocuments,
  <span class="hljs-attr">convertASTDocumentsWithBase</span>: convertASTDocumentsWithBase,
  <span class="hljs-attr">extendASTSchema</span>: extendASTSchema,
  <span class="hljs-attr">transformASTSchema</span>: transformASTSchema
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 64 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-251" id="section-251"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> OR_LIST_MAX_LENGTH = <span class="hljs-number">5</span>;

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">orList</span>(<span class="hljs-params">items</span>) </span>{
  <span class="hljs-keyword">if</span> (items.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Expected an array of strings. Got empty array'</span>);
  }

  <span class="hljs-keyword">if</span> (items.length === <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> items[<span class="hljs-number">0</span>];
  }

  <span class="hljs-keyword">if</span> (items.length &gt; OR_LIST_MAX_LENGTH) {
    <span class="hljs-keyword">return</span> items.slice(<span class="hljs-number">0</span>, OR_LIST_MAX_LENGTH).join(<span class="hljs-string">', '</span>) + <span class="hljs-string">', ...'</span>;
  }

  <span class="hljs-keyword">var</span> selected = items.slice();
  <span class="hljs-keyword">var</span> lastItem = selected.pop();
  <span class="hljs-keyword">return</span> selected.join(<span class="hljs-string">', '</span>) + <span class="hljs-string">' or '</span> + lastItem;
}

<span class="hljs-built_in">module</span>.exports = orList;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 65 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-252" id="section-252"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> Printer = __webpack_require__(<span class="hljs-number">31</span>);

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>);

<span class="hljs-keyword">var</span> RelayCodeGenerator = __webpack_require__(<span class="hljs-number">66</span>);

<span class="hljs-keyword">var</span> filterContextForNode = __webpack_require__(<span class="hljs-number">69</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createFragmentContext</span>(<span class="hljs-params">context, transforms, reporter</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-253" id="section-253"></a>
</div>
<p>The fragment is used for reading data from the normalized store.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">return</span> context.applyTransforms([].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transforms.commonTransforms), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transforms.fragmentTransforms)), reporter);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPrintContext</span>(<span class="hljs-params">context, transforms, reporter</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-254" id="section-254"></a>
</div>
<p>The unflattened query is used for printing, since flattening creates an
invalid query.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">return</span> context.applyTransforms([].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transforms.commonTransforms), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transforms.queryTransforms), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transforms.printTransforms)), reporter);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCodeGenContext</span>(<span class="hljs-params">context, transforms, reporter</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-255" id="section-255"></a>
</div>
<p>The flattened query is used for codegen in order to reduce the number of
duplicate fields that must be processed during response normalization.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">return</span> context.applyTransforms([].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transforms.commonTransforms), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transforms.queryTransforms), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transforms.codegenTransforms)), reporter);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compile</span>(<span class="hljs-params">context, fragmentContext, printContext, codeGenContext</span>) </span>{
  <span class="hljs-keyword">var</span> results = [];
  <span class="hljs-keyword">var</span> schema = context.getSchema(); <span class="hljs-comment">// Add everything from codeGenContext, these are the operations as well as</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-256" id="section-256"></a>
</div>
<p>SplitOperations from @match.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(codeGenContext.documents()),
      _step;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
      <span class="hljs-keyword">var</span> node = _step.value;

      <span class="hljs-keyword">if</span> (node.kind === <span class="hljs-string">'Root'</span>) {
        <span class="hljs-keyword">var</span> fragment = fragmentContext.getRoot(node.name);
        <span class="hljs-keyword">var</span> request = {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Request'</span>,
          <span class="hljs-attr">fragment</span>: {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'Fragment'</span>,
            <span class="hljs-attr">argumentDefinitions</span>: fragment.argumentDefinitions,
            <span class="hljs-attr">directives</span>: fragment.directives,
            <span class="hljs-attr">loc</span>: {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
              <span class="hljs-attr">source</span>: node.loc
            },
            <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">name</span>: fragment.name,
            <span class="hljs-attr">selections</span>: fragment.selections,
            <span class="hljs-attr">type</span>: fragment.type
          },
          <span class="hljs-attr">id</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-attr">loc</span>: node.loc,
          <span class="hljs-attr">metadata</span>: node.metadata || {},
          <span class="hljs-attr">name</span>: fragment.name,
          <span class="hljs-attr">root</span>: node,
          <span class="hljs-attr">text</span>: printOperation(printContext, fragment.name)
        };
        results.push([request, RelayCodeGenerator.generate(schema, request)]);
      } <span class="hljs-keyword">else</span> {
        results.push([node, RelayCodeGenerator.generate(schema, node)]);
      }
    } <span class="hljs-comment">// Add all the Fragments from the fragmentContext for the reader ASTs.</span>

  } <span class="hljs-keyword">catch</span> (err) {
    _iterator.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator.f();
  }

  <span class="hljs-keyword">var</span> _iterator2 = _createForOfIteratorHelper(fragmentContext.documents()),
      _step2;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      <span class="hljs-keyword">var</span> _node = _step2.value;

      <span class="hljs-keyword">if</span> (_node.kind === <span class="hljs-string">'Fragment'</span>) {
        results.push([_node, RelayCodeGenerator.generate(schema, _node)]);
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator2.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator2.f();
  }

  <span class="hljs-keyword">return</span> results;
}

<span class="hljs-keyword">var</span> OPERATION_ORDER = {
  <span class="hljs-attr">Root</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">SplitOperation</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">Fragment</span>: <span class="hljs-number">2</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printOperation</span>(<span class="hljs-params">printContext, name</span>) </span>{
  <span class="hljs-keyword">var</span> printableRoot = printContext.getRoot(name);
  <span class="hljs-keyword">return</span> filterContextForNode(printableRoot, printContext).documents().sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">if</span> (a.kind !== b.kind) {
      <span class="hljs-keyword">return</span> OPERATION_ORDER[a.kind] - OPERATION_ORDER[b.kind];
    }

    <span class="hljs-keyword">return</span> a.name &lt; b.name ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;
  }).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
    <span class="hljs-keyword">return</span> Printer.print(printContext.getSchema(), doc);
  }).join(<span class="hljs-string">'\n'</span>);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-257" id="section-257"></a>
</div>
<div class="dox">
<div class="summary">
<p>Transforms the provided compiler context</p>
</div>
<div class="body">
<p>compileRelayArtifacts generates artifacts for Relay's runtime as a result of
applying a series of transforms. Each kind of artifact is dependent on
transforms being applied in the following order:</p>
<ul>
<li>Fragment Readers: commonTransforms, fragmentTransforms</li>
<li>Operation Writers: commonTransforms, queryTransforms, codegenTransforms</li>
<li>GraphQL Text: commonTransforms, queryTransforms, printTransforms</li>
</ul>
<p>The order of the transforms applied for each artifact below is important.
CompilerContext will memoize applying each transform, so while
<code>commonTransforms</code> appears in each artifacts' application, it will not result
in repeated work as long as the order remains consistent across each context.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileRelayArtifacts</span>(<span class="hljs-params">context, transforms, reporter</span>) </span>{
  <span class="hljs-keyword">return</span> Profiler.run(<span class="hljs-string">'GraphQLCompiler.compile'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> fragmentContext = createFragmentContext(context, transforms, reporter);
    <span class="hljs-keyword">var</span> printContext = createPrintContext(context, transforms, reporter);
    <span class="hljs-keyword">var</span> codeGenContext = createCodeGenContext(context, transforms, reporter);
    <span class="hljs-keyword">return</span> compile(context, fragmentContext, printContext, codeGenContext);
  });
}

<span class="hljs-built_in">module</span>.exports = compileRelayArtifacts;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 66 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-258" id="section-258"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> NormalizationCodeGenerator = __webpack_require__(<span class="hljs-number">67</span>);

<span class="hljs-keyword">var</span> ReaderCodeGenerator = __webpack_require__(<span class="hljs-number">68</span>);

<span class="hljs-keyword">var</span> sortObjectByKey = __webpack_require__(<span class="hljs-number">33</span>);

<span class="hljs-keyword">var</span> md5 = __webpack_require__(<span class="hljs-number">24</span>);

<span class="hljs-keyword">var</span> nullthrows = __webpack_require__(<span class="hljs-number">16</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generate</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">var</span> _node$metadata;

  <span class="hljs-keyword">switch</span> (node.kind) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Fragment'</span>:
      <span class="hljs-keyword">if</span> (((_node$metadata = node.metadata) === <span class="hljs-literal">null</span> || _node$metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$metadata.inlineData) === <span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineDataFragment'</span>,
          <span class="hljs-attr">name</span>: node.name
        };
      }

      <span class="hljs-keyword">return</span> ReaderCodeGenerator.generate(schema, node);

    <span class="hljs-keyword">case</span> <span class="hljs-string">'Request'</span>:
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">fragment</span>: ReaderCodeGenerator.generate(schema, node.fragment),
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Request'</span>,
        <span class="hljs-attr">operation</span>: NormalizationCodeGenerator.generate(schema, node.root),
        <span class="hljs-attr">params</span>: node.id != <span class="hljs-literal">null</span> ? {
          <span class="hljs-attr">id</span>: node.id,
          <span class="hljs-attr">metadata</span>: sortObjectByKey(node.metadata),
          <span class="hljs-attr">name</span>: node.name,
          <span class="hljs-attr">operationKind</span>: node.root.operation
        } : {
          <span class="hljs-attr">cacheID</span>: md5(nullthrows(node.text)),
          <span class="hljs-attr">metadata</span>: sortObjectByKey(node.metadata),
          <span class="hljs-attr">name</span>: node.name,
          <span class="hljs-attr">operationKind</span>: node.root.operation,
          <span class="hljs-attr">text</span>: node.text
        }
      };

    <span class="hljs-keyword">case</span> <span class="hljs-string">'SplitOperation'</span>:
      <span class="hljs-keyword">return</span> NormalizationCodeGenerator.generate(schema, node);
  }

  <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"RelayCodeGenerator: Unknown AST kind '"</span>.concat(node.kind, <span class="hljs-string">"'."</span>), [node.loc]);
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">generate</span>: generate
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 67 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-259" id="section-259"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> argumentContainsVariables = __webpack_require__(<span class="hljs-number">32</span>);

<span class="hljs-keyword">var</span> generateAbstractTypeRefinementKey = __webpack_require__(<span class="hljs-number">17</span>);

<span class="hljs-keyword">var</span> partitionArray = __webpack_require__(<span class="hljs-number">15</span>);

<span class="hljs-keyword">var</span> sortObjectByKey = __webpack_require__(<span class="hljs-number">33</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError,
    createUserError = _require.createUserError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">10</span>),
    getStorageKey = _require2.getStorageKey,
    stableCopy = _require2.stableCopy;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generate</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.kind) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Root'</span>:
      <span class="hljs-keyword">return</span> generateRoot(schema, node);

    <span class="hljs-keyword">case</span> <span class="hljs-string">'SplitOperation'</span>:
      <span class="hljs-keyword">return</span> generateSplitOperation(schema, node);

    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"NormalizationCodeGenerator: Unsupported AST kind '"</span>.concat(node.kind, <span class="hljs-string">"'."</span>), [node.loc]);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateRoot</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">argumentDefinitions</span>: generateArgumentDefinitions(schema, node.argumentDefinitions),
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Operation'</span>,
    <span class="hljs-attr">name</span>: node.name,
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateSplitOperation</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'SplitOperation'</span>,
    <span class="hljs-attr">metadata</span>: sortObjectByKey(node.metadata),
    <span class="hljs-attr">name</span>: node.name,
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateSelections</span>(<span class="hljs-params">schema, selections</span>) </span>{
  <span class="hljs-keyword">var</span> normalizationSelections = [];
  selections.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">var</span> _selection$metadata;

    <span class="hljs-keyword">switch</span> (selection.kind) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Condition'</span>:
        normalizationSelections.push(generateCondition(schema, selection));
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ClientExtension'</span>:
        normalizationSelections.push(generateClientExtension(schema, selection));
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ScalarField'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-260" id="section-260"></a>
</div>
<p>NOTE: Inline fragments in normalization ast have the abstractKey
but we skip the corresponding ScalarField for the type discriminator
selection, since it's guaranteed to be a duplicate of a parent __typename
selection.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> abstractKey = (_selection$metadata = selection.metadata) === <span class="hljs-literal">null</span> || _selection$metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _selection$metadata.abstractKey;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> abstractKey === <span class="hljs-string">'string'</span>) {
          normalizationSelections.push(generateTypeDiscriminator(abstractKey));
        } <span class="hljs-keyword">else</span> {
          normalizationSelections.push.apply(normalizationSelections, (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(generateScalarField(selection)));
        }

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ModuleImport'</span>:
        normalizationSelections.push(generateModuleImport(selection));
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineFragment'</span>:
        normalizationSelections.push(generateInlineFragment(schema, selection));
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'LinkedField'</span>:
        normalizationSelections.push.apply(normalizationSelections, (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(generateLinkedField(schema, selection)));
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Defer'</span>:
        normalizationSelections.push(generateDefer(schema, selection));
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Stream'</span>:
        normalizationSelections.push(generateStream(schema, selection));
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineDataFragmentSpread'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'FragmentSpread'</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> createCompilerError(<span class="hljs-string">"NormalizationCodeGenerator: Unexpected IR node "</span>.concat(selection.kind, <span class="hljs-string">"."</span>), [selection.loc]);

      <span class="hljs-keyword">default</span>:
        selection;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();
    }
  });
  <span class="hljs-keyword">return</span> normalizationSelections;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateArgumentDefinitions</span>(<span class="hljs-params">schema, nodes</span>) </span>{
  <span class="hljs-keyword">return</span> nodes.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">defaultValue</span>: stableCopy(node.defaultValue),
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'LocalArgument'</span>,
      <span class="hljs-attr">name</span>: node.name
    };
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateClientExtension</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'ClientExtension'</span>,
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateCondition</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">if</span> (node.condition.kind !== <span class="hljs-string">'Variable'</span>) {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"NormalizationCodeGenerator: Expected 'Condition' with static "</span> + <span class="hljs-string">'value to be pruned or inlined'</span>, [node.condition.loc]);
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">condition</span>: node.condition.variableName,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Condition'</span>,
    <span class="hljs-attr">passingValue</span>: node.passingValue,
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateDefer</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">if</span> (!(node[<span class="hljs-string">"if"</span>] == <span class="hljs-literal">null</span> || node[<span class="hljs-string">"if"</span>].kind === <span class="hljs-string">'Variable'</span> || node[<span class="hljs-string">"if"</span>].kind === <span class="hljs-string">'Literal'</span> &amp;&amp; node[<span class="hljs-string">"if"</span>].value === <span class="hljs-literal">true</span>)) {
    <span class="hljs-keyword">var</span> _node$<span class="hljs-keyword">if</span>$loc, _node$<span class="hljs-keyword">if</span>;

    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'NormalizationCodeGenerator: Expected @defer `if` condition to be '</span> + <span class="hljs-string">'a variable, unspecified, or the literal `true`.'</span>, [(_node$<span class="hljs-keyword">if</span>$loc = (_node$<span class="hljs-keyword">if</span> = node[<span class="hljs-string">"if"</span>]) === <span class="hljs-literal">null</span> || _node$<span class="hljs-keyword">if</span> === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$<span class="hljs-keyword">if</span>.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _node$<span class="hljs-keyword">if</span>$loc !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _node$<span class="hljs-keyword">if</span>$loc : node.loc]);
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-string">"if"</span>: node[<span class="hljs-string">"if"</span>] != <span class="hljs-literal">null</span> &amp;&amp; node[<span class="hljs-string">"if"</span>].kind === <span class="hljs-string">'Variable'</span> ? node[<span class="hljs-string">"if"</span>].variableName : <span class="hljs-literal">null</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Defer'</span>,
    <span class="hljs-attr">label</span>: node.label,
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateInlineFragment</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">var</span> rawType = schema.getRawType(node.typeCondition);
  <span class="hljs-keyword">var</span> isAbstractType = schema.isAbstractType(rawType);
  <span class="hljs-keyword">var</span> abstractKey = isAbstractType ? generateAbstractTypeRefinementKey(schema, rawType) : <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> selections = generateSelections(schema, node.selections);

  <span class="hljs-keyword">if</span> (isAbstractType) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-261" id="section-261"></a>
</div>
<p>Maintain a few invariants:</p>
<ul>
<li>InlineFragment (and <code>selections</code> arrays generally) cannot be empty</li>
<li>Don't emit a TypeDiscriminator under an InlineFragment unless it has
a different abstractKey
This means we have to handle two cases:</li>
<li>The inline fragment only contains a TypeDiscriminator with the same
abstractKey: replace the Fragment w the Discriminator</li>
<li>The inline fragment contains other selections: return all the selections
minus any Discriminators w the same key</li>
</ul>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> _partitionArray = partitionArray(selections, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
      <span class="hljs-keyword">return</span> selection.kind === <span class="hljs-string">'TypeDiscriminator'</span> &amp;&amp; selection.abstractKey === abstractKey;
    }),
        discriminators = _partitionArray[<span class="hljs-number">0</span>],
        otherSelections = _partitionArray[<span class="hljs-number">1</span>];

    <span class="hljs-keyword">var</span> discriminator = discriminators[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">if</span> (discriminator != <span class="hljs-literal">null</span> &amp;&amp; otherSelections.length === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> discriminator;
    } <span class="hljs-keyword">else</span> {
      selections = otherSelections;
    }
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineFragment'</span>,
    <span class="hljs-attr">selections</span>: selections,
    <span class="hljs-attr">type</span>: schema.getTypeString(rawType),
    <span class="hljs-attr">abstractKey</span>: abstractKey
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateLinkedField</span>(<span class="hljs-params">schema, node</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-262" id="section-262"></a>
</div>
<p>Note: it is important that the arguments of this field be sorted to
ensure stable generation of storage keys for equivalent arguments
which may have originally appeared in different orders across an app.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> handles = node.handles &amp;&amp; node.handles.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">handle</span>) </span>{
    <span class="hljs-keyword">var</span> handleNode = {
      <span class="hljs-attr">alias</span>: node.alias === node.name ? <span class="hljs-literal">null</span> : node.alias,
      <span class="hljs-attr">args</span>: generateArgs(node.args),
      <span class="hljs-attr">filters</span>: handle.filters,
      <span class="hljs-attr">handle</span>: handle.name,
      <span class="hljs-attr">key</span>: handle.key,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkedHandle'</span>,
      <span class="hljs-attr">name</span>: node.name
    }; <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> this intentionally adds a dynamic key in order to avoid</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-263" id="section-263"></a>
</div>
<p>triggering updates to existing queries that do not use dynamic
keys.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
    <span class="hljs-keyword">if</span> (handle.dynamicKey != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> dynamicKeyArgName = <span class="hljs-string">'__dynamicKey'</span>;
      handleNode = _objectSpread(_objectSpread({}, handleNode), {}, {
        <span class="hljs-attr">dynamicKey</span>: {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Variable'</span>,
          <span class="hljs-attr">name</span>: dynamicKeyArgName,
          <span class="hljs-attr">variableName</span>: handle.dynamicKey.variableName
        }
      });
    }

    <span class="hljs-keyword">if</span> (handle.handleArgs != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> handleArgs = generateArgs(handle.handleArgs);

      <span class="hljs-keyword">if</span> (handleArgs != <span class="hljs-literal">null</span>) {
        handleNode = _objectSpread(_objectSpread({}, handleNode), {}, {
          <span class="hljs-attr">handleArgs</span>: handleArgs
        });
      }
    }

    <span class="hljs-keyword">return</span> handleNode;
  }) || [];
  <span class="hljs-keyword">var</span> type = schema.getRawType(node.type);
  <span class="hljs-keyword">var</span> field = {
    <span class="hljs-attr">alias</span>: node.alias === node.name ? <span class="hljs-literal">null</span> : node.alias,
    <span class="hljs-attr">args</span>: generateArgs(node.args),
    <span class="hljs-attr">concreteType</span>: !schema.isAbstractType(type) ? schema.getTypeString(type) : <span class="hljs-literal">null</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkedField'</span>,
    <span class="hljs-attr">name</span>: node.name,
    <span class="hljs-attr">plural</span>: isPlural(schema, node.type),
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections),
    <span class="hljs-attr">storageKey</span>: <span class="hljs-literal">null</span>
  }; <span class="hljs-comment">// Precompute storageKey if possible</span>

  <span class="hljs-keyword">var</span> storageKey = getStaticStorageKey(field, node.metadata);

  <span class="hljs-keyword">if</span> (storageKey != <span class="hljs-literal">null</span>) {
    field = _objectSpread(_objectSpread({}, field), {}, {
      <span class="hljs-attr">storageKey</span>: storageKey
    });
  }

  <span class="hljs-keyword">return</span> [field].concat(handles);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateModuleImport</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">var</span> fragmentName = node.name;
  <span class="hljs-keyword">var</span> regExpMatch = fragmentName.match(<span class="hljs-regexp">/^([a-zA-Z][a-zA-Z0-9]*)(?:_([a-zA-Z][_a-zA-Z0-9]*))?$/</span>);

  <span class="hljs-keyword">if</span> (!regExpMatch) {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'NormalizationCodeGenerator: @module fragments should be named '</span> + <span class="hljs-string">"'FragmentName_propName', got '"</span>.concat(fragmentName, <span class="hljs-string">"'."</span>), [node.loc]);
  }

  <span class="hljs-keyword">var</span> fragmentPropName = regExpMatch[<span class="hljs-number">2</span>];

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fragmentPropName !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'NormalizationCodeGenerator: @module fragments should be named '</span> + <span class="hljs-string">"'FragmentName_propName', got '"</span>.concat(fragmentName, <span class="hljs-string">"'."</span>), [node.loc]);
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">documentName</span>: node.key,
    <span class="hljs-attr">fragmentName</span>: fragmentName,
    <span class="hljs-attr">fragmentPropName</span>: fragmentPropName,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'ModuleImport'</span>
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateTypeDiscriminator</span>(<span class="hljs-params">abstractKey</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'TypeDiscriminator'</span>,
    <span class="hljs-attr">abstractKey</span>: abstractKey
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateScalarField</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">var</span> _node$metadata, _node$metadata2;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-264" id="section-264"></a>
</div>
<p>flowlint-next-line sketchy-null-mixed:off</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">if</span> ((_node$metadata = node.metadata) === <span class="hljs-literal">null</span> || _node$metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$metadata.skipNormalizationNode) {
    <span class="hljs-keyword">return</span> [];
  } <span class="hljs-comment">// Note: it is important that the arguments of this field be sorted to</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-265" id="section-265"></a>
</div>
<p>ensure stable generation of storage keys for equivalent arguments
which may have originally appeared in different orders across an app.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">var</span> handles = node.handles &amp;&amp; node.handles.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">handle</span>) </span>{
    <span class="hljs-keyword">if</span> (handle.dynamicKey != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Dynamic key values are not supported on scalar fields.'</span>, [handle.dynamicKey.loc]);
    }

    <span class="hljs-keyword">var</span> nodeHandle = {
      <span class="hljs-attr">alias</span>: node.alias === node.name ? <span class="hljs-literal">null</span> : node.alias,
      <span class="hljs-attr">args</span>: generateArgs(node.args),
      <span class="hljs-attr">filters</span>: handle.filters,
      <span class="hljs-attr">handle</span>: handle.name,
      <span class="hljs-attr">key</span>: handle.key,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'ScalarHandle'</span>,
      <span class="hljs-attr">name</span>: node.name
    };

    <span class="hljs-keyword">if</span> (handle.handleArgs != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-266" id="section-266"></a>
</div>
<p>$FlowFixMe handleArgs exists in Handle</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      nodeHandle.handleArgs = generateArgs(handle.handleArgs);
    }

    <span class="hljs-keyword">return</span> nodeHandle;
  }) || [];
  <span class="hljs-keyword">var</span> field = {
    <span class="hljs-attr">alias</span>: node.alias === node.name ? <span class="hljs-literal">null</span> : node.alias,
    <span class="hljs-attr">args</span>: generateArgs(node.args),
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'ScalarField'</span>,
    <span class="hljs-attr">name</span>: node.name,
    <span class="hljs-attr">storageKey</span>: <span class="hljs-literal">null</span>
  }; <span class="hljs-comment">// Precompute storageKey if possible</span>

  <span class="hljs-keyword">var</span> storageKey = getStaticStorageKey(field, node.metadata);

  <span class="hljs-keyword">if</span> (storageKey != <span class="hljs-literal">null</span>) {
    field = _objectSpread(_objectSpread({}, field), {}, {
      <span class="hljs-attr">storageKey</span>: storageKey
    });
  }

  <span class="hljs-keyword">if</span> (((_node$metadata2 = node.metadata) === <span class="hljs-literal">null</span> || _node$metadata2 === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$metadata2.flight) === <span class="hljs-literal">true</span>) {
    field = _objectSpread(_objectSpread({}, field), {}, {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'FlightField'</span>
    });
  }

  <span class="hljs-keyword">return</span> [field].concat(handles);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateStream</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">if</span> (!(node[<span class="hljs-string">"if"</span>] == <span class="hljs-literal">null</span> || node[<span class="hljs-string">"if"</span>].kind === <span class="hljs-string">'Variable'</span> || node[<span class="hljs-string">"if"</span>].kind === <span class="hljs-string">'Literal'</span> &amp;&amp; node[<span class="hljs-string">"if"</span>].value === <span class="hljs-literal">true</span>)) {
    <span class="hljs-keyword">var</span> _node$<span class="hljs-keyword">if</span>$loc2, _node$if2;

    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'NormalizationCodeGenerator: Expected @stream `if` condition to be '</span> + <span class="hljs-string">'a variable, unspecified, or the literal `true`.'</span>, [(_node$<span class="hljs-keyword">if</span>$loc2 = (_node$if2 = node[<span class="hljs-string">"if"</span>]) === <span class="hljs-literal">null</span> || _node$if2 === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$if2.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _node$<span class="hljs-keyword">if</span>$loc2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _node$<span class="hljs-keyword">if</span>$loc2 : node.loc]);
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-string">"if"</span>: node[<span class="hljs-string">"if"</span>] != <span class="hljs-literal">null</span> &amp;&amp; node[<span class="hljs-string">"if"</span>].kind === <span class="hljs-string">'Variable'</span> ? node[<span class="hljs-string">"if"</span>].variableName : <span class="hljs-literal">null</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Stream'</span>,
    <span class="hljs-attr">label</span>: node.label,
    <span class="hljs-attr">metadata</span>: sortObjectByKey(node.metadata),
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections),
    <span class="hljs-attr">useCustomizedBatch</span>: node.useCustomizedBatch != <span class="hljs-literal">null</span> &amp;&amp; node.useCustomizedBatch.kind === <span class="hljs-string">'Variable'</span> ? node.useCustomizedBatch.variableName : <span class="hljs-literal">null</span>
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateArgumentValue</span>(<span class="hljs-params">name, value</span>) </span>{
  <span class="hljs-keyword">switch</span> (value.kind) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Variable'</span>:
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Variable'</span>,
        <span class="hljs-attr">name</span>: name,
        <span class="hljs-attr">variableName</span>: value.variableName
      };

    <span class="hljs-keyword">case</span> <span class="hljs-string">'Literal'</span>:
      <span class="hljs-keyword">return</span> value.value === <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">name</span>: name,
        <span class="hljs-attr">value</span>: stableCopy(value.value)
      };

    <span class="hljs-keyword">case</span> <span class="hljs-string">'ObjectValue'</span>:
      {
        <span class="hljs-keyword">var</span> objectKeys = value.fields.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field</span>) </span>{
          <span class="hljs-keyword">return</span> field.name;
        }).sort();
        <span class="hljs-keyword">var</span> objectValues = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(value.fields.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field</span>) </span>{
          <span class="hljs-keyword">return</span> [field.name, field.value];
        }));
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">fields</span>: objectKeys.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fieldName</span>) </span>{
            <span class="hljs-keyword">var</span> _generateArgumentValu;

            <span class="hljs-keyword">var</span> fieldValue = objectValues.get(fieldName);

            <span class="hljs-keyword">if</span> (fieldValue == <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Expected to have object field value'</span>);
            }

            <span class="hljs-keyword">return</span> (_generateArgumentValu = generateArgumentValue(fieldName, fieldValue)) !== <span class="hljs-literal">null</span> &amp;&amp; _generateArgumentValu !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _generateArgumentValu : {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
              <span class="hljs-attr">name</span>: fieldName,
              <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span>
            };
          }),
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'ObjectValue'</span>,
          <span class="hljs-attr">name</span>: name
        };
      }

    <span class="hljs-keyword">case</span> <span class="hljs-string">'ListValue'</span>:
      {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">items</span>: value.items.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index</span>) </span>{
            <span class="hljs-keyword">return</span> generateArgumentValue(<span class="hljs-string">""</span>.concat(name, <span class="hljs-string">"."</span>).concat(index), item);
          }),
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'ListValue'</span>,
          <span class="hljs-attr">name</span>: name
        };
      }

    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'NormalizationCodeGenerator: Complex argument values (Lists or '</span> + <span class="hljs-string">'InputObjects with nested variables) are not supported.'</span>, [value.loc]);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateArgs</span>(<span class="hljs-params">args</span>) </span>{
  <span class="hljs-keyword">var</span> concreteArguments = [];
  args.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">var</span> concreteArgument = generateArgumentValue(arg.name, arg.value);

    <span class="hljs-keyword">if</span> (concreteArgument !== <span class="hljs-literal">null</span>) {
      concreteArguments.push(concreteArgument);
    }
  });
  <span class="hljs-keyword">return</span> concreteArguments.length === <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : concreteArguments.sort(nameComparator);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nameComparator</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a.name &lt; b.name ? <span class="hljs-number">-1</span> : a.name &gt; b.name ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-267" id="section-267"></a>
</div>
<div class="dox">
<div class="summary">
<p>Pre-computes storage key if possible and advantageous. Storage keys are
generated for fields with supplied arguments that are all statically known
(ie. literals, no variables) at build time.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStaticStorageKey</span>(<span class="hljs-params">field, metadata</span>) </span>{
  <span class="hljs-keyword">var</span> metadataStorageKey = metadata === <span class="hljs-literal">null</span> || metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : metadata.storageKey;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> metadataStorageKey === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">return</span> metadataStorageKey;
  }

  <span class="hljs-keyword">if</span> (!field.args || field.args.length === <span class="hljs-number">0</span> || field.args.some(argumentContainsVariables)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">return</span> getStorageKey(field, {});
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPlural</span>(<span class="hljs-params">schema, type</span>) </span>{
  <span class="hljs-keyword">return</span> schema.isList(schema.getNullableType(type));
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">generate</span>: generate
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 68 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-268" id="section-268"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> CodeMarker = __webpack_require__(<span class="hljs-number">34</span>);

<span class="hljs-keyword">var</span> argumentContainsVariables = __webpack_require__(<span class="hljs-number">32</span>);

<span class="hljs-keyword">var</span> generateAbstractTypeRefinementKey = __webpack_require__(<span class="hljs-number">17</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError,
    createUserError = _require.createUserError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">10</span>),
    getStorageKey = _require2.getStorageKey,
    stableCopy = _require2.stableCopy;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-269" id="section-269"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generate</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> node;
  }

  <span class="hljs-keyword">var</span> metadata = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (node.metadata != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> _node$metadata4 = node.metadata,
        mask = _node$metadata4.mask,
        plural = _node$metadata4.plural,
        connection = _node$metadata4.connection,
        refetch = _node$metadata4.refetch;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(connection)) {
      <span class="hljs-keyword">var</span> _metadata;

      metadata = (_metadata = metadata) !== <span class="hljs-literal">null</span> &amp;&amp; _metadata !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _metadata : {};
      metadata.connection = connection;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> mask === <span class="hljs-string">'boolean'</span>) {
      <span class="hljs-keyword">var</span> _metadata2;

      metadata = (_metadata2 = metadata) !== <span class="hljs-literal">null</span> &amp;&amp; _metadata2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _metadata2 : {};
      metadata.mask = mask;
    }

    <span class="hljs-keyword">if</span> (plural === <span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">var</span> _metadata3;

      metadata = (_metadata3 = metadata) !== <span class="hljs-literal">null</span> &amp;&amp; _metadata3 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _metadata3 : {};
      metadata.plural = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (refetch != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> refetch === <span class="hljs-string">'object'</span>) {
      <span class="hljs-keyword">var</span> _metadata4;

      metadata = (_metadata4 = metadata) !== <span class="hljs-literal">null</span> &amp;&amp; _metadata4 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _metadata4 : {};
      metadata.refetch = {
        <span class="hljs-attr">connection</span>: refetch.connection,
        <span class="hljs-attr">fragmentPathInResult</span>: refetch.fragmentPathInResult,
        <span class="hljs-attr">operation</span>: CodeMarker.moduleDependency( <span class="hljs-comment">// $FlowFixMe[unclear-addition]</span>
        refetch.operation + <span class="hljs-string">'.graphql'</span>)
      };

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> refetch.identifierField === <span class="hljs-string">'string'</span>) {
        metadata.refetch = _objectSpread(_objectSpread({}, metadata.refetch), {}, {
          <span class="hljs-attr">identifierField</span>: refetch.identifierField
        });
      }
    }
  }

  <span class="hljs-keyword">var</span> rawType = schema.getRawType(node.type);
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">argumentDefinitions</span>: generateArgumentDefinitions(schema, node.argumentDefinitions),
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Fragment'</span>,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-270" id="section-270"></a>
</div>
<p>$FlowFixMe[incompatible-return]</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    metadata: metadata,
    <span class="hljs-attr">name</span>: node.name,
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections),
    <span class="hljs-attr">type</span>: schema.getTypeString(rawType),
    <span class="hljs-attr">abstractKey</span>: schema.isAbstractType(rawType) ? generateAbstractTypeRefinementKey(schema, rawType) : <span class="hljs-literal">null</span>
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateSelections</span>(<span class="hljs-params">schema, selections</span>) </span>{
  <span class="hljs-keyword">return</span> selections.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">var</span> _selection$metadata;

    <span class="hljs-keyword">switch</span> (selection.kind) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'ClientExtension'</span>:
        <span class="hljs-keyword">return</span> generateClientExtension(schema, selection);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'FragmentSpread'</span>:
        <span class="hljs-keyword">return</span> generateFragmentSpread(schema, selection);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Condition'</span>:
        <span class="hljs-keyword">return</span> generateCondition(schema, selection);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ScalarField'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-271" id="section-271"></a>
</div>
<p>NOTE: The type discriminator is used only for the
normalization ast.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">var</span> isTypeDiscriminator = ((_selection$metadata = selection.metadata) === <span class="hljs-literal">null</span> || _selection$metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _selection$metadata.abstractKey) != <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (isTypeDiscriminator) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> generateScalarField(schema, selection);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ModuleImport'</span>:
        <span class="hljs-keyword">return</span> generateModuleImport(schema, selection);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineDataFragmentSpread'</span>:
        <span class="hljs-keyword">return</span> generateInlineDataFragmentSpread(schema, selection);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineFragment'</span>:
        <span class="hljs-keyword">return</span> generateInlineFragment(schema, selection);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'LinkedField'</span>:
        <span class="hljs-keyword">return</span> generateLinkedField(schema, selection);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Defer'</span>:
        <span class="hljs-keyword">return</span> generateDefer(schema, selection);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Stream'</span>:
        <span class="hljs-keyword">return</span> generateStream(schema, selection);

      <span class="hljs-keyword">default</span>:
        selection;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();
    }
  }).filter(<span class="hljs-built_in">Boolean</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateArgumentDefinitions</span>(<span class="hljs-params">schema, nodes</span>) </span>{
  <span class="hljs-keyword">return</span> nodes.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">switch</span> (node.kind) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'LocalArgumentDefinition'</span>:
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">defaultValue</span>: stableCopy(node.defaultValue),
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'LocalArgument'</span>,
          <span class="hljs-attr">name</span>: node.name
        };

      <span class="hljs-keyword">case</span> <span class="hljs-string">'RootArgumentDefinition'</span>:
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'RootArgument'</span>,
          <span class="hljs-attr">name</span>: node.name
        };

      <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();
    }
  }).sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nodeA, nodeB</span>) </span>{
    <span class="hljs-keyword">if</span> (nodeA.name &gt; nodeB.name) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">if</span> (nodeA.name &lt; nodeB.name) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateClientExtension</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'ClientExtension'</span>,
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateDefer</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Defer'</span>,
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateStream</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Stream'</span>,
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateCondition</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">if</span> (node.condition.kind !== <span class="hljs-string">'Variable'</span>) {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"ReaderCodeGenerator: Expected 'Condition' with static value to be "</span> + <span class="hljs-string">'pruned or inlined'</span>, [node.condition.loc]);
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">condition</span>: node.condition.variableName,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Condition'</span>,
    <span class="hljs-attr">passingValue</span>: node.passingValue,
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateFragmentSpread</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">args</span>: generateArgs(node.args),
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'FragmentSpread'</span>,
    <span class="hljs-attr">name</span>: node.name
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateInlineFragment</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">var</span> rawType = schema.getRawType(node.typeCondition);
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineFragment'</span>,
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections),
    <span class="hljs-attr">type</span>: schema.getTypeString(rawType),
    <span class="hljs-attr">abstractKey</span>: schema.isAbstractType(rawType) ? generateAbstractTypeRefinementKey(schema, rawType) : <span class="hljs-literal">null</span>
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateInlineDataFragmentSpread</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineDataFragmentSpread'</span>,
    <span class="hljs-attr">name</span>: node.name,
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateLinkedField</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">var</span> _node$metadata;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-272" id="section-272"></a>
</div>
<p>Note: it is important that the arguments of this field be sorted to
ensure stable generation of storage keys for equivalent arguments
which may have originally appeared in different orders across an app.
TODO(T37646905) enable this invariant after splitting the
RelayCodeGenerator-test and running the FieldHandleTransform on
Reader ASTs.</p>
<p>invariant(
node.handles == null,
'ReaderCodeGenerator: unexpected handles',
);</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> rawType = schema.getRawType(node.type);
  <span class="hljs-keyword">var</span> field = {
    <span class="hljs-attr">alias</span>: node.alias === node.name ? <span class="hljs-literal">null</span> : node.alias,
    <span class="hljs-attr">args</span>: generateArgs(node.args),
    <span class="hljs-attr">concreteType</span>: !schema.isAbstractType(rawType) ? schema.getTypeString(rawType) : <span class="hljs-literal">null</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkedField'</span>,
    <span class="hljs-attr">name</span>: node.name,
    <span class="hljs-attr">plural</span>: isPlural(schema, node.type),
    <span class="hljs-attr">selections</span>: generateSelections(schema, node.selections),
    <span class="hljs-attr">storageKey</span>: <span class="hljs-literal">null</span>
  }; <span class="hljs-comment">// Precompute storageKey if possible</span>

  <span class="hljs-keyword">var</span> storageKey = getStaticStorageKey(field, node.metadata);

  <span class="hljs-keyword">if</span> (storageKey) {
    field = _objectSpread(_objectSpread({}, field), {}, {
      <span class="hljs-attr">storageKey</span>: storageKey
    });
  }

  <span class="hljs-keyword">var</span> requiredMetadata = (_node$metadata = node.metadata) === <span class="hljs-literal">null</span> || _node$metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$metadata.required;

  <span class="hljs-keyword">if</span> (requiredMetadata != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> createRequiredField(field, requiredMetadata);
  }

  <span class="hljs-keyword">return</span> field;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRequiredField</span>(<span class="hljs-params">field, requiredMetadata</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'RequiredField'</span>,
    <span class="hljs-attr">field</span>: field,
    <span class="hljs-attr">action</span>: requiredMetadata.action,
    <span class="hljs-attr">path</span>: requiredMetadata.path
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateModuleImport</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">var</span> fragmentName = node.name;
  <span class="hljs-keyword">var</span> regExpMatch = fragmentName.match(<span class="hljs-regexp">/^([a-zA-Z][a-zA-Z0-9]*)(?:_([a-zA-Z][_a-zA-Z0-9]*))?$/</span>);

  <span class="hljs-keyword">if</span> (!regExpMatch) {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'ReaderCodeGenerator: @match fragments should be named '</span> + <span class="hljs-string">"'FragmentName_propName', got '"</span>.concat(fragmentName, <span class="hljs-string">"'."</span>), [node.loc]);
  }

  <span class="hljs-keyword">var</span> fragmentPropName = regExpMatch[<span class="hljs-number">2</span>];

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fragmentPropName !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'ReaderCodeGenerator: @module fragments should be named '</span> + <span class="hljs-string">"'FragmentName_propName', got '"</span>.concat(fragmentName, <span class="hljs-string">"'."</span>), [node.loc]);
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">documentName</span>: node.key,
    <span class="hljs-attr">fragmentName</span>: fragmentName,
    <span class="hljs-attr">fragmentPropName</span>: fragmentPropName,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'ModuleImport'</span>
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateScalarField</span>(<span class="hljs-params">schema, node</span>) </span>{
  <span class="hljs-keyword">var</span> _node$metadata2, _node$metadata3;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-273" id="section-273"></a>
</div>
<p>Note: it is important that the arguments of this field be sorted to
ensure stable generation of storage keys for equivalent arguments
which may have originally appeared in different orders across an app.
TODO(T37646905) enable this invariant after splitting the
RelayCodeGenerator-test and running the FieldHandleTransform on
Reader ASTs.</p>
<p>invariant(
node.handles == null,
'ReaderCodeGenerator: unexpected handles',
);</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> field = {
    <span class="hljs-attr">alias</span>: node.alias === node.name ? <span class="hljs-literal">null</span> : node.alias,
    <span class="hljs-attr">args</span>: generateArgs(node.args),
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'ScalarField'</span>,
    <span class="hljs-attr">name</span>: node.name,
    <span class="hljs-attr">storageKey</span>: <span class="hljs-literal">null</span>
  }; <span class="hljs-comment">// Precompute storageKey if possible</span>

  <span class="hljs-keyword">var</span> storageKey = getStaticStorageKey(field, node.metadata);

  <span class="hljs-keyword">if</span> (storageKey) {
    field = _objectSpread(_objectSpread({}, field), {}, {
      <span class="hljs-attr">storageKey</span>: storageKey
    });
  }

  <span class="hljs-keyword">if</span> (((_node$metadata2 = node.metadata) === <span class="hljs-literal">null</span> || _node$metadata2 === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$metadata2.flight) === <span class="hljs-literal">true</span>) {
    field = _objectSpread(_objectSpread({}, field), {}, {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'FlightField'</span>
    });
  }

  <span class="hljs-keyword">var</span> requiredMetadata = (_node$metadata3 = node.metadata) === <span class="hljs-literal">null</span> || _node$metadata3 === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$metadata3.required;

  <span class="hljs-keyword">if</span> (requiredMetadata != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (field.kind === <span class="hljs-string">'FlightField'</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> createUserError(<span class="hljs-string">'@required cannot be used on a ReactFlightComponent.'</span>, [node.loc]);
    }

    <span class="hljs-keyword">return</span> createRequiredField(field, requiredMetadata);
  }

  <span class="hljs-keyword">return</span> field;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateArgument</span>(<span class="hljs-params">name, value</span>) </span>{
  <span class="hljs-keyword">switch</span> (value.kind) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Variable'</span>:
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Variable'</span>,
        <span class="hljs-attr">name</span>: name,
        <span class="hljs-attr">variableName</span>: value.variableName
      };

    <span class="hljs-keyword">case</span> <span class="hljs-string">'Literal'</span>:
      <span class="hljs-keyword">return</span> value.value === <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">name</span>: name,
        <span class="hljs-attr">value</span>: stableCopy(value.value)
      };

    <span class="hljs-keyword">case</span> <span class="hljs-string">'ObjectValue'</span>:
      {
        <span class="hljs-keyword">var</span> objectKeys = value.fields.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field</span>) </span>{
          <span class="hljs-keyword">return</span> field.name;
        }).sort();
        <span class="hljs-keyword">var</span> objectValues = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(value.fields.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field</span>) </span>{
          <span class="hljs-keyword">return</span> [field.name, field.value];
        }));
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">fields</span>: objectKeys.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fieldName</span>) </span>{
            <span class="hljs-keyword">var</span> _generateArgument;

            <span class="hljs-keyword">var</span> fieldValue = objectValues.get(fieldName);

            <span class="hljs-keyword">if</span> (fieldValue == <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Expected to have object field value'</span>);
            }

            <span class="hljs-keyword">return</span> (_generateArgument = generateArgument(fieldName, fieldValue)) !== <span class="hljs-literal">null</span> &amp;&amp; _generateArgument !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _generateArgument : {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
              <span class="hljs-attr">name</span>: fieldName,
              <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span>
            };
          }),
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'ObjectValue'</span>,
          <span class="hljs-attr">name</span>: name
        };
      }

    <span class="hljs-keyword">case</span> <span class="hljs-string">'ListValue'</span>:
      {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">items</span>: value.items.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index</span>) </span>{
            <span class="hljs-keyword">return</span> generateArgument(<span class="hljs-string">""</span>.concat(name, <span class="hljs-string">"."</span>).concat(index), item);
          }),
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'ListValue'</span>,
          <span class="hljs-attr">name</span>: name
        };
      }

    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'ReaderCodeGenerator: Complex argument values (Lists or '</span> + <span class="hljs-string">'InputObjects with nested variables) are not supported.'</span>, [value.loc]);
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateArgs</span>(<span class="hljs-params">args</span>) </span>{
  <span class="hljs-keyword">var</span> concreteArguments = [];
  args.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">var</span> concreteArgument = generateArgument(arg.name, arg.value);

    <span class="hljs-keyword">if</span> (concreteArgument !== <span class="hljs-literal">null</span>) {
      concreteArguments.push(concreteArgument);
    }
  });
  <span class="hljs-keyword">return</span> concreteArguments.length === <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : concreteArguments.sort(nameComparator);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nameComparator</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> a.name &lt; b.name ? <span class="hljs-number">-1</span> : a.name &gt; b.name ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-274" id="section-274"></a>
</div>
<div class="dox">
<div class="summary">
<p>Pre-computes storage key if possible and advantageous. Storage keys are
generated for fields with supplied arguments that are all statically known
(ie. literals, no variables) at build time.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStaticStorageKey</span>(<span class="hljs-params">field, metadata</span>) </span>{
  <span class="hljs-keyword">var</span> metadataStorageKey = metadata === <span class="hljs-literal">null</span> || metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : metadata.storageKey;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> metadataStorageKey === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">return</span> metadataStorageKey;
  }

  <span class="hljs-keyword">if</span> (!field.args || field.args.length === <span class="hljs-number">0</span> || field.args.some(argumentContainsVariables)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">return</span> getStorageKey(field, {});
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPlural</span>(<span class="hljs-params">schema, type</span>) </span>{
  <span class="hljs-keyword">return</span> schema.isList(schema.getNullableType(type));
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">generate</span>: generate
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 69 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-275" id="section-275"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> CompilerContext = __webpack_require__(<span class="hljs-number">23</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">18</span>),
    visit = _require.visit;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-276" id="section-276"></a>
</div>
<div class="dox">
<div class="summary">
<p>Returns a CompilerContext containing only the documents referenced
by and including the provided node.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterContextForNode</span>(<span class="hljs-params">node, context</span>) </span>{
  <span class="hljs-keyword">var</span> queue = [node];
  <span class="hljs-keyword">var</span> filteredContext = <span class="hljs-keyword">new</span> CompilerContext(context.getSchema()).add(node);

  <span class="hljs-keyword">var</span> visitFragmentSpread = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragmentSpread</span>(<span class="hljs-params">fragmentSpread</span>) </span>{
    <span class="hljs-keyword">var</span> name = fragmentSpread.name;

    <span class="hljs-keyword">if</span> (!filteredContext.get(name)) {
      <span class="hljs-keyword">var</span> fragment = context.getFragment(name);
      filteredContext = filteredContext.add(fragment);
      queue.push(fragment);
    }
  };

  <span class="hljs-keyword">var</span> visitorConfig = {
    <span class="hljs-attr">FragmentSpread</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FragmentSpread</span>(<span class="hljs-params">fragmentSpread</span>) </span>{
      visitFragmentSpread(fragmentSpread);
    }
  };

  <span class="hljs-keyword">while</span> (queue.length) {
    visit(queue.pop(), visitorConfig);
  }

  <span class="hljs-keyword">return</span> filteredContext;
}

<span class="hljs-built_in">module</span>.exports = filterContextForNode;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 70 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-277" id="section-277"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _asyncToGenerator = __webpack_require__(<span class="hljs-number">11</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _objectWithoutPropertiesLoose2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">71</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> CodeMarker = __webpack_require__(<span class="hljs-number">34</span>);

<span class="hljs-keyword">var</span> createPrintRequireModuleDependency = __webpack_require__(<span class="hljs-number">72</span>);

<span class="hljs-keyword">var</span> dedupeJSONStringify = __webpack_require__(<span class="hljs-number">73</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> md5 = __webpack_require__(<span class="hljs-number">24</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">10</span>),
    RelayConcreteNode = _require.RelayConcreteNode;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getConcreteType</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">switch</span> (node.kind) {
    <span class="hljs-keyword">case</span> RelayConcreteNode.FRAGMENT:
      <span class="hljs-keyword">return</span> <span class="hljs-string">'ReaderFragment'</span>;

    <span class="hljs-keyword">case</span> RelayConcreteNode.REQUEST:
      <span class="hljs-keyword">return</span> <span class="hljs-string">'ConcreteRequest'</span>;

    <span class="hljs-keyword">case</span> RelayConcreteNode.SPLIT_OPERATION:
      <span class="hljs-keyword">return</span> <span class="hljs-string">'NormalizationSplitOperation'</span>;

    <span class="hljs-keyword">case</span> RelayConcreteNode.INLINE_DATA_FRAGMENT:
      <span class="hljs-keyword">return</span> <span class="hljs-string">'ReaderInlineDataFragment'</span>;

    <span class="hljs-keyword">default</span>:
      node;
       <span class="hljs-literal">true</span> ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'Unexpected GeneratedNode kind: `%s`.'</span>, node.kind) : <span class="hljs-literal">undefined</span> : <span class="hljs-literal">undefined</span>;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeRelayGeneratedFile</span>(<span class="hljs-params">schema, codegenDir, definition, _generatedNode, formatModule, typeText, _persistQuery, sourceHash, extension</span>) </span>{
  <span class="hljs-keyword">var</span> printModuleDependency = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">9</span> &amp;&amp; <span class="hljs-built_in">arguments</span>[<span class="hljs-number">9</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">9</span>] : createPrintRequireModuleDependency(extension);
  <span class="hljs-keyword">var</span> shouldRepersist = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">10</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">10</span>] : <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">var</span> writeQueryParameters = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">11</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">11</span>] : <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">var</span> languagePlugin = <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">12</span> ? <span class="hljs-built_in">arguments</span>[<span class="hljs-number">12</span>] : <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">var</span> generatedNode = _generatedNode; <span class="hljs-comment">// Copy to const so Flow can refine.</span>

  <span class="hljs-keyword">var</span> persistQuery = _persistQuery;
  <span class="hljs-keyword">var</span> operationName = generatedNode.kind === <span class="hljs-string">'Request'</span> ? generatedNode.params.name : generatedNode.name;
  <span class="hljs-keyword">var</span> moduleName = (languagePlugin === <span class="hljs-literal">null</span> || languagePlugin === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : languagePlugin.getModuleName) ? languagePlugin.getModuleName(operationName) : operationName + <span class="hljs-string">'.graphql'</span>;
  <span class="hljs-keyword">var</span> filename = moduleName + <span class="hljs-string">'.'</span> + extension;
  <span class="hljs-keyword">var</span> queryParametersFilename = generatedNode.kind === <span class="hljs-string">'Request'</span> ? <span class="hljs-string">""</span>.concat(generatedNode.params.name, <span class="hljs-string">"$Parameters."</span>).concat(extension) : <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> typeName = getConcreteType(generatedNode);
  <span class="hljs-keyword">var</span> docText;

  <span class="hljs-keyword">if</span> (generatedNode.kind === RelayConcreteNode.REQUEST) {
    docText = generatedNode.params.text != <span class="hljs-literal">null</span> ? generatedNode.params.text : <span class="hljs-literal">null</span>;
  } <span class="hljs-comment">// Use `Promise.resolve` to work around a Babel 7.8/7.9 issue.</span>


  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve().then( <span class="hljs-comment">/*#__PURE__*/</span>_asyncToGenerator(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _generatedNode$metada;

    <span class="hljs-keyword">var</span> hash = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (generatedNode.kind === RelayConcreteNode.REQUEST) {
      !(docText != <span class="hljs-literal">null</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'writeRelayGeneratedFile: Expected `text` for operations to be set.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> _generatedNode$params = generatedNode.params.metadata,
          _ignored = _generatedNode$params.isRefetchableQuery,
          _ignored2 = _generatedNode$params.derivedFrom,
          nextMetadata = (<span class="hljs-number">0</span>, _objectWithoutPropertiesLoose2[<span class="hljs-string">"default"</span>])(_generatedNode$params, [<span class="hljs-string">"isRefetchableQuery"</span>, <span class="hljs-string">"derivedFrom"</span>]);
      <span class="hljs-keyword">var</span> nextRequestParams;

      <span class="hljs-keyword">if</span> (persistQuery != <span class="hljs-literal">null</span>) {
        hash = md5(docText);
        <span class="hljs-keyword">var</span> id = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (!shouldRepersist) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-278" id="section-278"></a>
</div>
<p>Unless we <code>shouldRepersist</code> the query, check if the @relayHash matches
the operation text of the current text and re-use the persisted
operation id.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> oldContent = codegenDir.read(filename);
          <span class="hljs-keyword">var</span> oldHash = extractHash(oldContent);
          <span class="hljs-keyword">var</span> oldRequestID = extractRelayRequestID(oldContent);

          <span class="hljs-keyword">if</span> (hash === oldHash &amp;&amp; oldRequestID != <span class="hljs-literal">null</span>) {
            id = oldRequestID;
          }
        }

        <span class="hljs-keyword">if</span> (id == <span class="hljs-literal">null</span>) {
          id = <span class="hljs-keyword">yield</span> persistQuery(docText);
        }

        nextRequestParams = {
          <span class="hljs-attr">id</span>: id,
          <span class="hljs-attr">metadata</span>: nextMetadata,
          <span class="hljs-attr">name</span>: generatedNode.params.name,
          <span class="hljs-attr">operationKind</span>: generatedNode.params.operationKind,
          <span class="hljs-attr">text</span>: <span class="hljs-literal">null</span>
        };
      } <span class="hljs-keyword">else</span> {
        nextRequestParams = {
          <span class="hljs-attr">cacheID</span>: md5(docText),
          <span class="hljs-attr">id</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-attr">metadata</span>: nextMetadata,
          <span class="hljs-attr">name</span>: generatedNode.params.name,
          <span class="hljs-attr">operationKind</span>: generatedNode.params.operationKind,
          <span class="hljs-attr">text</span>: docText
        };
      }

      generatedNode = _objectSpread(_objectSpread({}, generatedNode), {}, {
        <span class="hljs-attr">params</span>: nextRequestParams
      });
    } <span class="hljs-comment">// Strip metadata only used within the compiler</span>


    <span class="hljs-keyword">if</span> (generatedNode.kind === RelayConcreteNode.SPLIT_OPERATION &amp;&amp; ((_generatedNode$metada = generatedNode.metadata) === <span class="hljs-literal">null</span> || _generatedNode$metada === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _generatedNode$metada.derivedFrom) != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> _generatedNode$metada2 = generatedNode.metadata,
          _ignored3 = _generatedNode$metada2.derivedFrom,
          metadata = (<span class="hljs-number">0</span>, _objectWithoutPropertiesLoose2[<span class="hljs-string">"default"</span>])(_generatedNode$metada2, [<span class="hljs-string">"derivedFrom"</span>]);
      generatedNode = _objectSpread(_objectSpread({}, generatedNode), {}, {
        <span class="hljs-attr">metadata</span>: metadata
      });
    }

    <span class="hljs-keyword">var</span> moduleText = formatModule({
      <span class="hljs-attr">moduleName</span>: moduleName,
      <span class="hljs-attr">documentType</span>: typeName,
      <span class="hljs-attr">definition</span>: definition,
      <span class="hljs-attr">kind</span>: generatedNode.kind,
      <span class="hljs-attr">docText</span>: docText,
      <span class="hljs-attr">typeText</span>: typeText,
      <span class="hljs-attr">hash</span>: hash != <span class="hljs-literal">null</span> ? <span class="hljs-string">"@relayHash "</span>.concat(hash) : <span class="hljs-literal">null</span>,
      <span class="hljs-attr">concreteText</span>: CodeMarker.postProcess(dedupeJSONStringify(generatedNode), printModuleDependency),
      <span class="hljs-attr">sourceHash</span>: sourceHash,
      <span class="hljs-attr">node</span>: generatedNode,
      <span class="hljs-attr">schema</span>: schema
    });
    codegenDir.writeFile(filename, moduleText, shouldRepersist);

    <span class="hljs-keyword">if</span> (writeQueryParameters &amp;&amp; queryParametersFilename != <span class="hljs-literal">null</span> &amp;&amp; generatedNode.kind === RelayConcreteNode.REQUEST &amp;&amp; generatedNode.params.operationKind === <span class="hljs-string">'query'</span>) {
      writeQueryParameters(codegenDir, queryParametersFilename, moduleName, generatedNode.params);
    }

    <span class="hljs-keyword">return</span> generatedNode;
  }));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractHash</span>(<span class="hljs-params">text</span>) </span>{
  <span class="hljs-keyword">if</span> (text == <span class="hljs-literal">null</span> || text.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/&lt;&lt;&lt;&lt;&lt;|&gt;&gt;&gt;&gt;&gt;/</span>.test(text)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-279" id="section-279"></a>
</div>
<p>looks like a merge conflict</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> match = text.match(<span class="hljs-regexp">/@relayHash (\w{32})\b/m</span>);
  <span class="hljs-keyword">return</span> match &amp;&amp; match[<span class="hljs-number">1</span>];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractRelayRequestID</span>(<span class="hljs-params">text</span>) </span>{
  <span class="hljs-keyword">if</span> (text == <span class="hljs-literal">null</span> || text.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/&lt;&lt;&lt;&lt;&lt;|&gt;&gt;&gt;&gt;&gt;/</span>.test(text)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-280" id="section-280"></a>
</div>
<p>looks like a merge conflict</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> match = text.match(<span class="hljs-regexp">/@relayRequestID (.+)/</span>);
  <span class="hljs-keyword">return</span> match ? match[<span class="hljs-number">1</span>] : <span class="hljs-literal">null</span>;
}

<span class="hljs-built_in">module</span>.exports = writeRelayGeneratedFile;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 71 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/runtime/helpers/objectWithoutPropertiesLoose"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 72 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-281" id="section-281"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createPrintRequireModuleDependency</span>(<span class="hljs-params">extension</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">moduleName</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"require('./"</span>.concat(moduleName, <span class="hljs-string">"."</span>).concat(extension, <span class="hljs-string">"')"</span>);
  };
}

<span class="hljs-built_in">module</span>.exports = createPrintRequireModuleDependency;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 73 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-282" id="section-282"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-283" id="section-283"></a>
</div>
<div class="dox">
<div class="summary">
<p>This function works similar to JSON.stringify except that for the case there
are multiple common subtrees, it generates a string for a IIFE that re-uses
the same objects for the duplicate subtrees.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dedupeJSONStringify</span>(<span class="hljs-params">jsonValue</span>) </span>{
  <span class="hljs-keyword">var</span> metadataForHash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">var</span> metadataForVal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
  <span class="hljs-keyword">var</span> varDefs = [];
  collectMetadata(jsonValue);
  collectDuplicates(jsonValue);
  <span class="hljs-keyword">var</span> code = printJSCode(<span class="hljs-literal">false</span>, <span class="hljs-string">''</span>, jsonValue);
  <span class="hljs-keyword">return</span> varDefs.length === <span class="hljs-number">0</span> ? code : <span class="hljs-string">"(function(){\nvar "</span>.concat(varDefs.join(<span class="hljs-string">',\n'</span>), <span class="hljs-string">";\nreturn "</span>).concat(code, <span class="hljs-string">";\n})()"</span>); <span class="hljs-comment">// Collect common metadata for each object in the value tree, ensuring that</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-284" id="section-284"></a>
</div>
<p>equivalent values have the <em>same reference</em> to the same metadata. Note that
the hashes generated are not exactly JSON, but still identify equivalent
values. Runs in linear time due to hashing in a bottom-up recursion.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectMetadata</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'object'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-285" id="section-285"></a>
</div>
<p>$FlowFixMe[incompatible-return] - JSON.stringify can return undefined</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(value);
    }

    <span class="hljs-keyword">var</span> hash;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) {
      hash = <span class="hljs-string">'['</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; value.length; i++) {
        hash += collectMetadata(value[i]) + <span class="hljs-string">','</span>;
      }
    } <span class="hljs-keyword">else</span> {
      hash = <span class="hljs-string">'{'</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> value) {
        <span class="hljs-keyword">if</span> (value.hasOwnProperty(k) &amp;&amp; value[k] !== <span class="hljs-literal">undefined</span>) {
          hash += k + <span class="hljs-string">':'</span> + collectMetadata(value[k]) + <span class="hljs-string">','</span>;
        }
      }
    }

    <span class="hljs-keyword">var</span> metadata = metadataForHash.get(hash);

    <span class="hljs-keyword">if</span> (!metadata) {
      metadata = {
        <span class="hljs-attr">value</span>: value,
        <span class="hljs-attr">hash</span>: hash,
        <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>
      };
      metadataForHash.set(hash, metadata);
    }

    metadataForVal.set(value, metadata);
    <span class="hljs-keyword">return</span> hash;
  } <span class="hljs-comment">// Using top-down recursion, linearly scan the JSON tree to determine which</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-286" id="section-286"></a>
</div>
<p>values should be deduplicated.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectDuplicates</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'object'</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> metadata = metadataForVal.get(value); <span class="hljs-comment">// Only consider duplicates with hashes longer than 2 (excludes [] and {}).</span>

    <span class="hljs-keyword">if</span> (metadata &amp;&amp; metadata.hash.length &gt; <span class="hljs-number">2</span>) {
      metadata.count++;

      <span class="hljs-keyword">if</span> (metadata.count &gt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span>;
      }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; value.length; i++) {
        collectDuplicates(value[i]);
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> value) {
        <span class="hljs-keyword">if</span> (value.hasOwnProperty(k) &amp;&amp; value[k] !== <span class="hljs-literal">undefined</span>) {
          collectDuplicates(value[k]);
        }
      }
    }
  } <span class="hljs-comment">// Stringify JS, replacing duplicates with variable references.</span>


  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printJSCode</span>(<span class="hljs-params">isDupedVar, depth, value</span>) </span>{
    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'object'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-287" id="section-287"></a>
</div>
<p>$FlowFixMe[incompatible-return] : JSON.stringify can return undefined</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(value);
    } <span class="hljs-comment">// Only use variable references at depth beyond the top level.</span>


    <span class="hljs-keyword">if</span> (depth !== <span class="hljs-string">''</span>) {
      <span class="hljs-keyword">var</span> metadata = metadataForVal.get(value);

      <span class="hljs-keyword">if</span> (metadata &amp;&amp; metadata.count &gt; <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">var</span> varName = metadata.varName;

        <span class="hljs-keyword">if</span> (varName == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> refCode = printJSCode(<span class="hljs-literal">true</span>, <span class="hljs-string">''</span>, value);
          varName = metadata.varName = <span class="hljs-string">'v'</span> + varDefs.length;
          varDefs.push(metadata.varName + <span class="hljs-string">' = '</span> + refCode);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-string">'('</span> + varName + <span class="hljs-string">'/*: any*/)'</span>;
      }
    }

    <span class="hljs-keyword">var</span> str;
    <span class="hljs-keyword">var</span> isEmpty = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> depth2 = depth + <span class="hljs-string">'  '</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-288" id="section-288"></a>
</div>
<p>Empty arrays can only have one inferred flow type and then conflict if
used in different places, this is unsound if we would write to them but
this whole module is based on the idea of a read only JSON tree.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">if</span> (isDupedVar &amp;&amp; value.length === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'([]/*: any*/)'</span>;
      }

      str = <span class="hljs-string">'['</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; value.length; i++) {
        str += (isEmpty ? <span class="hljs-string">'\n'</span> : <span class="hljs-string">',\n'</span>) + depth2 + printJSCode(isDupedVar, depth2, value[i]);
        isEmpty = <span class="hljs-literal">false</span>;
      }

      str += isEmpty ? <span class="hljs-string">']'</span> : <span class="hljs-string">"\n"</span>.concat(depth, <span class="hljs-string">"]"</span>);
    } <span class="hljs-keyword">else</span> {
      str = <span class="hljs-string">'{'</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> value) {
        <span class="hljs-keyword">if</span> (value.hasOwnProperty(k) &amp;&amp; value[k] !== <span class="hljs-literal">undefined</span>) {
          str += (isEmpty ? <span class="hljs-string">'\n'</span> : <span class="hljs-string">',\n'</span>) + depth2 + <span class="hljs-built_in">JSON</span>.stringify(k) + <span class="hljs-string">': '</span> + printJSCode(isDupedVar, depth2, value[k]);
          isEmpty = <span class="hljs-literal">false</span>;
        }
      }

      str += isEmpty ? <span class="hljs-string">'}'</span> : <span class="hljs-string">"\n"</span>.concat(depth, <span class="hljs-string">"}"</span>);
    }

    <span class="hljs-keyword">return</span> str;
  }
}

<span class="hljs-built_in">module</span>.exports = dedupeJSONStringify;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 74 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-289" id="section-289"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-290" id="section-290"></a>
</div>
<div class="dox">
<div class="summary">
<p>Helpers to retieve the name of the document from which the input derives:
this is either the name of the input itself (if it is not a derived node)
or the metadata.derivedFrom property for derived nodes.</p>
</div>
<div class="body">
</div>
</div>
Version for generated nodes

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getReaderSourceDefinitionName</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">var</span> _node$params$metadata, _node$metadata;

  <span class="hljs-keyword">var</span> _ref = node.kind === <span class="hljs-string">'Request'</span> ? [node.params.name, (_node$params$metadata = node.params.metadata) === <span class="hljs-literal">null</span> || _node$params$metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$params$metadata.derivedFrom] : node.kind === <span class="hljs-string">'SplitOperation'</span> ? [node.name, (_node$metadata = node.metadata) === <span class="hljs-literal">null</span> || _node$metadata === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _node$metadata.derivedFrom] : [node.name, <span class="hljs-literal">null</span>],
      name = _ref[<span class="hljs-number">0</span>],
      derivedFrom = _ref[<span class="hljs-number">1</span>];

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> derivedFrom === <span class="hljs-string">'string'</span> ? derivedFrom : name;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">getReaderSourceDefinitionName</span>: getReaderSourceDefinitionName
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 75 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-291" id="section-291"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> ApplyFragmentArgumentTransform = __webpack_require__(<span class="hljs-number">76</span>);

<span class="hljs-keyword">var</span> ClientExtensionsTransform = __webpack_require__(<span class="hljs-number">78</span>);

<span class="hljs-keyword">var</span> ConnectionTransform = __webpack_require__(<span class="hljs-number">79</span>);

<span class="hljs-keyword">var</span> DeclarativeConnectionMutationTransform = __webpack_require__(<span class="hljs-number">80</span>);

<span class="hljs-keyword">var</span> DeferStreamTransform = __webpack_require__(<span class="hljs-number">81</span>);

<span class="hljs-keyword">var</span> DisallowIdAsAlias = __webpack_require__(<span class="hljs-number">82</span>);

<span class="hljs-keyword">var</span> DisallowTypenameOnRoot = __webpack_require__(<span class="hljs-number">83</span>);

<span class="hljs-keyword">var</span> FieldHandleTransform = __webpack_require__(<span class="hljs-number">84</span>);

<span class="hljs-keyword">var</span> FilterCompilerDirectivesTransform = __webpack_require__(<span class="hljs-number">85</span>);

<span class="hljs-keyword">var</span> FilterDirectivesTransform = __webpack_require__(<span class="hljs-number">86</span>);

<span class="hljs-keyword">var</span> FlattenTransform = __webpack_require__(<span class="hljs-number">38</span>);

<span class="hljs-keyword">var</span> GenerateIDFieldTransform = __webpack_require__(<span class="hljs-number">88</span>);

<span class="hljs-keyword">var</span> GenerateTypeNameTransform = __webpack_require__(<span class="hljs-number">89</span>);

<span class="hljs-keyword">var</span> InlineDataFragmentTransform = __webpack_require__(<span class="hljs-number">90</span>);

<span class="hljs-keyword">var</span> InlineFragmentsTransform = __webpack_require__(<span class="hljs-number">91</span>);

<span class="hljs-keyword">var</span> MaskTransform = __webpack_require__(<span class="hljs-number">41</span>);

<span class="hljs-keyword">var</span> MatchTransform = __webpack_require__(<span class="hljs-number">42</span>);

<span class="hljs-keyword">var</span> ReactFlightComponentTransform = __webpack_require__(<span class="hljs-number">93</span>);

<span class="hljs-keyword">var</span> RefetchableFragmentTransform = __webpack_require__(<span class="hljs-number">44</span>);

<span class="hljs-keyword">var</span> RelayDirectiveTransform = __webpack_require__(<span class="hljs-number">45</span>);

<span class="hljs-keyword">var</span> RelayFlowGenerator = __webpack_require__(<span class="hljs-number">46</span>);

<span class="hljs-keyword">var</span> RequiredFieldTransform = __webpack_require__(<span class="hljs-number">47</span>);

<span class="hljs-keyword">var</span> SkipClientExtensionsTransform = __webpack_require__(<span class="hljs-number">101</span>);

<span class="hljs-keyword">var</span> SkipHandleFieldTransform = __webpack_require__(<span class="hljs-number">102</span>);

<span class="hljs-keyword">var</span> SkipRedundantNodesTransform = __webpack_require__(<span class="hljs-number">103</span>);

<span class="hljs-keyword">var</span> SkipSplitOperationTransform = __webpack_require__(<span class="hljs-number">104</span>);

<span class="hljs-keyword">var</span> SkipUnreachableNodeTransform = __webpack_require__(<span class="hljs-number">105</span>);

<span class="hljs-keyword">var</span> SkipUnusedVariablesTransform = __webpack_require__(<span class="hljs-number">106</span>);

<span class="hljs-keyword">var</span> SplitModuleImportTransform = __webpack_require__(<span class="hljs-number">107</span>);

<span class="hljs-keyword">var</span> TestOperationTransform = __webpack_require__(<span class="hljs-number">108</span>);

<span class="hljs-keyword">var</span> ValidateGlobalVariablesTransform = __webpack_require__(<span class="hljs-number">109</span>);

<span class="hljs-keyword">var</span> ValidateRequiredArgumentsTransform = __webpack_require__(<span class="hljs-number">110</span>);

<span class="hljs-keyword">var</span> ValidateUnusedVariablesTransform = __webpack_require__(<span class="hljs-number">111</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-292" id="section-292"></a>
</div>
<p>Transforms applied to the code used to process a query response.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> relaySchemaExtensions = [ConnectionTransform.SCHEMA_EXTENSION, DeclarativeConnectionMutationTransform.SCHEMA_EXTENSION, InlineDataFragmentTransform.SCHEMA_EXTENSION, MatchTransform.SCHEMA_EXTENSION, RequiredFieldTransform.SCHEMA_EXTENSION, RefetchableFragmentTransform.SCHEMA_EXTENSION, RelayDirectiveTransform.SCHEMA_EXTENSION, RelayFlowGenerator.SCHEMA_EXTENSION, TestOperationTransform.SCHEMA_EXTENSION, ValidateUnusedVariablesTransform.SCHEMA_EXTENSION]; <span class="hljs-comment">// Transforms applied to both operations and fragments for both reading and</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-293" id="section-293"></a>
</div>
<p>writing from the store.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-keyword">var</span> relayCommonTransforms = [DisallowIdAsAlias.transform, ConnectionTransform.transform, RelayDirectiveTransform.transform, MaskTransform.transform, MatchTransform.transform, RefetchableFragmentTransform.transform, DeferStreamTransform.transform, ReactFlightComponentTransform.transform]; <span class="hljs-comment">// Transforms applied to fragments used for reading data from a store</span>

<span class="hljs-keyword">var</span> relayFragmentTransforms = [ClientExtensionsTransform.transform, FieldHandleTransform.transform, InlineDataFragmentTransform.transform, FlattenTransform.transformWithOptions({
  <span class="hljs-attr">isForCodegen</span>: <span class="hljs-literal">true</span>
}), RequiredFieldTransform.transform, SkipRedundantNodesTransform.transform]; <span class="hljs-comment">// Transforms applied to queries/mutations/subscriptions that are used for</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-294" id="section-294"></a>
</div>
<p>fetching data from the server and parsing those responses.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-keyword">var</span> relayQueryTransforms = [SplitModuleImportTransform.transform, DisallowTypenameOnRoot.transform, ValidateUnusedVariablesTransform.transform, ApplyFragmentArgumentTransform.transform, ValidateGlobalVariablesTransform.transform, GenerateIDFieldTransform.transform, DeclarativeConnectionMutationTransform.transform]; <span class="hljs-comment">// Transforms applied to the code used to process a query response.</span>

<span class="hljs-keyword">var</span> relayCodegenTransforms = [FilterCompilerDirectivesTransform.transform, SkipUnreachableNodeTransform.transform, InlineFragmentsTransform.transform, <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> For the codegen context, we make sure to run ClientExtensions</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-295" id="section-295"></a>
</div>
<p>transform after we've inlined fragment spreads (i.e. InlineFragmentsTransform)
This will ensure that we don't generate nested ClientExtension nodes</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">ClientExtensionsTransform.transform, GenerateTypeNameTransform.transform, FlattenTransform.transformWithOptions({
  <span class="hljs-attr">isForCodegen</span>: <span class="hljs-literal">true</span>
}), SkipRedundantNodesTransform.transform, TestOperationTransform.transform]; <span class="hljs-comment">// Transforms applied before printing the query sent to the server.</span>

<span class="hljs-keyword">var</span> relayPrintTransforms = [SkipSplitOperationTransform.transform, <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Skipping client extensions might leave empty selections, which we</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-296" id="section-296"></a>
</div>
<p>skip by running SkipUnreachableNodeTransform immediately after.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">ClientExtensionsTransform.transform, SkipClientExtensionsTransform.transform, SkipUnreachableNodeTransform.transform, GenerateTypeNameTransform.transform, FlattenTransform.transformWithOptions({}), SkipHandleFieldTransform.transform, FilterDirectivesTransform.transform, SkipUnusedVariablesTransform.transform, ValidateRequiredArgumentsTransform.transform];
<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">commonTransforms</span>: relayCommonTransforms,
  <span class="hljs-attr">codegenTransforms</span>: relayCodegenTransforms,
  <span class="hljs-attr">fragmentTransforms</span>: relayFragmentTransforms,
  <span class="hljs-attr">printTransforms</span>: relayPrintTransforms,
  <span class="hljs-attr">queryTransforms</span>: relayQueryTransforms,
  <span class="hljs-attr">schemaExtensions</span>: relaySchemaExtensions
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 76 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-297" id="section-297"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> RelayCompilerScope = __webpack_require__(<span class="hljs-number">77</span>);

<span class="hljs-keyword">var</span> getIdentifierForArgumentValue = __webpack_require__(<span class="hljs-number">35</span>);

<span class="hljs-keyword">var</span> murmurHash = __webpack_require__(<span class="hljs-number">36</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError,
    createNonRecoverableUserError = _require.createNonRecoverableUserError;

<span class="hljs-keyword">var</span> getFragmentScope = RelayCompilerScope.getFragmentScope,
    getRootScope = RelayCompilerScope.getRootScope;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-298" id="section-298"></a>
</div>
<div class="dox">
<div class="summary">
<p>A transform that converts a set of documents containing fragments/fragment
spreads <em>with</em> arguments to one where all arguments have been inlined. This
is effectively static currying of functions. Nodes are changed as follows:</p>
<ul>
<li>Fragment spreads with arguments are replaced with references to an inlined
version of the referenced fragment.</li>
<li>Fragments with argument definitions are cloned once per unique set of
arguments, with the name changed to original name + hash and all nested
variable references changed to the value of that variable given its
arguments.</li>
<li>Field &amp; directive argument variables are replaced with the value of those
variables in context.</li>
<li>All nodes are cloned with updated children.</li>
</ul>
</div>
<div class="body">
<p>The transform also handles statically passing/failing Condition nodes:</p>
<ul>
<li>Literal Conditions with a passing value are elided and their selections
inlined in their parent.</li>
<li>Literal Conditions with a failing value are removed.</li>
<li>Nodes that would become empty as a result of the above are removed.</li>
</ul>
<p>Note that unreferenced fragments are not added to the output.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyFragmentArgumentTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> fragments = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">var</span> nextContext = IRTransformer.transform(context, {
    <span class="hljs-attr">Root</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Root</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">var</span> scope = getRootScope(node.argumentDefinitions);
      <span class="hljs-keyword">return</span> transformNode(context, fragments, scope, node, [node]);
    },
    <span class="hljs-attr">SplitOperation</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SplitOperation</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> transformNode(context, fragments, {}, node, [node]);
    },
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-299" id="section-299"></a>
</div>
<p>Fragments are included below where referenced.
Unreferenced fragments are not included.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    Fragment: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fragment</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  });

  <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(fragments.values()),
      _step;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
      <span class="hljs-keyword">var</span> pendingFragment = _step.value;

      <span class="hljs-keyword">if</span> (pendingFragment.kind === <span class="hljs-string">'resolved'</span> &amp;&amp; pendingFragment.value) {
        nextContext = nextContext.add(pendingFragment.value);
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator.f();
  }

  <span class="hljs-keyword">return</span> nextContext;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformNode</span>(<span class="hljs-params">context, fragments, scope, node, errorContext</span>) </span>{
  <span class="hljs-keyword">var</span> selections = transformSelections(context, fragments, scope, node.selections, errorContext);

  <span class="hljs-keyword">if</span> (!selections) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">if</span> (node.hasOwnProperty(<span class="hljs-string">'directives'</span>)) {
    <span class="hljs-keyword">var</span> directives = transformDirectives(scope, node.directives, errorContext);
    <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, node), {}, {
      <span class="hljs-attr">directives</span>: directives,
      <span class="hljs-attr">selections</span>: selections
    });
  }

  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, node), {}, {
    <span class="hljs-attr">selections</span>: selections
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformDeferStreamNode</span>(<span class="hljs-params">context, fragments, scope, node, errorContext</span>) </span>{
  <span class="hljs-keyword">var</span> nextNode = transformNode(context, fragments, scope, node, errorContext);

  <span class="hljs-keyword">if</span> (!nextNode) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  nextNode;

  <span class="hljs-keyword">if</span> (nextNode[<span class="hljs-string">"if"</span>]) {
    <span class="hljs-keyword">var</span> ifVal = transformValue(scope, nextNode[<span class="hljs-string">"if"</span>], errorContext);

    <span class="hljs-keyword">if</span> (ifVal.kind === <span class="hljs-string">'Literal'</span> &amp;&amp; ifVal.value === <span class="hljs-literal">false</span> &amp;&amp; node.selections &amp;&amp; node.selections.length === <span class="hljs-number">1</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-300" id="section-300"></a>
</div>
<p>Skip Defer/Stream wrapper with literal if: false</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">return</span> node.selections[<span class="hljs-number">0</span>];
    } <span class="hljs-comment">// $FlowFixMe[cannot-write] nextNode is uniquely owned</span>


    nextNode[<span class="hljs-string">"if"</span>] = ifVal;
  }

  <span class="hljs-keyword">if</span> (nextNode.useCustomizedBatch) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-301" id="section-301"></a>
</div>
<p>$FlowFixMe[cannot-write] nextNode is uniquely owned</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    nextNode.useCustomizedBatch = transformValue(scope, nextNode.useCustomizedBatch, errorContext);
  }

  <span class="hljs-keyword">if</span> (nextNode.initialCount) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-302" id="section-302"></a>
</div>
<p>$FlowFixMe[cannot-write] nextNode is uniquely owned</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    nextNode.initialCount = transformValue(scope, nextNode.initialCount, errorContext);
  }

  <span class="hljs-keyword">return</span> nextNode;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformFragmentSpread</span>(<span class="hljs-params">context, fragments, scope, spread, errorContext</span>) </span>{
  <span class="hljs-keyword">var</span> directives = transformDirectives(scope, spread.directives, errorContext);
  <span class="hljs-keyword">var</span> appliedFragment = transformFragment(context, fragments, scope, spread, spread.args, [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(errorContext), [spread]));

  <span class="hljs-keyword">if</span> (!appliedFragment) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> transformed = _objectSpread(_objectSpread({}, spread), {}, {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'FragmentSpread'</span>,
    <span class="hljs-attr">args</span>: [],
    <span class="hljs-attr">directives</span>: directives,
    <span class="hljs-attr">name</span>: appliedFragment.name
  });

  <span class="hljs-keyword">return</span> transformed;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformField</span>(<span class="hljs-params">context, fragments, scope, field, errorContext</span>) </span>{
  <span class="hljs-keyword">var</span> args = transformArguments(scope, field.args, errorContext);
  <span class="hljs-keyword">var</span> directives = transformDirectives(scope, field.directives, errorContext);

  <span class="hljs-keyword">if</span> (field.kind === <span class="hljs-string">'LinkedField'</span>) {
    <span class="hljs-keyword">var</span> selections = transformSelections(context, fragments, scope, field.selections, errorContext);

    <span class="hljs-keyword">if</span> (!selections) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, field), {}, {
      <span class="hljs-attr">args</span>: args,
      <span class="hljs-attr">directives</span>: directives,
      <span class="hljs-attr">selections</span>: selections
    });
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, field), {}, {
      <span class="hljs-attr">args</span>: args,
      <span class="hljs-attr">directives</span>: directives
    });
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformCondition</span>(<span class="hljs-params">context, fragments, scope, node, errorContext</span>) </span>{
  <span class="hljs-keyword">var</span> condition = transformValue(scope, node.condition, errorContext);

  <span class="hljs-keyword">if</span> (!(condition.kind === <span class="hljs-string">'Literal'</span> || condition.kind === <span class="hljs-string">'Variable'</span>)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-303" id="section-303"></a>
</div>
<p>This transform does whole-program optimization, errors in
a single document could break invariants and/or cause
additional spurious errors.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">throw</span> createNonRecoverableUserError(<span class="hljs-string">'A non-scalar value was applied to an @include or @skip directive, '</span> + <span class="hljs-string">'the `if` argument value must be a '</span> + <span class="hljs-string">'variable or a literal Boolean.'</span>, [condition.loc]);
  }

  <span class="hljs-keyword">if</span> (condition.kind === <span class="hljs-string">'Literal'</span> &amp;&amp; condition.value !== node.passingValue) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-304" id="section-304"></a>
</div>
<p>Dead code, no need to traverse further.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> selections = transformSelections(context, fragments, scope, node.selections, errorContext);

  <span class="hljs-keyword">if</span> (!selections) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">if</span> (condition.kind === <span class="hljs-string">'Literal'</span> &amp;&amp; condition.value === node.passingValue) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-305" id="section-305"></a>
</div>
<p>Always passes, return inlined selections</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> selections;
  }

  <span class="hljs-keyword">return</span> [_objectSpread(_objectSpread({}, node), {}, {
    <span class="hljs-attr">condition</span>: condition,
    <span class="hljs-attr">selections</span>: selections
  })];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformSelections</span>(<span class="hljs-params">context, fragments, scope, selections, errorContext</span>) </span>{
  <span class="hljs-keyword">var</span> nextSelections = <span class="hljs-literal">null</span>;
  selections.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">var</span> nextSelection;

    <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'ClientExtension'</span> || selection.kind === <span class="hljs-string">'InlineDataFragmentSpread'</span> || selection.kind === <span class="hljs-string">'InlineFragment'</span> || selection.kind === <span class="hljs-string">'ModuleImport'</span>) {
      nextSelection = transformNode(context, fragments, scope, selection, errorContext);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'Defer'</span> || selection.kind === <span class="hljs-string">'Stream'</span>) {
      nextSelection = transformDeferStreamNode(context, fragments, scope, selection, errorContext);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'FragmentSpread'</span>) {
      nextSelection = transformFragmentSpread(context, fragments, scope, selection, errorContext);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'Condition'</span>) {
      <span class="hljs-keyword">var</span> conditionSelections = transformCondition(context, fragments, scope, selection, errorContext);

      <span class="hljs-keyword">if</span> (conditionSelections) {
        <span class="hljs-keyword">var</span> _nextSelections;

        nextSelections = nextSelections || [];

        (_nextSelections = nextSelections).push.apply(_nextSelections, (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(conditionSelections));
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'LinkedField'</span> || selection.kind === <span class="hljs-string">'ScalarField'</span>) {
      nextSelection = transformField(context, fragments, scope, selection, errorContext);
    } <span class="hljs-keyword">else</span> {
      selection;
      <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"ApplyFragmentArgumentTransform: Unsupported kind '"</span>.concat(selection.kind, <span class="hljs-string">"'."</span>), [selection.loc]);
    }

    <span class="hljs-keyword">if</span> (nextSelection) {
      nextSelections = nextSelections || [];
      nextSelections.push(nextSelection);
    }
  });
  <span class="hljs-keyword">return</span> nextSelections;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformDirectives</span>(<span class="hljs-params">scope, directives, errorContext</span>) </span>{
  <span class="hljs-keyword">return</span> directives.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">var</span> args = transformArguments(scope, directive.args, errorContext);
    <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, directive), {}, {
      <span class="hljs-attr">args</span>: args
    });
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformArguments</span>(<span class="hljs-params">scope, args, errorContext</span>) </span>{
  <span class="hljs-keyword">return</span> args.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">var</span> value = transformValue(scope, arg.value, errorContext);
    <span class="hljs-keyword">return</span> value === arg.value ? arg : _objectSpread(_objectSpread({}, arg), {}, {
      <span class="hljs-attr">value</span>: value
    });
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformValue</span>(<span class="hljs-params">scope, value, errorContext</span>) </span>{
  <span class="hljs-keyword">if</span> (value.kind === <span class="hljs-string">'Variable'</span>) {
    <span class="hljs-keyword">var</span> scopeValue = scope[value.variableName];

    <span class="hljs-keyword">if</span> (scopeValue == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> _errorContext$;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-306" id="section-306"></a>
</div>
<p>This transform does whole-program optimization, errors in
a single document could break invariants and/or cause
additional spurious errors.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">throw</span> createNonRecoverableUserError(<span class="hljs-string">"Variable '$"</span>.concat(value.variableName, <span class="hljs-string">"' is not in scope."</span>), [(_errorContext$ = errorContext[<span class="hljs-number">0</span>]) === <span class="hljs-literal">null</span> || _errorContext$ === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _errorContext$.loc, value.loc].filter(<span class="hljs-built_in">Boolean</span>));
    }

    <span class="hljs-keyword">return</span> scopeValue;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.kind === <span class="hljs-string">'ObjectValue'</span>) {
    <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, value), {}, {
      <span class="hljs-attr">fields</span>: value.fields.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">field</span>) </span>{
        <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, field), {}, {
          <span class="hljs-attr">value</span>: transformValue(scope, field.value, errorContext)
        });
      })
    });
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.kind === <span class="hljs-string">'ListValue'</span>) {
    <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, value), {}, {
      <span class="hljs-attr">items</span>: value.items.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
        <span class="hljs-keyword">return</span> transformValue(scope, item, errorContext);
      })
    });
  }

  <span class="hljs-keyword">return</span> value;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-307" id="section-307"></a>
</div>
<div class="dox">
<div class="summary">
<p>Apply arguments to a fragment, creating a new fragment (with the given name)
with all values recursively applied.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformFragment</span>(<span class="hljs-params">context, fragments, parentScope, spread, args, errorContext</span>) </span>{
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> fragment = context.getFragment(spread.name, spread.loc);
  <span class="hljs-keyword">var</span> argumentsHash = hashArguments(args, parentScope, errorContext);
  <span class="hljs-keyword">var</span> fragmentName = argumentsHash ? <span class="hljs-string">""</span>.concat(fragment.name, <span class="hljs-string">"_"</span>).concat(argumentsHash) : fragment.name;
  <span class="hljs-keyword">var</span> appliedFragment = fragments.get(fragmentName);

  <span class="hljs-keyword">if</span> (appliedFragment) {
    <span class="hljs-keyword">if</span> (appliedFragment.kind === <span class="hljs-string">'resolved'</span>) {
      <span class="hljs-keyword">return</span> appliedFragment.value;
    } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-308" id="section-308"></a>
</div>
<p>This transform does whole-program optimization, errors in
a single document could break invariants and/or cause
additional spurious errors.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">throw</span> createNonRecoverableUserError(<span class="hljs-string">"Found a circular reference from fragment '"</span>.concat(fragment.name, <span class="hljs-string">"'."</span>), errorContext.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">return</span> node.loc;
      }));
    }
  }

  <span class="hljs-keyword">var</span> fragmentScope = getFragmentScope(schema, fragment.argumentDefinitions, args, parentScope, spread); <span class="hljs-comment">// record that this fragment is pending to detect circular references</span>

  fragments.set(fragmentName, {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'pending'</span>
  });
  <span class="hljs-keyword">var</span> transformedFragment = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> selections = transformSelections(context, fragments, fragmentScope, fragment.selections, errorContext);

  <span class="hljs-keyword">if</span> (selections) {
    transformedFragment = _objectSpread(_objectSpread({}, fragment), {}, {
      <span class="hljs-attr">selections</span>: selections,
      <span class="hljs-attr">name</span>: fragmentName,
      <span class="hljs-attr">argumentDefinitions</span>: []
    });
  }

  fragments.set(fragmentName, {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'resolved'</span>,
    <span class="hljs-attr">value</span>: transformedFragment
  });
  <span class="hljs-keyword">return</span> transformedFragment;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hashArguments</span>(<span class="hljs-params">args, scope, errorContext</span>) </span>{
  <span class="hljs-keyword">if</span> (!args.length) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> sortedArgs = (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(args).sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> a.name &lt; b.name ? <span class="hljs-number">-1</span> : a.name &gt; b.name ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
  });
  <span class="hljs-keyword">var</span> printedArgs = <span class="hljs-built_in">JSON</span>.stringify(sortedArgs.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">var</span> value;

    <span class="hljs-keyword">if</span> (arg.value.kind === <span class="hljs-string">'Variable'</span>) {
      value = scope[arg.value.variableName];

      <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> _errorContext$<span class="hljs-number">2</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-309" id="section-309"></a>
</div>
<p>This transform does whole-program optimization, errors in
a single document could break invariants and/or cause
additional spurious errors.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">throw</span> createNonRecoverableUserError(<span class="hljs-string">"Variable '$"</span>.concat(arg.value.variableName, <span class="hljs-string">"' is not in scope."</span>), [(_errorContext$<span class="hljs-number">2</span> = errorContext[<span class="hljs-number">0</span>]) === <span class="hljs-literal">null</span> || _errorContext$<span class="hljs-number">2</span> === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _errorContext$<span class="hljs-number">2.</span>loc, arg.value.loc].filter(<span class="hljs-built_in">Boolean</span>));
      }
    } <span class="hljs-keyword">else</span> {
      value = arg.value;
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">name</span>: arg.name,
      <span class="hljs-attr">value</span>: getIdentifierForArgumentValue(value)
    };
  }));
  <span class="hljs-keyword">return</span> murmurHash(printedArgs);
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: applyFragmentArgumentTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 77 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-310" id="section-310"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError,
    eachWithCombinedError = _require.eachWithCombinedError;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-311" id="section-311"></a>
</div>
<div class="dox">
<div class="summary">
<p>Creates a scope for a <code>Root</code>, with each argument mapped to a variable of the
same name. Example:</p>
</div>
<div class="body">
<p>Query:
query Foo($id: ID, $size: Int = 42) { ... }</p>
<p>Scope:
{
id: $id,
size: $size,
}</p>
<p>Note that even though a default value is defined for $size, the scope must
assume that this could be overridden at runtime. The value cannot be decided
statically and therefore is set to a variable.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRootScope</span>(<span class="hljs-params">definitions</span>) </span>{
  <span class="hljs-keyword">var</span> scope = {};
  definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
    scope[definition.name] = {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Variable'</span>,
      <span class="hljs-attr">loc</span>: definition.loc,
      <span class="hljs-attr">variableName</span>: definition.name,
      <span class="hljs-attr">type</span>: definition.type
    };
  });
  <span class="hljs-keyword">return</span> scope;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-312" id="section-312"></a>
</div>
<div class="dox">
<div class="summary">
<p>Creates a scope for a <code>Fragment</code> by translating fragment spread arguments in
the context of a parent scope into a new scope and validating them against
the argument definitions.</p>
</div>
<div class="body">
<p>Parent Scope:
{
active: $parentActive
}</p>
<p>Fragment Spread:
...Bar(size: 42, enabled: $active)</p>
<p>Fragment:
fragment Bar on Foo @argumentDefinitions(
id: {type: &quot;ID&quot;}
size: {type: &quot;Int&quot;}
enabled: {type: &quot;Boolean}
scale: {type: &quot;Int&quot;, imports: &quot;pixelRatio&quot;}
)</p>
<p>Scope:
{
// No argument is provided for $id, it gets the default value which in this
// case is <code>null</code>:
id: null,</p>
<p>// The parent passes 42 as a literal value for $size:
size: 42,</p>
<p>// The parent passes a variable as the value of $enabled. This variable is
// resolved in the parent scope to the value $parentActive, which becomes
// the value of $enabled:
$enabled: $parentActive,</p>
<p>// $scale imports pixelRatio from the root scope. Since any argument in a
// root scope maps to a variable of the same name, that means the value of
// pixelRatio in the root is $pixelRatio:
$scale: $pixelRatio,
}</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFragmentScope</span>(<span class="hljs-params">schema, definitions, args, parentScope, spread</span>) </span>{
  <span class="hljs-keyword">var</span> argMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  args.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">if</span> (arg.value.kind === <span class="hljs-string">'Literal'</span>) {
      argMap.set(arg.name, arg.value);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arg.value.kind === <span class="hljs-string">'Variable'</span>) {
      argMap.set(arg.name, parentScope[arg.value.variableName]);
    }
  });
  <span class="hljs-keyword">var</span> fragmentScope = {};
  eachWithCombinedError(definitions, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">definition</span>) </span>{
    <span class="hljs-keyword">if</span> (definition.kind === <span class="hljs-string">'RootArgumentDefinition'</span>) {
      <span class="hljs-keyword">if</span> (argMap.has(definition.name)) {
        <span class="hljs-keyword">var</span> _argNode$loc;

        <span class="hljs-keyword">var</span> argNode = args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
          <span class="hljs-keyword">return</span> a.name === definition.name;
        });
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unexpected argument '"</span>.concat(definition.name, <span class="hljs-string">"' supplied to fragment '"</span>).concat(spread.name, <span class="hljs-string">"'. @arguments may only be provided for variables defined in the fragment's @argumentDefinitions."</span>), [(_argNode$loc = argNode === <span class="hljs-literal">null</span> || argNode === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : argNode.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _argNode$loc !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _argNode$loc : spread.loc]);
      }

      fragmentScope[definition.name] = {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Variable'</span>,
        <span class="hljs-attr">loc</span>: definition.loc,
        <span class="hljs-attr">variableName</span>: definition.name,
        <span class="hljs-attr">type</span>: definition.type
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> arg = argMap.get(definition.name);

      <span class="hljs-keyword">if</span> (arg == <span class="hljs-literal">null</span> || arg.kind === <span class="hljs-string">'Literal'</span> &amp;&amp; arg.value == <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-313" id="section-313"></a>
</div>
<p>No variable or literal null was passed, fall back to default
value.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">if</span> (definition.defaultValue == <span class="hljs-literal">null</span> &amp;&amp; schema.isNonNull(definition.type)) {
          <span class="hljs-keyword">var</span> _argNode$loc2;

          <span class="hljs-keyword">var</span> _argNode = args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
            <span class="hljs-keyword">return</span> a.name === definition.name;
          });

          <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"No value found for required argument '"</span>.concat(definition.name, <span class="hljs-string">": "</span>).concat(schema.getTypeString(definition.type), <span class="hljs-string">"' on fragment '"</span>).concat(spread.name, <span class="hljs-string">"'."</span>), [(_argNode$loc2 = _argNode === <span class="hljs-literal">null</span> || _argNode === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _argNode.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _argNode$loc2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _argNode$loc2 : spread.loc]);
        }

        fragmentScope[definition.name] = {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
          <span class="hljs-attr">value</span>: definition.defaultValue
        };
      } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-314" id="section-314"></a>
</div>
<p>Variable or non-null literal.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        fragmentScope[definition.name] = arg;
      }
    }
  });
  <span class="hljs-keyword">return</span> fragmentScope;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">getFragmentScope</span>: getFragmentScope,
  <span class="hljs-attr">getRootScope</span>: getRootScope
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 78 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-315" id="section-315"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError,
    createUserError = _require.createUserError;

<span class="hljs-keyword">var</span> cachesByNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clientExtensionTransform</span>(<span class="hljs-params">context</span>) </span>{
  cachesByNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">Fragment</span>: traverseDefinition,
    <span class="hljs-attr">Root</span>: traverseDefinition,
    <span class="hljs-attr">SplitOperation</span>: traverseDefinition
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverseDefinition</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">var</span> compilerContext = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> schema = compilerContext.getSchema();
  <span class="hljs-keyword">var</span> rootType;

  <span class="hljs-keyword">switch</span> (node.kind) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Root'</span>:
      <span class="hljs-keyword">switch</span> (node.operation) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'query'</span>:
          rootType = schema.getQueryType();
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'mutation'</span>:
          rootType = schema.getMutationType();
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'subscription'</span>:
          rootType = schema.getSubscriptionType();
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
          node.operation;
      }

      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'SplitOperation'</span>:
      <span class="hljs-keyword">if</span> (!schema.isServerType(node.type)) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'ClientExtensionTransform: SplitOperation (@module) can be created '</span> + <span class="hljs-string">'only for fragments that defined on a server type'</span>, [node.loc]);
      }

      rootType = node.type;
      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'Fragment'</span>:
      rootType = node.type;
      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">default</span>:
      node;
  }

  <span class="hljs-keyword">if</span> (rootType == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"ClientExtensionTransform: Expected the type of `"</span>.concat(node.name, <span class="hljs-string">"` to have been defined in the schema. Make sure both server and "</span>) + <span class="hljs-string">'client schema are up to date.'</span>, [node.loc]);
  }

  <span class="hljs-keyword">return</span> traverseSelections(node, compilerContext, rootType);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverseSelections</span>(<span class="hljs-params">node, compilerContext, parentType</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-316" id="section-316"></a>
</div>
<p>$FlowFixMe[escaped-generic]</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> nodeCache = cachesByNode.get(node);

  <span class="hljs-keyword">if</span> (nodeCache == <span class="hljs-literal">null</span>) {
    nodeCache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// $FlowFixMe[escaped-generic]</span>

    cachesByNode.set(node, nodeCache);
  }

  <span class="hljs-keyword">var</span> result = nodeCache.get(parentType);

  <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-317" id="section-317"></a>
</div>
<div class="dox">
<div class="summary">
<p>$FlowFixMe[incompatible-return] - TODO: type IRTransformer to allow
changing result type</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-keyword">var</span> schema = compilerContext.getSchema();
  <span class="hljs-keyword">var</span> clientSelections = [];
  <span class="hljs-keyword">var</span> serverSelections = cowMap(node.selections, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">switch</span> (selection.kind) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'ClientExtension'</span>:
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'Unexpected ClientExtension node before ClientExtensionTransform'</span>, [selection.loc]);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Condition'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Defer'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineDataFragmentSpread'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'ModuleImport'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Stream'</span>:
        <span class="hljs-keyword">return</span> traverseSelections(selection, compilerContext, parentType);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ScalarField'</span>:
        <span class="hljs-keyword">if</span> (schema.isClientDefinedField(schema.assertCompositeType(schema.getRawType(parentType)), selection)) {
          clientSelections.push(selection);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> selection;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">'LinkedField'</span>:
        {
          <span class="hljs-keyword">if</span> (schema.isClientDefinedField(schema.assertCompositeType(schema.getRawType(parentType)), selection)) {
            clientSelections.push(selection);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">return</span> traverseSelections(selection, compilerContext, selection.type);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineFragment'</span>:
        {
          <span class="hljs-keyword">var</span> isClientType = !schema.isServerType(selection.typeCondition);

          <span class="hljs-keyword">if</span> (isClientType) {
            clientSelections.push(selection);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">return</span> traverseSelections(selection, compilerContext, selection.typeCondition);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">'FragmentSpread'</span>:
        {
          <span class="hljs-keyword">return</span> selection;
        }

      <span class="hljs-attr">default</span>:
        selection;
        <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"ClientExtensionTransform: Unexpected selection of kind `"</span>.concat(selection.kind, <span class="hljs-string">"`."</span>), [selection.loc]);
    }
  });

  <span class="hljs-keyword">if</span> (clientSelections.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span> (serverSelections === node.selections) {
      result = node;
    } <span class="hljs-keyword">else</span> {
      result = _objectSpread(_objectSpread({}, node), {}, {
        <span class="hljs-attr">selections</span>: serverSelections
      });
    }
  } <span class="hljs-keyword">else</span> {
    result = _objectSpread(_objectSpread({}, node), {}, {
      <span class="hljs-attr">selections</span>: [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(serverSelections), [<span class="hljs-comment">// Group client fields under a single ClientExtension node</span>
      {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'ClientExtension'</span>,
        <span class="hljs-attr">loc</span>: node.loc,
        <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">selections</span>: clientSelections
      }])
    });
  }

  nodeCache.set(parentType, result);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-318" id="section-318"></a>
</div>
<div class="dox">
<div class="summary">
<p>$FlowFixMe[incompatible-return] - TODO: type IRTransformer to allow
changing result type</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  <span class="hljs-keyword">return</span> result;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-319" id="section-319"></a>
</div>
<div class="dox">
<div class="summary">
<p>Maps an array with copy-on-write semantics.
<code>null</code> return values from the map function are removals.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cowMap</span>(<span class="hljs-params">selections, f</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; selections.length; i++) {
    <span class="hljs-keyword">var</span> prevSelection = selections[i];
    <span class="hljs-keyword">var</span> nextSelection = f(prevSelection);

    <span class="hljs-keyword">if</span> (prevSelection !== nextSelection) {
      <span class="hljs-keyword">var</span> result = selections.slice(<span class="hljs-number">0</span>, i);

      <span class="hljs-keyword">if</span> (nextSelection != <span class="hljs-literal">null</span>) {
        result.push(nextSelection);
      }

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i + <span class="hljs-number">1</span>; j &lt; selections.length; j++) {
        <span class="hljs-keyword">var</span> innerNextSelection = f(selections[j]);

        <span class="hljs-keyword">if</span> (innerNextSelection != <span class="hljs-literal">null</span>) {
          result.push(innerNextSelection);
        }
      }

      <span class="hljs-keyword">return</span> result;
    }
  } <span class="hljs-comment">// nothing changed, return original</span>


  <span class="hljs-keyword">return</span> selections;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: clientExtensionTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 79 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-320" id="section-320"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> RelayParser = __webpack_require__(<span class="hljs-number">28</span>);

<span class="hljs-keyword">var</span> SchemaUtils = __webpack_require__(<span class="hljs-number">9</span>);

<span class="hljs-keyword">var</span> getLiteralArgumentValues = __webpack_require__(<span class="hljs-number">19</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createCompilerError = _require.createCompilerError,
    createUserError = _require.createUserError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">7</span>),
    parse = _require2.parse;

<span class="hljs-keyword">var</span> _require3 = __webpack_require__(<span class="hljs-number">10</span>),
    ConnectionInterface = _require3.ConnectionInterface,
    RelayFeatureFlags = _require3.RelayFeatureFlags;

<span class="hljs-keyword">var</span> AFTER = <span class="hljs-string">'after'</span>;
<span class="hljs-keyword">var</span> BEFORE = <span class="hljs-string">'before'</span>;
<span class="hljs-keyword">var</span> FIRST = <span class="hljs-string">'first'</span>;
<span class="hljs-keyword">var</span> KEY = <span class="hljs-string">'key'</span>;
<span class="hljs-keyword">var</span> LAST = <span class="hljs-string">'last'</span>;
<span class="hljs-keyword">var</span> CONNECTION = <span class="hljs-string">'connection'</span>;
<span class="hljs-keyword">var</span> STREAM_CONNECTION = <span class="hljs-string">'stream_connection'</span>;
<span class="hljs-keyword">var</span> HANDLER = <span class="hljs-string">'handler'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-321" id="section-321"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connectionTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">Fragment</span>: visitFragmentOrRoot,
    <span class="hljs-attr">LinkedField</span>: visitLinkedField,
    <span class="hljs-attr">Root</span>: visitFragmentOrRoot
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">documentName</span>: node.name,
      <span class="hljs-attr">path</span>: [],
      <span class="hljs-attr">connectionMetadata</span>: []
    };
  });
}

<span class="hljs-keyword">var</span> SCHEMA_EXTENSION = <span class="hljs-string">"\n  directive @connection(\n    key: String!\n    filters: [String]\n    handler: String\n    dynamicKey_UNSTABLE: String\n  ) on FIELD\n\n  directive @stream_connection(\n    key: String!\n    filters: [String]\n    handler: String\n    initial_count: Int!\n    if: Boolean = true\n    use_customized_batch: Boolean = false\n    dynamicKey_UNSTABLE: String\n  ) on FIELD\n"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-322" id="section-322"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragmentOrRoot</span>(<span class="hljs-params">node, options</span>) </span>{
  <span class="hljs-keyword">var</span> transformedNode = <span class="hljs-keyword">this</span>.traverse(node, options);
  <span class="hljs-keyword">var</span> connectionMetadata = options.connectionMetadata;

  <span class="hljs-keyword">if</span> (connectionMetadata.length) {
    <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, transformedNode), {}, {
      <span class="hljs-attr">metadata</span>: _objectSpread(_objectSpread({}, transformedNode.metadata), {}, {
        <span class="hljs-attr">connection</span>: connectionMetadata
      })
    });
  }

  <span class="hljs-keyword">return</span> transformedNode;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-323" id="section-323"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitLinkedField</span>(<span class="hljs-params">field, options</span>) </span>{
  <span class="hljs-keyword">var</span> _connectionArguments$;

  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> nullableType = schema.getNullableType(field.type);
  <span class="hljs-keyword">var</span> isPlural = schema.isList(nullableType);
  <span class="hljs-keyword">var</span> path = options.path.concat(isPlural ? <span class="hljs-literal">null</span> : field.alias || field.name);
  <span class="hljs-keyword">var</span> transformedField = <span class="hljs-keyword">this</span>.traverse(field, _objectSpread(_objectSpread({}, options), {}, {
    <span class="hljs-attr">path</span>: path
  }));
  <span class="hljs-keyword">var</span> connectionDirective = field.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === CONNECTION || directive.name === STREAM_CONNECTION;
  });

  <span class="hljs-keyword">if</span> (!connectionDirective) {
    <span class="hljs-keyword">return</span> transformedField;
  }

  <span class="hljs-keyword">if</span> (!schema.isObject(nullableType) &amp;&amp; !schema.isInterface(nullableType)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> createUserError(<span class="hljs-string">"@"</span>.concat(connectionDirective.name, <span class="hljs-string">" used on invalid field '"</span>).concat(field.name, <span class="hljs-string">"'. "</span>) + <span class="hljs-string">'Expected the return type to be a non-plural interface or object, '</span> + <span class="hljs-string">"got '"</span>.concat(schema.getTypeString(field.type), <span class="hljs-string">"'."</span>), [transformedField.loc]);
  }

  validateConnectionSelection(transformedField);
  validateConnectionType(schema, transformedField, schema.assertCompositeType(nullableType), connectionDirective);
  <span class="hljs-keyword">var</span> connectionArguments = buildConnectionArguments(transformedField, connectionDirective);
  <span class="hljs-keyword">var</span> connectionMetadata = buildConnectionMetadata(transformedField, path, connectionArguments.stream != <span class="hljs-literal">null</span>);
  options.connectionMetadata.push(connectionMetadata);
  <span class="hljs-keyword">var</span> handle = {
    <span class="hljs-attr">name</span>: (_connectionArguments$ = connectionArguments.handler) !== <span class="hljs-literal">null</span> &amp;&amp; _connectionArguments$ !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _connectionArguments$ : CONNECTION,
    <span class="hljs-attr">key</span>: connectionArguments.key,
    <span class="hljs-attr">dynamicKey</span>: connectionArguments.dynamicKey,
    <span class="hljs-attr">filters</span>: connectionArguments.filters
  };
  <span class="hljs-keyword">var</span> direction = connectionMetadata.direction;

  <span class="hljs-keyword">if</span> (direction != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> selections = transformConnectionSelections(<span class="hljs-keyword">this</span>.getContext(), transformedField, schema.assertCompositeType(nullableType), direction, connectionArguments, connectionDirective.loc, options.documentName);
    transformedField = _objectSpread(_objectSpread({}, transformedField), {}, {
      <span class="hljs-attr">selections</span>: selections
    });
  }

  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, transformedField), {}, {
    <span class="hljs-attr">directives</span>: transformedField.directives.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> directive !== connectionDirective;
    }),
    <span class="hljs-attr">connection</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">handles</span>: transformedField.handles ? [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transformedField.handles), [handle]) : [handle]
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildConnectionArguments</span>(<span class="hljs-params">field, connectionDirective</span>) </span>{
  <span class="hljs-keyword">var</span> _getLiteralArgumentVa = getLiteralArgumentValues(connectionDirective.args),
      handler = _getLiteralArgumentVa.handler,
      key = _getLiteralArgumentVa.key,
      label = _getLiteralArgumentVa.label,
      literalFilters = _getLiteralArgumentVa.filters;

  <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> handler !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">var</span> _handleArg$value$loc, _handleArg$value;

    <span class="hljs-keyword">var</span> handleArg = connectionDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'handler'</span>;
    });
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected the "</span>.concat(HANDLER, <span class="hljs-string">" argument to @"</span>).concat(connectionDirective.name, <span class="hljs-string">" to "</span>) + <span class="hljs-string">"be a string literal for field "</span>.concat(field.name, <span class="hljs-string">"."</span>), [(_handleArg$value$loc = handleArg === <span class="hljs-literal">null</span> || handleArg === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : (_handleArg$value = handleArg.value) === <span class="hljs-literal">null</span> || _handleArg$value === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _handleArg$value.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _handleArg$value$loc !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _handleArg$value$loc : connectionDirective.loc]);
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">var</span> _keyArg$value$loc, _keyArg$value;

    <span class="hljs-keyword">var</span> keyArg = connectionDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'key'</span>;
    });
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected the "</span>.concat(KEY, <span class="hljs-string">" argument to @"</span>).concat(connectionDirective.name, <span class="hljs-string">" to be a "</span>) + <span class="hljs-string">"string literal for field "</span>.concat(field.name, <span class="hljs-string">"."</span>), [(_keyArg$value$loc = keyArg === <span class="hljs-literal">null</span> || keyArg === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : (_keyArg$value = keyArg.value) === <span class="hljs-literal">null</span> || _keyArg$value === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _keyArg$value.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _keyArg$value$loc !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _keyArg$value$loc : connectionDirective.loc]);
  }

  <span class="hljs-keyword">var</span> postfix = field.alias || field.name;

  <span class="hljs-keyword">if</span> (!key.endsWith(<span class="hljs-string">'_'</span> + postfix)) {
    <span class="hljs-keyword">var</span> _keyArg$value$loc2, _keyArg$value2;

    <span class="hljs-keyword">var</span> _keyArg = connectionDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'key'</span>;
    });

    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected the "</span>.concat(KEY, <span class="hljs-string">" argument to @"</span>).concat(connectionDirective.name, <span class="hljs-string">" to be of "</span>) + <span class="hljs-string">"form &lt;SomeName&gt;_"</span>.concat(postfix, <span class="hljs-string">", got '"</span>).concat(key, <span class="hljs-string">"'. "</span>) + <span class="hljs-string">'For a detailed explanation, check out '</span> + <span class="hljs-string">'https://relay.dev/docs/en/pagination-container#connection'</span>, [(_keyArg$value$loc2 = _keyArg === <span class="hljs-literal">null</span> || _keyArg === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : (_keyArg$value2 = _keyArg.value) === <span class="hljs-literal">null</span> || _keyArg$value2 === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _keyArg$value2.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _keyArg$value$loc2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _keyArg$value$loc2 : connectionDirective.loc]);
  }

  <span class="hljs-keyword">if</span> (literalFilters != <span class="hljs-literal">null</span> &amp;&amp; (!<span class="hljs-built_in">Array</span>.isArray(literalFilters) || literalFilters.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">filter</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> filter !== <span class="hljs-string">'string'</span>;
  }))) {
    <span class="hljs-keyword">var</span> _filtersArg$value$loc, _filtersArg$value;

    <span class="hljs-keyword">var</span> filtersArg = connectionDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'filters'</span>;
    });
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected the 'filters' argument to @"</span>.concat(connectionDirective.name, <span class="hljs-string">" to be "</span>) + <span class="hljs-string">'a string literal.'</span>, [(_filtersArg$value$loc = filtersArg === <span class="hljs-literal">null</span> || filtersArg === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : (_filtersArg$value = filtersArg.value) === <span class="hljs-literal">null</span> || _filtersArg$value === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _filtersArg$value.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _filtersArg$value$loc !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _filtersArg$value$loc : connectionDirective.loc]);
  }

  <span class="hljs-keyword">var</span> filters = literalFilters;

  <span class="hljs-keyword">if</span> (filters == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> generatedFilters = field.args.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> !ConnectionInterface.isConnectionCall({
        <span class="hljs-attr">name</span>: arg.name,
        <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span>
      });
    }).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> arg.name;
    });
    filters = generatedFilters.length !== <span class="hljs-number">0</span> ? generatedFilters : <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> stream = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (connectionDirective.name === STREAM_CONNECTION) {
    <span class="hljs-keyword">var</span> initialCountArg = connectionDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'initial_count'</span>;
    });
    <span class="hljs-keyword">var</span> useCustomizedBatchArg = connectionDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'use_customized_batch'</span>;
    });
    <span class="hljs-keyword">var</span> ifArg = connectionDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'if'</span>;
    });
    stream = {
      <span class="hljs-string">"if"</span>: ifArg,
      <span class="hljs-attr">initialCount</span>: initialCountArg,
      <span class="hljs-attr">useCustomizedBatch</span>: useCustomizedBatchArg,
      <span class="hljs-attr">label</span>: key
    };
  }

  <span class="hljs-keyword">var</span> dynamicKeyArg = connectionDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'dynamicKey_UNSTABLE'</span>;
  });
  <span class="hljs-keyword">var</span> dynamicKey = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (dynamicKeyArg != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (RelayFeatureFlags.ENABLE_VARIABLE_CONNECTION_KEY &amp;&amp; dynamicKeyArg.value.kind === <span class="hljs-string">'Variable'</span>) {
      dynamicKey = dynamicKeyArg.value;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unsupported 'dynamicKey_UNSTABLE' argument to @"</span>.concat(connectionDirective.name, <span class="hljs-string">". This argument is only valid when the feature flag is enabled and "</span>) + <span class="hljs-string">'the variable must be a variable'</span>, [connectionDirective.loc]);
    }
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">handler</span>: handler,
    <span class="hljs-attr">key</span>: key,
    <span class="hljs-attr">dynamicKey</span>: dynamicKey,
    <span class="hljs-attr">filters</span>: filters,
    <span class="hljs-attr">stream</span>: stream
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildConnectionMetadata</span>(<span class="hljs-params">field, path, stream</span>) </span>{
  <span class="hljs-keyword">var</span> pathHasPlural = path.includes(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">var</span> firstArg = findArg(field, FIRST);
  <span class="hljs-keyword">var</span> lastArg = findArg(field, LAST);
  <span class="hljs-keyword">var</span> direction = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> countArg = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> cursorArg = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (firstArg &amp;&amp; !lastArg) {
    direction = <span class="hljs-string">'forward'</span>;
    countArg = firstArg;
    cursorArg = findArg(field, AFTER);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastArg &amp;&amp; !firstArg) {
    direction = <span class="hljs-string">'backward'</span>;
    countArg = lastArg;
    cursorArg = findArg(field, BEFORE);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lastArg &amp;&amp; firstArg) {
    direction = <span class="hljs-string">'bidirectional'</span>; <span class="hljs-comment">// TODO(T26511885) Maybe add connection metadata to this case</span>
  }

  <span class="hljs-keyword">var</span> countVariable = countArg &amp;&amp; countArg.value.kind === <span class="hljs-string">'Variable'</span> ? countArg.value.variableName : <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> cursorVariable = cursorArg &amp;&amp; cursorArg.value.kind === <span class="hljs-string">'Variable'</span> ? cursorArg.value.variableName : <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (stream) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">count</span>: countVariable,
      <span class="hljs-attr">cursor</span>: cursorVariable,
      <span class="hljs-attr">direction</span>: direction,
      <span class="hljs-attr">path</span>: pathHasPlural ? <span class="hljs-literal">null</span> : path,
      <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span>
    };
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">count</span>: countVariable,
    <span class="hljs-attr">cursor</span>: cursorVariable,
    <span class="hljs-attr">direction</span>: direction,
    <span class="hljs-attr">path</span>: pathHasPlural ? <span class="hljs-literal">null</span> : path
  };
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-324" id="section-324"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformConnectionSelections</span>(<span class="hljs-params">context, field, nullableType, direction, connectionArguments, directiveLocation, documentName</span>) </span>{
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> derivedFieldLocation = {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
    <span class="hljs-attr">source</span>: field.loc
  };
  <span class="hljs-keyword">var</span> derivedDirectiveLocation = {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
    <span class="hljs-attr">source</span>: directiveLocation
  };

  <span class="hljs-keyword">var</span> _ConnectionInterface$ = ConnectionInterface.get(),
      CURSOR = _ConnectionInterface$.CURSOR,
      EDGES = _ConnectionInterface$.EDGES,
      END_CURSOR = _ConnectionInterface$.END_CURSOR,
      HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE,
      HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE,
      NODE = _ConnectionInterface$.NODE,
      PAGE_INFO = _ConnectionInterface$.PAGE_INFO,
      START_CURSOR = _ConnectionInterface$.START_CURSOR; <span class="hljs-comment">// Find existing edges/pageInfo selections</span>


  <span class="hljs-keyword">var</span> edgesSelection;
  <span class="hljs-keyword">var</span> pageInfoSelection;
  field.selections.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'LinkedField'</span>) {
      <span class="hljs-keyword">if</span> (selection.name === EDGES) {
        <span class="hljs-keyword">if</span> (edgesSelection != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"ConnectionTransform: Unexpected duplicate field '"</span>.concat(EDGES, <span class="hljs-string">"'."</span>), [edgesSelection.loc, selection.loc]);
        }

        edgesSelection = selection;
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selection.name === PAGE_INFO) {
        <span class="hljs-keyword">if</span> (pageInfoSelection != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"ConnectionTransform: Unexpected duplicate field '"</span>.concat(PAGE_INFO, <span class="hljs-string">"'."</span>), [pageInfoSelection.loc, selection.loc]);
        }

        pageInfoSelection = selection;
        <span class="hljs-keyword">return</span>;
      }
    }
  }); <span class="hljs-comment">// If streaming is enabled, construct directives to apply to the edges/</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-325" id="section-325"></a>
</div>
<p>pageInfo fields</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  <span class="hljs-keyword">var</span> streamDirective;
  <span class="hljs-keyword">var</span> stream = connectionArguments.stream;

  <span class="hljs-keyword">if</span> (stream != <span class="hljs-literal">null</span>) {
    streamDirective = {
      <span class="hljs-attr">args</span>: [stream[<span class="hljs-string">"if"</span>], stream.initialCount, stream.useCustomizedBatch, {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
        <span class="hljs-attr">loc</span>: derivedDirectiveLocation,
        <span class="hljs-attr">name</span>: <span class="hljs-string">'label'</span>,
        <span class="hljs-attr">type</span>: SchemaUtils.getNullableStringInput(schema),
        <span class="hljs-attr">value</span>: {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
          <span class="hljs-attr">loc</span>: derivedDirectiveLocation,
          <span class="hljs-attr">value</span>: stream.label
        }
      }].filter(<span class="hljs-built_in">Boolean</span>),
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Directive'</span>,
      <span class="hljs-attr">loc</span>: derivedDirectiveLocation,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'stream'</span>
    };
  } <span class="hljs-comment">// For backwards compatibility with earlier versions of this transform,</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-326" id="section-326"></a>
</div>
<p>edges/pageInfo have to be generated as non-aliased fields (since product
code may be accessing the non-aliased response keys). But for streaming
mode we need to generate @stream/@defer directives on these fields <em>and</em>
we prefer to avoid generating extra selections (we want one payload per
item, not two as could happen with separate @stream directives on the
aliased and non-aliased edges fields). So we keep things simple by
disallowing aliases on edges/pageInfo in streaming mode.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">if</span> (edgesSelection &amp;&amp; edgesSelection.alias !== edgesSelection.name) {
    <span class="hljs-keyword">if</span> (stream) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@stream_connection does not support aliasing the '"</span>.concat(EDGES, <span class="hljs-string">"' field."</span>), [edgesSelection.loc]);
    }

    edgesSelection = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">if</span> (pageInfoSelection &amp;&amp; pageInfoSelection.alias !== pageInfoSelection.name) {
    <span class="hljs-keyword">if</span> (stream) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@stream_connection does not support aliasing the '"</span>.concat(PAGE_INFO, <span class="hljs-string">"' field."</span>), [pageInfoSelection.loc]);
    }

    pageInfoSelection = <span class="hljs-literal">null</span>;
  } <span class="hljs-comment">// Separately create transformed versions of edges/pageInfo so that we can</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-327" id="section-327"></a>
</div>
<p>later replace the originals at the same point within the selection array</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">var</span> transformedEdgesSelection = edgesSelection;
  <span class="hljs-keyword">var</span> transformedPageInfoSelection = pageInfoSelection;
  <span class="hljs-keyword">var</span> edgesType = schema.getFieldConfig(schema.expectField(nullableType, EDGES)).type;
  <span class="hljs-keyword">var</span> pageInfoType = schema.getFieldConfig(schema.expectField(nullableType, PAGE_INFO)).type;

  <span class="hljs-keyword">if</span> (transformedEdgesSelection == <span class="hljs-literal">null</span>) {
    transformedEdgesSelection = {
      <span class="hljs-attr">alias</span>: EDGES,
      <span class="hljs-attr">args</span>: [],
      <span class="hljs-attr">connection</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">directives</span>: [],
      <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkedField'</span>,
      <span class="hljs-attr">loc</span>: derivedFieldLocation,
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">name</span>: EDGES,
      <span class="hljs-attr">selections</span>: [],
      <span class="hljs-attr">type</span>: schema.assertLinkedFieldType(edgesType)
    };
  }

  <span class="hljs-keyword">if</span> (transformedPageInfoSelection == <span class="hljs-literal">null</span>) {
    transformedPageInfoSelection = {
      <span class="hljs-attr">alias</span>: PAGE_INFO,
      <span class="hljs-attr">args</span>: [],
      <span class="hljs-attr">connection</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">directives</span>: [],
      <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkedField'</span>,
      <span class="hljs-attr">loc</span>: derivedFieldLocation,
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">name</span>: PAGE_INFO,
      <span class="hljs-attr">selections</span>: [],
      <span class="hljs-attr">type</span>: schema.assertLinkedFieldType(pageInfoType)
    };
  } <span class="hljs-comment">// Generate (additional) fields on pageInfo and add to the transformed</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-328" id="section-328"></a>
</div>
<p>pageInfo field</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">var</span> pageInfoRawType = schema.getRawType(pageInfoType);
  <span class="hljs-keyword">var</span> pageInfoText;

  <span class="hljs-keyword">if</span> (direction === <span class="hljs-string">'forward'</span>) {
    pageInfoText = <span class="hljs-string">"fragment PageInfo on "</span>.concat(schema.getTypeString(pageInfoRawType), <span class="hljs-string">" {\n      "</span>).concat(END_CURSOR, <span class="hljs-string">"\n      "</span>).concat(HAS_NEXT_PAGE, <span class="hljs-string">"\n    }"</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (direction === <span class="hljs-string">'backward'</span>) {
    pageInfoText = <span class="hljs-string">"fragment PageInfo on "</span>.concat(schema.getTypeString(pageInfoRawType), <span class="hljs-string">"  {\n      "</span>).concat(HAS_PREV_PAGE, <span class="hljs-string">"\n      "</span>).concat(START_CURSOR, <span class="hljs-string">"\n    }"</span>);
  } <span class="hljs-keyword">else</span> {
    pageInfoText = <span class="hljs-string">"fragment PageInfo on "</span>.concat(schema.getTypeString(pageInfoRawType), <span class="hljs-string">"  {\n      "</span>).concat(END_CURSOR, <span class="hljs-string">"\n      "</span>).concat(HAS_NEXT_PAGE, <span class="hljs-string">"\n      "</span>).concat(HAS_PREV_PAGE, <span class="hljs-string">"\n      "</span>).concat(START_CURSOR, <span class="hljs-string">"\n    }"</span>);
  }

  <span class="hljs-keyword">var</span> pageInfoAst = parse(pageInfoText);
  <span class="hljs-keyword">var</span> pageInfoFragment = RelayParser.transform(schema, [pageInfoAst.definitions[<span class="hljs-number">0</span>]])[<span class="hljs-number">0</span>];

  <span class="hljs-keyword">if</span> (transformedPageInfoSelection.kind !== <span class="hljs-string">'LinkedField'</span>) {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">'ConnectionTransform: Expected generated pageInfo selection to be '</span> + <span class="hljs-string">'a LinkedField'</span>, [field.loc]);
  }

  transformedPageInfoSelection = _objectSpread(_objectSpread({}, transformedPageInfoSelection), {}, {
    <span class="hljs-attr">selections</span>: [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transformedPageInfoSelection.selections), [{
      <span class="hljs-attr">directives</span>: [],
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineFragment'</span>,
      <span class="hljs-attr">loc</span>: derivedFieldLocation,
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">selections</span>: pageInfoFragment.selections,
      <span class="hljs-attr">typeCondition</span>: pageInfoFragment.type
    }])
  }); <span class="hljs-comment">// When streaming the pageInfo field has to be deferred</span>

  <span class="hljs-keyword">if</span> (stream != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> _stream$<span class="hljs-keyword">if</span>$value, _stream$<span class="hljs-keyword">if</span>;

    transformedPageInfoSelection = {
      <span class="hljs-string">"if"</span>: (_stream$<span class="hljs-keyword">if</span>$value = (_stream$<span class="hljs-keyword">if</span> = stream[<span class="hljs-string">"if"</span>]) === <span class="hljs-literal">null</span> || _stream$<span class="hljs-keyword">if</span> === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : _stream$<span class="hljs-keyword">if</span>.value) !== <span class="hljs-literal">null</span> &amp;&amp; _stream$<span class="hljs-keyword">if</span>$value !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _stream$<span class="hljs-keyword">if</span>$value : <span class="hljs-literal">null</span>,
      <span class="hljs-attr">label</span>: <span class="hljs-string">""</span>.concat(documentName, <span class="hljs-string">"$defer$"</span>).concat(stream.label, <span class="hljs-string">"$"</span>).concat(PAGE_INFO),
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Defer'</span>,
      <span class="hljs-attr">loc</span>: derivedFieldLocation,
      <span class="hljs-attr">selections</span>: [transformedPageInfoSelection]
    };
  } <span class="hljs-comment">// Generate additional fields on edges and append to the transformed edges</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-329" id="section-329"></a>
</div>
<p>selection</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">var</span> edgeText = <span class="hljs-string">"\n    fragment Edges on "</span>.concat(schema.getTypeString(schema.getRawType(edgesType)), <span class="hljs-string">" {\n      "</span>).concat(CURSOR, <span class="hljs-string">"\n      "</span>).concat(NODE, <span class="hljs-string">" {\n        __typename # rely on GenerateRequisiteFieldTransform to add \"id\"\n      }\n    }\n  "</span>);
  <span class="hljs-keyword">var</span> edgeAst = parse(edgeText);
  <span class="hljs-keyword">var</span> edgeFragment = RelayParser.transform(schema, [edgeAst.definitions[<span class="hljs-number">0</span>]])[<span class="hljs-number">0</span>]; <span class="hljs-comment">// When streaming the edges field needs @stream</span>

  transformedEdgesSelection = _objectSpread(_objectSpread({}, transformedEdgesSelection), {}, {
    <span class="hljs-attr">directives</span>: streamDirective != <span class="hljs-literal">null</span> ? [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transformedEdgesSelection.directives), [streamDirective]) : transformedEdgesSelection.directives,
    <span class="hljs-attr">selections</span>: [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transformedEdgesSelection.selections), [{
      <span class="hljs-attr">directives</span>: [],
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineFragment'</span>,
      <span class="hljs-attr">loc</span>: derivedFieldLocation,
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">selections</span>: edgeFragment.selections,
      <span class="hljs-attr">typeCondition</span>: edgeFragment.type
    }])
  }); <span class="hljs-comment">// Copy the original selections, replacing edges/pageInfo (if present)</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-330" id="section-330"></a>
</div>
<p>with the generated locations. This is to maintain the original field
ordering.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  <span class="hljs-keyword">var</span> selections = field.selections.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">if</span> (transformedEdgesSelection != <span class="hljs-literal">null</span> &amp;&amp; edgesSelection != <span class="hljs-literal">null</span> &amp;&amp; selection === edgesSelection) {
      <span class="hljs-keyword">return</span> transformedEdgesSelection;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (transformedPageInfoSelection != <span class="hljs-literal">null</span> &amp;&amp; pageInfoSelection != <span class="hljs-literal">null</span> &amp;&amp; selection === pageInfoSelection) {
      <span class="hljs-keyword">return</span> transformedPageInfoSelection;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> selection;
    }
  }); <span class="hljs-comment">// If edges/pageInfo were missing, append the generated versions instead.</span>

  <span class="hljs-keyword">if</span> (edgesSelection == <span class="hljs-literal">null</span> &amp;&amp; transformedEdgesSelection != <span class="hljs-literal">null</span>) {
    selections.push(transformedEdgesSelection);
  }

  <span class="hljs-keyword">if</span> (pageInfoSelection == <span class="hljs-literal">null</span> &amp;&amp; transformedPageInfoSelection != <span class="hljs-literal">null</span>) {
    selections.push(transformedPageInfoSelection);
  }

  <span class="hljs-keyword">return</span> selections;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findArg</span>(<span class="hljs-params">field, argName</span>) </span>{
  <span class="hljs-keyword">return</span> field.args &amp;&amp; field.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === argName;
  });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-331" id="section-331"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateConnectionSelection</span>(<span class="hljs-params">field</span>) </span>{
  <span class="hljs-keyword">var</span> _ConnectionInterface$<span class="hljs-number">2</span> = ConnectionInterface.get(),
      EDGES = _ConnectionInterface$<span class="hljs-number">2.</span>EDGES;

  <span class="hljs-keyword">if</span> (!findArg(field, FIRST) &amp;&amp; !findArg(field, LAST)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected field '"</span>.concat(field.name, <span class="hljs-string">"' to have a '"</span>).concat(FIRST, <span class="hljs-string">"' or '"</span>).concat(LAST, <span class="hljs-string">"' "</span>) + <span class="hljs-string">'argument.'</span>, [field.loc]);
  }

  <span class="hljs-keyword">if</span> (!field.selections.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">return</span> selection.kind === <span class="hljs-string">'LinkedField'</span> &amp;&amp; selection.name === EDGES;
  })) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected field '"</span>.concat(field.name, <span class="hljs-string">"' to have an '"</span>).concat(EDGES, <span class="hljs-string">"' selection."</span>), [field.loc]);
  }
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-332" id="section-332"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateConnectionType</span>(<span class="hljs-params">schema, field, nullableType, connectionDirective</span>) </span>{
  <span class="hljs-keyword">var</span> directiveName = connectionDirective.name;

  <span class="hljs-keyword">var</span> _ConnectionInterface$<span class="hljs-number">3</span> = ConnectionInterface.get(),
      CURSOR = _ConnectionInterface$<span class="hljs-number">3.</span>CURSOR,
      EDGES = _ConnectionInterface$<span class="hljs-number">3.</span>EDGES,
      END_CURSOR = _ConnectionInterface$<span class="hljs-number">3.</span>END_CURSOR,
      HAS_NEXT_PAGE = _ConnectionInterface$<span class="hljs-number">3.</span>HAS_NEXT_PAGE,
      HAS_PREV_PAGE = _ConnectionInterface$<span class="hljs-number">3.</span>HAS_PREV_PAGE,
      NODE = _ConnectionInterface$<span class="hljs-number">3.</span>NODE,
      PAGE_INFO = _ConnectionInterface$<span class="hljs-number">3.</span>PAGE_INFO,
      START_CURSOR = _ConnectionInterface$<span class="hljs-number">3.</span>START_CURSOR;

  <span class="hljs-keyword">var</span> typeName = schema.getTypeString(nullableType);

  <span class="hljs-keyword">if</span> (!schema.hasField(nullableType, EDGES)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@"</span>.concat(directiveName, <span class="hljs-string">" used on invalid field '"</span>).concat(field.name, <span class="hljs-string">"'. Expected the "</span>) + <span class="hljs-string">"field type '"</span>.concat(typeName, <span class="hljs-string">"' to have an '"</span>).concat(EDGES, <span class="hljs-string">"' field"</span>), [field.loc]);
  }

  <span class="hljs-keyword">var</span> edges = schema.getFieldConfig(schema.expectField(nullableType, EDGES));
  <span class="hljs-keyword">var</span> edgesType = schema.getNullableType(edges.type);

  <span class="hljs-keyword">if</span> (!schema.isList(edgesType)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@"</span>.concat(directiveName, <span class="hljs-string">" used on invalid field '"</span>).concat(field.name, <span class="hljs-string">"'. Expected the "</span>) + <span class="hljs-string">"field type '"</span>.concat(typeName, <span class="hljs-string">"' to have an '"</span>).concat(EDGES, <span class="hljs-string">"' field that returns "</span>) + <span class="hljs-string">'a list of objects.'</span>, [field.loc]);
  }

  <span class="hljs-keyword">var</span> edgeType = schema.getNullableType(schema.getListItemType(edgesType));

  <span class="hljs-keyword">if</span> (!schema.isObject(edgeType) &amp;&amp; !schema.isInterface(edgeType)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@"</span>.concat(directiveName, <span class="hljs-string">" used on invalid field '"</span>).concat(field.name, <span class="hljs-string">"'. Expected the "</span>) + <span class="hljs-string">"field type '"</span>.concat(typeName, <span class="hljs-string">"' to have an '"</span>).concat(EDGES, <span class="hljs-string">"' field that returns "</span>) + <span class="hljs-string">'a list of objects.'</span>, [field.loc]);
  }

  edgeType = schema.assertCompositeType(edgeType);

  <span class="hljs-keyword">if</span> (!schema.hasField(edgeType, NODE)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@"</span>.concat(directiveName, <span class="hljs-string">" used on invalid field '"</span>).concat(field.name, <span class="hljs-string">"'. Expected the "</span>) + <span class="hljs-string">"field type '"</span>.concat(typeName, <span class="hljs-string">"' to have an '"</span>).concat(EDGES, <span class="hljs-string">" { "</span>).concat(NODE, <span class="hljs-string">" }' field "</span>) + <span class="hljs-string">'that returns an object, interface, or union.'</span>, [field.loc]);
  }

  <span class="hljs-keyword">var</span> node = schema.getFieldConfig(schema.expectField(edgeType, NODE));
  <span class="hljs-keyword">var</span> nodeType = schema.getNullableType(node.type);

  <span class="hljs-keyword">if</span> (!(schema.isAbstractType(nodeType) || schema.isObject(nodeType))) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@"</span>.concat(directiveName, <span class="hljs-string">" used on invalid field '"</span>).concat(field.name, <span class="hljs-string">"'. Expected the "</span>) + <span class="hljs-string">"field type '"</span>.concat(typeName, <span class="hljs-string">"' to have an '"</span>).concat(EDGES, <span class="hljs-string">" { "</span>).concat(NODE, <span class="hljs-string">" }' field "</span>) + <span class="hljs-string">'that returns an object, interface, or union.'</span>, [field.loc]);
  }

  <span class="hljs-keyword">if</span> (!schema.hasField(edgeType, CURSOR)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@"</span>.concat(directiveName, <span class="hljs-string">" used on invalid field '"</span>).concat(field.name, <span class="hljs-string">"'. Expected the "</span>) + <span class="hljs-string">"field type '"</span>.concat(typeName, <span class="hljs-string">"' to have an '"</span>).concat(EDGES, <span class="hljs-string">" { "</span>).concat(CURSOR, <span class="hljs-string">" }' field "</span>) + <span class="hljs-string">'that returns a scalar value.'</span>, [field.loc]);
  }

  <span class="hljs-keyword">var</span> cursor = schema.getFieldConfig(schema.expectField(edgeType, CURSOR));

  <span class="hljs-keyword">if</span> (!schema.isScalar(schema.getNullableType(cursor.type))) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@"</span>.concat(directiveName, <span class="hljs-string">" used on invalid field '"</span>).concat(field.name, <span class="hljs-string">"'. Expected the "</span>) + <span class="hljs-string">"field type '"</span>.concat(typeName, <span class="hljs-string">"' to have an '"</span>).concat(EDGES, <span class="hljs-string">" { "</span>).concat(CURSOR, <span class="hljs-string">" }' field "</span>) + <span class="hljs-string">'that returns a scalar value.'</span>, [field.loc]);
  }

  <span class="hljs-keyword">if</span> (!schema.hasField(nullableType, PAGE_INFO)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@"</span>.concat(directiveName, <span class="hljs-string">" used on invalid field '"</span>).concat(field.name, <span class="hljs-string">"'. Expected the "</span>) + <span class="hljs-string">"field type '"</span>.concat(typeName, <span class="hljs-string">"' to have a '"</span>).concat(PAGE_INFO, <span class="hljs-string">"' field that returns "</span>) + <span class="hljs-string">'an object.'</span>, [field.loc]);
  }

  <span class="hljs-keyword">var</span> pageInfo = schema.getFieldConfig(schema.expectField(nullableType, PAGE_INFO));
  <span class="hljs-keyword">var</span> pageInfoType = schema.getNullableType(pageInfo.type);

  <span class="hljs-keyword">if</span> (!schema.isObject(pageInfoType)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@"</span>.concat(directiveName, <span class="hljs-string">" used on invalid field '"</span>).concat(field.name, <span class="hljs-string">"'. Expected the "</span>) + <span class="hljs-string">"field type '"</span>.concat(typeName, <span class="hljs-string">"' to have a '"</span>).concat(PAGE_INFO, <span class="hljs-string">"' field that "</span>) + <span class="hljs-string">'returns an object.'</span>, [field.loc]);
  }

  [END_CURSOR, HAS_NEXT_PAGE, HAS_PREV_PAGE, START_CURSOR].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fieldName</span>) </span>{
    <span class="hljs-keyword">var</span> pageInfoField = schema.getFieldConfig(schema.expectField(schema.assertObjectType(pageInfoType), fieldName));

    <span class="hljs-keyword">if</span> (!schema.isScalar(schema.getNullableType(pageInfoField.type))) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"@"</span>.concat(directiveName, <span class="hljs-string">" used on invalid field '"</span>).concat(field.name, <span class="hljs-string">"'. Expected "</span>) + <span class="hljs-string">"the field type '"</span>.concat(typeName, <span class="hljs-string">"' to have a '"</span>).concat(PAGE_INFO, <span class="hljs-string">" { "</span>).concat(fieldName, <span class="hljs-string">" }' "</span>) + <span class="hljs-string">'field returns a scalar.'</span>, [field.loc]);
    }
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">buildConnectionMetadata</span>: buildConnectionMetadata,
  <span class="hljs-attr">CONNECTION</span>: CONNECTION,
  <span class="hljs-attr">SCHEMA_EXTENSION</span>: SCHEMA_EXTENSION,
  <span class="hljs-attr">transform</span>: connectionTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 80 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-333" id="section-333"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">10</span>),
    ConnectionInterface = _require2.ConnectionInterface;

<span class="hljs-keyword">var</span> DELETE_RECORD = <span class="hljs-string">'deleteRecord'</span>;
<span class="hljs-keyword">var</span> DELETE_EDGE = <span class="hljs-string">'deleteEdge'</span>;
<span class="hljs-keyword">var</span> APPEND_EDGE = <span class="hljs-string">'appendEdge'</span>;
<span class="hljs-keyword">var</span> PREPEND_EDGE = <span class="hljs-string">'prependEdge'</span>;
<span class="hljs-keyword">var</span> APPEND_NODE = <span class="hljs-string">'appendNode'</span>;
<span class="hljs-keyword">var</span> PREPEND_NODE = <span class="hljs-string">'prependNode'</span>;
<span class="hljs-keyword">var</span> EDGE_LINKED_FIELD_DIRECTIVES = [APPEND_EDGE, PREPEND_EDGE];
<span class="hljs-keyword">var</span> NODE_LINKED_FIELD_DIRECTIVES = [APPEND_NODE, PREPEND_NODE];
<span class="hljs-keyword">var</span> LINKED_FIELD_DIRECTIVES = [].concat(EDGE_LINKED_FIELD_DIRECTIVES, NODE_LINKED_FIELD_DIRECTIVES);
<span class="hljs-keyword">var</span> SCHEMA_EXTENSION = <span class="hljs-string">"\n  directive @"</span>.concat(DELETE_RECORD, <span class="hljs-string">" on FIELD\n  directive @"</span>).concat(DELETE_EDGE, <span class="hljs-string">"(\n    connections: [ID!]!\n  ) on FIELD\n  directive @"</span>).concat(APPEND_EDGE, <span class="hljs-string">"(\n    connections: [ID!]!\n  ) on FIELD\n  directive @"</span>).concat(PREPEND_EDGE, <span class="hljs-string">"(\n    connections: [ID!]!\n  ) on FIELD\n  directive @"</span>).concat(APPEND_NODE, <span class="hljs-string">"(\n    connections: [ID!]!\n    edgeTypeName: String!\n  ) on FIELD\n  directive @"</span>).concat(PREPEND_NODE, <span class="hljs-string">"(\n    connections: [ID!]!\n    edgeTypeName: String!\n  ) on FIELD\n"</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">ScalarField</span>: visitScalarField,
    <span class="hljs-attr">LinkedField</span>: visitLinkedField,
    <span class="hljs-attr">SplitOperation</span>: skip,
    <span class="hljs-attr">Fragment</span>: skip
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skip</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">return</span> node;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitScalarField</span>(<span class="hljs-params">field</span>) </span>{
  <span class="hljs-keyword">var</span> linkedFieldDirective = field.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> LINKED_FIELD_DIRECTIVES.indexOf(directive.name) &gt; <span class="hljs-number">-1</span>;
  });

  <span class="hljs-keyword">if</span> (linkedFieldDirective != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @"</span>.concat(linkedFieldDirective.name, <span class="hljs-string">" on scalar field '"</span>).concat(field.name, <span class="hljs-string">"'"</span>), [linkedFieldDirective.loc]);
  }

  <span class="hljs-keyword">var</span> deleteNodeDirective = field.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === DELETE_RECORD;
  });
  <span class="hljs-keyword">var</span> deleteEdgeDirective = field.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === DELETE_EDGE;
  });

  <span class="hljs-keyword">if</span> (deleteNodeDirective != <span class="hljs-literal">null</span> &amp;&amp; deleteEdgeDirective != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Both @deleteNode and @deleteEdge are used on field '"</span>.concat(field.name, <span class="hljs-string">"'. Only one directive is supported for now."</span>), [deleteNodeDirective.loc, deleteEdgeDirective.loc]);
  }

  <span class="hljs-keyword">var</span> targetDirective = deleteNodeDirective !== <span class="hljs-literal">null</span> &amp;&amp; deleteNodeDirective !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? deleteNodeDirective : deleteEdgeDirective;

  <span class="hljs-keyword">if</span> (targetDirective == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> field;
  }

  <span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">this</span>.getContext().getSchema();

  <span class="hljs-keyword">if</span> (!schema.isId(schema.getRawType(field.type))) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @"</span>.concat(targetDirective.name, <span class="hljs-string">" on field '"</span>).concat(field.name, <span class="hljs-string">"'. Expected field to return an ID or list of ID values, got "</span>).concat(schema.getTypeString(field.type), <span class="hljs-string">"."</span>), [targetDirective.loc]);
  }

  <span class="hljs-keyword">var</span> connectionsArg = targetDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'connections'</span>;
  });
  <span class="hljs-keyword">var</span> handle = {
    <span class="hljs-attr">name</span>: targetDirective.name,
    <span class="hljs-attr">key</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">dynamicKey</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">filters</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">handleArgs</span>: connectionsArg ? [connectionsArg] : <span class="hljs-literal">undefined</span>
  };
  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, field), {}, {
    <span class="hljs-attr">directives</span>: field.directives.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> directive !== targetDirective;
    }),
    <span class="hljs-attr">handles</span>: field.handles ? [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(field.handles), [handle]) : [handle]
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitLinkedField</span>(<span class="hljs-params">field</span>) </span>{
  <span class="hljs-keyword">var</span> transformedField = <span class="hljs-keyword">this</span>.traverse(field);
  <span class="hljs-keyword">var</span> deleteDirective = transformedField.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === DELETE_RECORD;
  });

  <span class="hljs-keyword">if</span> (deleteDirective != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @"</span>.concat(deleteDirective.name, <span class="hljs-string">" on scalar field '"</span>).concat(transformedField.name, <span class="hljs-string">"'."</span>), [deleteDirective.loc]);
  }

  <span class="hljs-keyword">var</span> edgeDirective = transformedField.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> EDGE_LINKED_FIELD_DIRECTIVES.indexOf(directive.name) &gt; <span class="hljs-number">-1</span>;
  });
  <span class="hljs-keyword">var</span> nodeDirective = transformedField.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> NODE_LINKED_FIELD_DIRECTIVES.indexOf(directive.name) &gt; <span class="hljs-number">-1</span>;
  });

  <span class="hljs-keyword">if</span> (edgeDirective == <span class="hljs-literal">null</span> &amp;&amp; nodeDirective == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> transformedField;
  }

  <span class="hljs-keyword">if</span> (edgeDirective != <span class="hljs-literal">null</span> &amp;&amp; nodeDirective != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @"</span>.concat(edgeDirective.name, <span class="hljs-string">" and @"</span>).concat(nodeDirective.name, <span class="hljs-string">" on field '"</span>).concat(transformedField.name, <span class="hljs-string">"' - these directives cannot be used together."</span>), [edgeDirective.loc]);
  }

  <span class="hljs-keyword">var</span> targetDirective = edgeDirective !== <span class="hljs-literal">null</span> &amp;&amp; edgeDirective !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? edgeDirective : nodeDirective;
  <span class="hljs-keyword">var</span> connectionsArg = targetDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'connections'</span>;
  });

  <span class="hljs-keyword">if</span> (connectionsArg == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected the 'connections' argument to be defined on @"</span>.concat(targetDirective.name, <span class="hljs-string">"."</span>), [targetDirective.loc]);
  }

  <span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">this</span>.getContext().getSchema();

  <span class="hljs-keyword">if</span> (edgeDirective) {
    <span class="hljs-keyword">var</span> fields = schema.getFields(transformedField.type);
    <span class="hljs-keyword">var</span> cursorFieldID;
    <span class="hljs-keyword">var</span> nodeFieldID;

    <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(fields),
        _step;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
        <span class="hljs-keyword">var</span> fieldID = _step.value;
        <span class="hljs-keyword">var</span> fieldName = schema.getFieldName(fieldID);

        <span class="hljs-keyword">if</span> (fieldName === ConnectionInterface.get().CURSOR) {
          cursorFieldID = fieldID;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fieldName === ConnectionInterface.get().NODE) {
          nodeFieldID = fieldID;
        }
      } <span class="hljs-comment">// Edge</span>

    } <span class="hljs-keyword">catch</span> (err) {
      _iterator.e(err);
    } <span class="hljs-keyword">finally</span> {
      _iterator.f();
    }

    <span class="hljs-keyword">if</span> (cursorFieldID != <span class="hljs-literal">null</span> &amp;&amp; nodeFieldID != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> handle = {
        <span class="hljs-attr">name</span>: edgeDirective.name,
        <span class="hljs-attr">key</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">dynamicKey</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">filters</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">handleArgs</span>: [connectionsArg]
      };
      <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, transformedField), {}, {
        <span class="hljs-attr">directives</span>: transformedField.directives.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
          <span class="hljs-keyword">return</span> directive !== edgeDirective;
        }),
        <span class="hljs-attr">handles</span>: transformedField.handles ? [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transformedField.handles), [handle]) : [handle]
      });
    }

    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unsupported use of @"</span>.concat(edgeDirective.name, <span class="hljs-string">" on field '"</span>).concat(transformedField.name, <span class="hljs-string">"', expected an edge field (a field with 'cursor' and 'node' selection)."</span>), [targetDirective.loc]);
  } <span class="hljs-keyword">else</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-334" id="section-334"></a>
</div>
<p>Node</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">var</span> edgeTypeNameArg = nodeDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'edgeTypeName'</span>;
    });

    <span class="hljs-keyword">if</span> (!edgeTypeNameArg) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unsupported use of @"</span>.concat(nodeDirective.name, <span class="hljs-string">" on field '"</span>).concat(transformedField.name, <span class="hljs-string">"', 'edgeTypeName' argument must be provided."</span>), [targetDirective.loc]);
    }

    <span class="hljs-keyword">var</span> rawType = schema.getRawType(transformedField.type);

    <span class="hljs-keyword">if</span> (schema.canHaveSelections(rawType)) {
      <span class="hljs-keyword">var</span> _handle = {
        <span class="hljs-attr">name</span>: nodeDirective.name,
        <span class="hljs-attr">key</span>: <span class="hljs-string">''</span>,
        <span class="hljs-attr">dynamicKey</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">filters</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">handleArgs</span>: [connectionsArg, edgeTypeNameArg]
      };
      <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, transformedField), {}, {
        <span class="hljs-attr">directives</span>: transformedField.directives.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
          <span class="hljs-keyword">return</span> directive !== nodeDirective;
        }),
        <span class="hljs-attr">handles</span>: transformedField.handles ? [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transformedField.handles), [_handle]) : [_handle]
      });
    }

    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unsupported use of @"</span>.concat(nodeDirective.name, <span class="hljs-string">" on field '"</span>).concat(transformedField.name, <span class="hljs-string">"'. Expected an object, union or interface, but got '"</span>).concat(schema.getTypeString(transformedField.type), <span class="hljs-string">"'."</span>), [nodeDirective.loc]);
  }
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">SCHEMA_EXTENSION</span>: SCHEMA_EXTENSION,
  <span class="hljs-attr">transform</span>: transform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 81 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-335" id="section-335"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> getIdentifierForArgumentValue = __webpack_require__(<span class="hljs-number">35</span>);

<span class="hljs-keyword">var</span> murmurHash = __webpack_require__(<span class="hljs-number">36</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-336" id="section-336"></a>
</div>
<div class="dox">
<div class="summary">
<p>This transform finds usages of @defer and @stream, validates them, and
converts the using node to specialized IR nodes (Defer/Stream).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deferStreamTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-337" id="section-337"></a>
</div>
<p>TODO: type IRTransformer to allow changing result type</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    FragmentSpread: visitFragmentSpread,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-338" id="section-338"></a>
</div>
<p>TODO: type IRTransformer to allow changing result type</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    InlineFragment: visitInlineFragment,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-339" id="section-339"></a>
</div>
<p>TODO: type IRTransformer to allow changing result type</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    LinkedField: visitLinkedField,
    <span class="hljs-attr">ScalarField</span>: visitScalarField
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sourceNode</span>) </span>{
    <span class="hljs-keyword">var</span> labels = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">documentName</span>: sourceNode.name,
      <span class="hljs-attr">recordLabel</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recordLabel</span>(<span class="hljs-params">label, directive</span>) </span>{
        <span class="hljs-keyword">var</span> prevDirective = labels.get(label);

        <span class="hljs-keyword">if</span> (prevDirective) {
          <span class="hljs-keyword">var</span> _prevLabelArg$loc;

          <span class="hljs-keyword">var</span> labelArg = directive.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref</span>) </span>{
            <span class="hljs-keyword">var</span> name = _ref.name;
            <span class="hljs-keyword">return</span> name === <span class="hljs-string">'label'</span>;
          });
          <span class="hljs-keyword">var</span> prevLabelArg = prevDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref2</span>) </span>{
            <span class="hljs-keyword">var</span> name = _ref2.name;
            <span class="hljs-keyword">return</span> name === <span class="hljs-string">'label'</span>;
          });
          <span class="hljs-keyword">var</span> previousLocation = (_prevLabelArg$loc = prevLabelArg === <span class="hljs-literal">null</span> || prevLabelArg === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : prevLabelArg.loc) !== <span class="hljs-literal">null</span> &amp;&amp; _prevLabelArg$loc !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _prevLabelArg$loc : prevDirective.loc;

          <span class="hljs-keyword">if</span> (labelArg) {
            <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @"</span>.concat(directive.name, <span class="hljs-string">", the provided label is "</span>) + <span class="hljs-string">"not unique. Specify a unique 'label' as a literal string."</span>, [labelArg === <span class="hljs-literal">null</span> || labelArg === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : labelArg.loc, previousLocation]);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @"</span>.concat(directive.name, <span class="hljs-string">", could not generate a "</span>) + <span class="hljs-string">"default label that is unique. Specify a unique 'label' "</span> + <span class="hljs-string">'as a literal string.'</span>, [directive.loc, previousLocation]);
          }
        }

        labels.set(label, directive);
      }
    };
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitLinkedField</span>(<span class="hljs-params">field, state</span>) </span>{
  <span class="hljs-keyword">var</span> _getLiteralStringArgu, _ifArg$value, _useCustomizedBatch$v;

  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> transformedField = <span class="hljs-keyword">this</span>.traverse(field, state);
  <span class="hljs-keyword">var</span> streamDirective = transformedField.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'stream'</span>;
  });

  <span class="hljs-keyword">if</span> (streamDirective == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> transformedField;
  }

  <span class="hljs-keyword">var</span> type = schema.getNullableType(field.type);

  <span class="hljs-keyword">if</span> (!schema.isList(type)) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @stream on non-plural field '"</span>.concat(field.name, <span class="hljs-string">"'"</span>), [streamDirective.loc]);
  }

  transformedField = _objectSpread(_objectSpread({}, transformedField), {}, {
    <span class="hljs-attr">directives</span>: transformedField.directives.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> directive.name !== <span class="hljs-string">'stream'</span>;
    })
  });
  <span class="hljs-keyword">var</span> ifArg = streamDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'if'</span>;
  });

  <span class="hljs-keyword">if</span> (isLiteralFalse(ifArg)) {
    <span class="hljs-keyword">return</span> transformedField;
  }

  <span class="hljs-keyword">var</span> initialCount = streamDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'initial_count'</span>;
  });

  <span class="hljs-keyword">if</span> (initialCount == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @stream, the 'initial_count' argument is required."</span>, [streamDirective.loc]);
  }

  <span class="hljs-keyword">var</span> useCustomizedBatch = streamDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'use_customized_batch'</span>;
  });
  <span class="hljs-keyword">var</span> label = (_getLiteralStringArgu = getLiteralStringArgument(streamDirective, <span class="hljs-string">'label'</span>)) !== <span class="hljs-literal">null</span> &amp;&amp; _getLiteralStringArgu !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _getLiteralStringArgu : field.alias;
  <span class="hljs-keyword">var</span> transformedLabel = transformLabel(state.documentName, <span class="hljs-string">'stream'</span>, label);
  state.recordLabel(transformedLabel, streamDirective);
  <span class="hljs-keyword">return</span> {
    <span class="hljs-string">"if"</span>: (_ifArg$value = ifArg === <span class="hljs-literal">null</span> || ifArg === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : ifArg.value) !== <span class="hljs-literal">null</span> &amp;&amp; _ifArg$value !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _ifArg$value : <span class="hljs-literal">null</span>,
    <span class="hljs-attr">initialCount</span>: initialCount.value,
    <span class="hljs-attr">useCustomizedBatch</span>: (_useCustomizedBatch$v = useCustomizedBatch === <span class="hljs-literal">null</span> || useCustomizedBatch === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : useCustomizedBatch.value) !== <span class="hljs-literal">null</span> &amp;&amp; _useCustomizedBatch$v !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _useCustomizedBatch$v : <span class="hljs-literal">null</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Stream'</span>,
    <span class="hljs-attr">label</span>: transformedLabel,
    <span class="hljs-attr">loc</span>: {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
      <span class="hljs-attr">source</span>: streamDirective.loc
    },
    <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">selections</span>: [transformedField]
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitScalarField</span>(<span class="hljs-params">field, state</span>) </span>{
  <span class="hljs-keyword">var</span> streamDirective = field.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'stream'</span>;
  });

  <span class="hljs-keyword">if</span> (streamDirective != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @stream on scalar field '"</span>.concat(field.name, <span class="hljs-string">"'"</span>), [streamDirective.loc]);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(field, state);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitInlineFragment</span>(<span class="hljs-params">fragment, state</span>) </span>{
  <span class="hljs-keyword">var</span> deferDirective = fragment.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'defer'</span>;
  });

  <span class="hljs-keyword">if</span> (deferDirective != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Invalid use of @defer on an inline fragment, @defer is only supported on fragment spreads.'</span>, [fragment.loc]);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(fragment, state);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragmentSpread</span>(<span class="hljs-params">spread, state</span>) </span>{
  <span class="hljs-keyword">var</span> _getLiteralStringArgu2, _ifArg$value2;

  <span class="hljs-keyword">var</span> transformedSpread = <span class="hljs-keyword">this</span>.traverse(spread, state);
  <span class="hljs-keyword">var</span> deferDirective = transformedSpread.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'defer'</span>;
  });

  <span class="hljs-keyword">if</span> (deferDirective == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> transformedSpread;
  }

  transformedSpread = _objectSpread(_objectSpread({}, transformedSpread), {}, {
    <span class="hljs-attr">directives</span>: transformedSpread.directives.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> directive.name !== <span class="hljs-string">'defer'</span>;
    })
  });
  <span class="hljs-keyword">var</span> ifArg = deferDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'if'</span>;
  });

  <span class="hljs-keyword">if</span> (isLiteralFalse(ifArg)) {
    <span class="hljs-keyword">return</span> transformedSpread;
  }

  <span class="hljs-keyword">var</span> label = (_getLiteralStringArgu2 = getLiteralStringArgument(deferDirective, <span class="hljs-string">'label'</span>)) !== <span class="hljs-literal">null</span> &amp;&amp; _getLiteralStringArgu2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _getLiteralStringArgu2 : getFragmentSpreadName(spread);
  <span class="hljs-keyword">var</span> transformedLabel = transformLabel(state.documentName, <span class="hljs-string">'defer'</span>, label);
  state.recordLabel(transformedLabel, deferDirective);
  <span class="hljs-keyword">return</span> {
    <span class="hljs-string">"if"</span>: (_ifArg$value2 = ifArg === <span class="hljs-literal">null</span> || ifArg === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : ifArg.value) !== <span class="hljs-literal">null</span> &amp;&amp; _ifArg$value2 !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _ifArg$value2 : <span class="hljs-literal">null</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'Defer'</span>,
    <span class="hljs-attr">label</span>: transformedLabel,
    <span class="hljs-attr">loc</span>: {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
      <span class="hljs-attr">source</span>: deferDirective.loc
    },
    <span class="hljs-attr">selections</span>: [transformedSpread]
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLiteralStringArgument</span>(<span class="hljs-params">directive, argName</span>) </span>{
  <span class="hljs-keyword">var</span> arg = directive.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref3</span>) </span>{
    <span class="hljs-keyword">var</span> name = _ref3.name;
    <span class="hljs-keyword">return</span> name === argName;
  });

  <span class="hljs-keyword">if</span> (arg == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> value = arg.value.kind === <span class="hljs-string">'Literal'</span> ? arg.value.value : <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Expected the '"</span>.concat(argName, <span class="hljs-string">"' value to @"</span>).concat(directive.name, <span class="hljs-string">" to be a string literal if provided."</span>), [arg.value.loc]);
  }

  <span class="hljs-keyword">return</span> value;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformLabel</span>(<span class="hljs-params">parentName, directive, label</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.concat(parentName, <span class="hljs-string">"$"</span>).concat(directive, <span class="hljs-string">"$"</span>).concat(label);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLiteralFalse</span>(<span class="hljs-params">arg</span>) </span>{
  <span class="hljs-keyword">return</span> arg != <span class="hljs-literal">null</span> &amp;&amp; arg.value.kind === <span class="hljs-string">'Literal'</span> &amp;&amp; arg.value.value === <span class="hljs-literal">false</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFragmentSpreadName</span>(<span class="hljs-params">fragmentSpread</span>) </span>{
  <span class="hljs-keyword">if</span> (fragmentSpread.args.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> fragmentSpread.name;
  }

  <span class="hljs-keyword">var</span> sortedArgs = (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(fragmentSpread.args).sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> a.name &lt; b.name ? <span class="hljs-number">-1</span> : a.name &gt; b.name ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
  }).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argument</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">name</span>: argument.name,
      <span class="hljs-attr">value</span>: getIdentifierForArgumentValue(argument.value)
    };
  });
  <span class="hljs-keyword">var</span> hash = murmurHash(<span class="hljs-built_in">JSON</span>.stringify(sortedArgs));
  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.concat(fragmentSpread.name, <span class="hljs-string">"_"</span>).concat(hash);
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: deferStreamTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 82 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-340" id="section-340"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitField</span>(<span class="hljs-params">field</span>) </span>{
  <span class="hljs-keyword">if</span> (field.alias === <span class="hljs-string">'id'</span> &amp;&amp; field.name !== <span class="hljs-string">'id'</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Relay does not allow aliasing fields to `id`. '</span> + <span class="hljs-string">'This name is reserved for the globally unique `id` field on '</span> + <span class="hljs-string">'`Node`.'</span>, [field.loc]);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(field);
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-341" id="section-341"></a>
</div>
<div class="dox">
<div class="summary">
<p>This is not an actual transform (but more a validation)
Relay does not allow aliasing fields to <code>id</code>.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disallowIdAsAlias</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">ScalarField</span>: visitField,
    <span class="hljs-attr">LinkedField</span>: visitField
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: disallowIdAsAlias
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 83 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-342" id="section-342"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> IRValidator = __webpack_require__(<span class="hljs-number">37</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitRoot</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(node.selections),
      _step;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
      <span class="hljs-keyword">var</span> selection = _step.value;

      <span class="hljs-keyword">if</span> (selection.kind === <span class="hljs-string">'ScalarField'</span> &amp;&amp; selection.name === <span class="hljs-string">'__typename'</span>) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Relay does not allow `__typename` field on Query, Mutation or Subscription'</span>, [selection.loc]);
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator.f();
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopVisit</span>(<span class="hljs-params"></span>) </span>{}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">disallowTypenameOnRoot</span>(<span class="hljs-params">context</span>) </span>{
  IRValidator.validate(context, {
    <span class="hljs-attr">Root</span>: visitRoot,
    <span class="hljs-attr">Fragment</span>: stopVisit
  });
  <span class="hljs-keyword">return</span> context;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: disallowTypenameOnRoot
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 84 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-343" id="section-343"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> SchemaUtils = __webpack_require__(<span class="hljs-number">9</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> nullthrows = __webpack_require__(<span class="hljs-number">16</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">10</span>),
    getRelayHandleKey = _require.getRelayHandleKey;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fieldHandleTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">LinkedField</span>: visitField,
    <span class="hljs-attr">ScalarField</span>: visitField
  });
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-344" id="section-344"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitField</span>(<span class="hljs-params">field</span>) </span>{
  <span class="hljs-keyword">var</span> nextField = field.kind === <span class="hljs-string">'LinkedField'</span> ? <span class="hljs-keyword">this</span>.traverse(field) : field;
  <span class="hljs-keyword">var</span> handles = nextField.handles;

  <span class="hljs-keyword">if</span> (!handles || !handles.length) {
    <span class="hljs-keyword">return</span> nextField;
  } <span class="hljs-comment">// ensure exactly one handle</span>


  !(handles.length === <span class="hljs-number">1</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'FieldHandleTransform: Expected fields to have at most one '</span> + <span class="hljs-string">'"handle" property, got `%s`.'</span>, handles.join(<span class="hljs-string">', '</span>)) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> alias = nextField.alias;
  <span class="hljs-keyword">var</span> handle = handles[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> name = getRelayHandleKey(handle.name, handle.key, nextField.name);
  <span class="hljs-keyword">var</span> filters = handle.filters;
  <span class="hljs-keyword">var</span> args = filters ? nextField.args.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> filters.indexOf(arg.name) !== <span class="hljs-number">-1</span>;
  }) : [];

  <span class="hljs-keyword">if</span> (handle.dynamicKey != <span class="hljs-literal">null</span>) {
    args.push({
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
      <span class="hljs-attr">loc</span>: handle.dynamicKey.loc,
      <span class="hljs-attr">name</span>: <span class="hljs-string">'__dynamicKey'</span>,
      <span class="hljs-attr">type</span>: SchemaUtils.getNullableStringInput(schema),
      <span class="hljs-attr">value</span>: nullthrows(handle.dynamicKey)
    });
  }

  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, nextField), {}, {
    <span class="hljs-attr">args</span>: args,
    <span class="hljs-attr">alias</span>: alias,
    <span class="hljs-attr">name</span>: name,
    <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: fieldHandleTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 85 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-345" id="section-345"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> COMPILE_TIME_DIRECTIVES = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'required'</span>]);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-346" id="section-346"></a>
</div>
<div class="dox">
<div class="summary">
<p>A transform that removes any directives that are only interpreted by the Relay compiler.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterDirectivesTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">Directive</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Directive</span>(<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> COMPILE_TIME_DIRECTIVES.has(directive.name) ? <span class="hljs-literal">null</span> : directive;
    }
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: filterDirectivesTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 86 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-347" id="section-347"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-348" id="section-348"></a>
</div>
<div class="dox">
<div class="summary">
<p>A transform that removes any directives that were not present in the
server schema.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterDirectivesTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> schemaDirectives = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(context.getSchema().getDirectives().filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> !directive.isClient;
  }).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">schemaDirective</span>) </span>{
    <span class="hljs-keyword">return</span> schemaDirective.name;
  }));

  <span class="hljs-keyword">var</span> visitDirective = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitDirective</span>(<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">if</span> (schemaDirectives.has(directive.name)) {
      <span class="hljs-keyword">return</span> directive;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  };

  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">Directive</span>: visitDirective
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: filterDirectivesTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 87 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-349" id="section-349"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> aStackPool = [];
<span class="hljs-keyword">var</span> bStackPool = [];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-350" id="section-350"></a>
</div>
<div class="dox">
<div class="summary">
<p>Checks if two values are equal. Values may be primitives, arrays, or objects.
Returns true if both arguments have the same keys and values.</p>
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">See</div>
<div class="dox_tag_detail">
<a href="http://underscorejs.org">http://underscorejs.org</a>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">areEqual</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">var</span> aStack = aStackPool.length ? aStackPool.pop() : [];
  <span class="hljs-keyword">var</span> bStack = bStackPool.length ? bStackPool.pop() : [];
  <span class="hljs-keyword">var</span> result = eq(a, b, aStack, bStack);
  aStack.length = <span class="hljs-number">0</span>;
  bStack.length = <span class="hljs-number">0</span>;
  aStackPool.push(aStack);
  bStackPool.push(bStack);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eq</span>(<span class="hljs-params">a, b, aStack, bStack</span>) </span>{
  <span class="hljs-keyword">if</span> (a === b) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-351" id="section-351"></a>
</div>
<p>Identical objects are equal. <code>0 === -0</code>, but they aren't identical.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> a !== <span class="hljs-number">0</span> || <span class="hljs-number">1</span> / a === <span class="hljs-number">1</span> / b;
  }

  <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || b == <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-352" id="section-352"></a>
</div>
<p>a or b can be <code>null</code> or <code>undefined</code></p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">'object'</span> || <span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">'object'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">var</span> objToStr = <span class="hljs-built_in">Object</span>.prototype.toString;
  <span class="hljs-keyword">var</span> className = objToStr.call(a);

  <span class="hljs-keyword">if</span> (className !== objToStr.call(b)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">switch</span> (className) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'[object String]'</span>:
      <span class="hljs-keyword">return</span> a === <span class="hljs-built_in">String</span>(b);

    <span class="hljs-keyword">case</span> <span class="hljs-string">'[object Number]'</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">isNaN</span>(a) || <span class="hljs-built_in">isNaN</span>(b) ? <span class="hljs-literal">false</span> : a === <span class="hljs-built_in">Number</span>(b);

    <span class="hljs-keyword">case</span> <span class="hljs-string">'[object Date]'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'[object Boolean]'</span>:
      <span class="hljs-keyword">return</span> +a === +b;

    <span class="hljs-keyword">case</span> <span class="hljs-string">'[object RegExp]'</span>:
      <span class="hljs-keyword">return</span> a.source === b.source &amp;&amp; a.global === b.global &amp;&amp; a.multiline === b.multiline &amp;&amp; a.ignoreCase === b.ignoreCase;
  } <span class="hljs-comment">// Assume equality for cyclic structures.</span>


  <span class="hljs-keyword">var</span> length = aStack.length;

  <span class="hljs-keyword">while</span> (length--) {
    <span class="hljs-keyword">if</span> (aStack[length] === a) {
      <span class="hljs-keyword">return</span> bStack[length] === b;
    }
  }

  aStack.push(a);
  bStack.push(b);
  <span class="hljs-keyword">var</span> size = <span class="hljs-number">0</span>; <span class="hljs-comment">// Recursively compare objects and arrays.</span>

  <span class="hljs-keyword">if</span> (className === <span class="hljs-string">'[object Array]'</span>) {
    size = a.length;

    <span class="hljs-keyword">if</span> (size !== b.length) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-comment">// Deep compare the contents, ignoring non-numeric properties.</span>


    <span class="hljs-keyword">while</span> (size--) {
      <span class="hljs-keyword">if</span> (!eq(a[size], b[size], aStack, bStack)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (a.constructor !== b.constructor) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (a.hasOwnProperty(<span class="hljs-string">'valueOf'</span>) &amp;&amp; b.hasOwnProperty(<span class="hljs-string">'valueOf'</span>)) {
      <span class="hljs-keyword">return</span> a.valueOf() === b.valueOf();
    }

    <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(a);

    <span class="hljs-keyword">if</span> (keys.length !== <span class="hljs-built_in">Object</span>.keys(b).length) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) {
      <span class="hljs-keyword">if</span> (keys[i] === <span class="hljs-string">'_owner'</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-353" id="section-353"></a>
</div>
<p>HACK: Comparing deeply nested React trees is slow since you end up
comparing the entire tree (all ancestors and all children) and
likely not what you want if you're comparing two elements with
areEqual. We bail out here for now.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">if</span> (!b.hasOwnProperty(keys[i]) || !eq(a[keys[i]], b[keys[i]], aStack, bStack)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }
  }

  aStack.pop();
  bStack.pop();
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-built_in">module</span>.exports = areEqual;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 88 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-354" id="section-354"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">9</span>),
    generateIDField = _require.generateIDField;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">40</span>),
    hasUnaliasedSelection = _require2.hasUnaliasedSelection;

<span class="hljs-keyword">var</span> ID = <span class="hljs-string">'id'</span>;
<span class="hljs-keyword">var</span> NODE_TYPE = <span class="hljs-string">'Node'</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-355" id="section-355"></a>
</div>
<div class="dox">
<div class="summary">
<p>A transform that adds an <code>id</code> field on any type that has an id field but
where there is no unaliased <code>id</code> selection.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateIDFieldTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> typeToIDField = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">idFieldForType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">var</span> idField = typeToIDField.get(type);

    <span class="hljs-keyword">if</span> (idField == <span class="hljs-literal">null</span>) {
      idField = generateIDField(schema, type);
      typeToIDField.set(type, idField);
    }

    <span class="hljs-keyword">return</span> idField;
  }

  <span class="hljs-keyword">var</span> typeToIDFragment = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">idFragmentForType</span>(<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">var</span> fragment = typeToIDFragment.get(type);

    <span class="hljs-keyword">if</span> (fragment == <span class="hljs-literal">null</span>) {
      fragment = {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineFragment'</span>,
        <span class="hljs-attr">directives</span>: [],
        <span class="hljs-attr">loc</span>: {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Generated'</span>
        },
        <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">selections</span>: [idFieldForType(type)],
        <span class="hljs-attr">typeCondition</span>: type
      };
      typeToIDFragment.set(type, fragment);
    }

    <span class="hljs-keyword">return</span> fragment;
  }

  <span class="hljs-keyword">var</span> state = {
    <span class="hljs-attr">idFieldForType</span>: idFieldForType,
    <span class="hljs-attr">idFragmentForType</span>: idFragmentForType
  };
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">LinkedField</span>: visitLinkedField
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> state;
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitLinkedField</span>(<span class="hljs-params">field, state</span>) </span>{
  <span class="hljs-keyword">var</span> transformedNode = <span class="hljs-keyword">this</span>.traverse(field, state); <span class="hljs-comment">// If the field already has an unaliased `id` field, do nothing</span>

  <span class="hljs-keyword">if</span> (hasUnaliasedSelection(field, ID)) {
    <span class="hljs-keyword">return</span> transformedNode;
  }

  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> unmodifiedType = schema.assertCompositeType(schema.getRawType(field.type)); <span class="hljs-comment">// If the field type has an `id` subfield add an `id` selection</span>

  <span class="hljs-keyword">if</span> (schema.canHaveSelections(unmodifiedType) &amp;&amp; schema.hasId(unmodifiedType)) {
    <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, transformedNode), {}, {
      <span class="hljs-attr">selections</span>: [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transformedNode.selections), [state.idFieldForType(unmodifiedType)])
    });
  } <span class="hljs-comment">// If the field type is abstract, then generate a `... on Node { id }`</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-356" id="section-356"></a>
</div>
<p>fragment if <em>any</em> concrete type implements Node. Then generate a
<code>... on PossibleType { id }</code> for every concrete type that does <em>not</em>
implement <code>Node</code></p>

        </td>
        <td class="code highlight">
          <pre class="javascript">

  <span class="hljs-keyword">var</span> nodeType = schema.getTypeFromString(NODE_TYPE);

  <span class="hljs-keyword">if</span> (!nodeType) {
    <span class="hljs-keyword">return</span> transformedNode;
  }

  <span class="hljs-keyword">var</span> nodeInterface = schema.assertInterfaceType(nodeType);

  <span class="hljs-keyword">if</span> (schema.isAbstractType(unmodifiedType)) {
    <span class="hljs-keyword">var</span> selections = (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transformedNode.selections);

    <span class="hljs-keyword">if</span> (schema.mayImplement(unmodifiedType, nodeInterface)) {
      selections.push(state.idFragmentForType(nodeInterface));
    }

    <span class="hljs-built_in">Array</span>.from(schema.getPossibleTypes(schema.assertAbstractType(unmodifiedType)).values()).filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">concreteType</span>) </span>{
      <span class="hljs-keyword">return</span> !schema.implementsInterface(schema.assertCompositeType(concreteType), nodeInterface) &amp;&amp; schema.hasId(concreteType);
    }).sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
      <span class="hljs-keyword">return</span> schema.getTypeString(a) &lt; schema.getTypeString(b) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;
    }).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">concreteType</span>) </span>{
      selections.push(state.idFragmentForType(concreteType));
    });
    <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, transformedNode), {}, {
      <span class="hljs-attr">selections</span>: selections
    });
  }

  <span class="hljs-keyword">return</span> transformedNode;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: generateIDFieldTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 89 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-357" id="section-357"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> generateAbstractTypeRefinementKey = __webpack_require__(<span class="hljs-number">17</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">40</span>),
    hasUnaliasedSelection = _require.hasUnaliasedSelection;

<span class="hljs-keyword">var</span> TYPENAME_KEY = <span class="hljs-string">'__typename'</span>;
<span class="hljs-keyword">var</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-358" id="section-358"></a>
</div>
<div class="dox">
<div class="summary">
<p>A transform that adds <code>__typename</code> field on any <code>LinkedField</code> of a union or
interface type where there is no unaliased <code>__typename</code> selection.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateTypeNameTransform</span>(<span class="hljs-params">context</span>) </span>{
  cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> typenameField = {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'ScalarField'</span>,
    <span class="hljs-attr">alias</span>: TYPENAME_KEY,
    <span class="hljs-attr">args</span>: [],
    <span class="hljs-attr">directives</span>: [],
    <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">loc</span>: {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Generated'</span>
    },
    <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">name</span>: TYPENAME_KEY,
    <span class="hljs-attr">type</span>: schema.assertScalarFieldType(schema.getNonNullType(schema.expectStringType()))
  };
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">Fragment</span>: visitFragment,
    <span class="hljs-attr">LinkedField</span>: visitLinkedField,
    <span class="hljs-attr">InlineFragment</span>: visitInlineFragment
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">typenameField</span>: typenameField
    };
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragment</span>(<span class="hljs-params">fragment, state</span>) </span>{
  <span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">this</span>.getContext().getSchema();
  <span class="hljs-keyword">var</span> rawType = schema.getRawType(fragment.type);
  <span class="hljs-keyword">var</span> transformedNode = <span class="hljs-keyword">this</span>.traverse(fragment, state);
  <span class="hljs-keyword">var</span> isClientType = !schema.isServerType(rawType);

  <span class="hljs-keyword">if</span> (!isClientType &amp;&amp; schema.isAbstractType(rawType)) {
    <span class="hljs-keyword">var</span> abstractKey = generateAbstractTypeRefinementKey(schema, rawType);
    transformedNode = _objectSpread(_objectSpread({}, transformedNode), {}, {
      <span class="hljs-attr">selections</span>: [{
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'ScalarField'</span>,
        <span class="hljs-attr">alias</span>: abstractKey,
        <span class="hljs-attr">args</span>: [],
        <span class="hljs-attr">directives</span>: [],
        <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">loc</span>: {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Generated'</span>
        },
        <span class="hljs-attr">metadata</span>: {
          <span class="hljs-attr">abstractKey</span>: abstractKey
        },
        <span class="hljs-attr">name</span>: TYPENAME_KEY,
        <span class="hljs-attr">type</span>: schema.assertScalarFieldType(schema.getNonNullType(schema.expectStringType()))
      }].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transformedNode.selections))
    });
  }

  <span class="hljs-keyword">return</span> transformedNode;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitInlineFragment</span>(<span class="hljs-params">fragment, state</span>) </span>{
  <span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">this</span>.getContext().getSchema();
  <span class="hljs-keyword">var</span> transformedNode = cache.get(fragment);

  <span class="hljs-keyword">if</span> (transformedNode != <span class="hljs-literal">null</span> &amp;&amp; transformedNode.kind === <span class="hljs-string">'InlineFragment'</span>) {
    <span class="hljs-keyword">return</span> transformedNode;
  }

  <span class="hljs-keyword">var</span> rawType = schema.getRawType(fragment.typeCondition);
  transformedNode = <span class="hljs-keyword">this</span>.traverse(fragment, state);
  <span class="hljs-keyword">var</span> isClientType = !schema.isServerType(rawType);

  <span class="hljs-keyword">if</span> (!isClientType &amp;&amp; schema.isAbstractType(rawType)) {
    <span class="hljs-keyword">var</span> abstractKey = generateAbstractTypeRefinementKey(schema, rawType);
    transformedNode = _objectSpread(_objectSpread({}, transformedNode), {}, {
      <span class="hljs-attr">selections</span>: [{
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'ScalarField'</span>,
        <span class="hljs-attr">alias</span>: abstractKey,
        <span class="hljs-attr">args</span>: [],
        <span class="hljs-attr">directives</span>: [],
        <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">loc</span>: {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Generated'</span>
        },
        <span class="hljs-attr">metadata</span>: {
          <span class="hljs-attr">abstractKey</span>: abstractKey
        },
        <span class="hljs-attr">name</span>: TYPENAME_KEY,
        <span class="hljs-attr">type</span>: schema.assertScalarFieldType(schema.getNonNullType(schema.expectStringType()))
      }].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transformedNode.selections))
    });
  }

  cache.set(fragment, transformedNode);
  <span class="hljs-keyword">return</span> transformedNode;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitLinkedField</span>(<span class="hljs-params">field, state</span>) </span>{
  <span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">this</span>.getContext().getSchema();
  <span class="hljs-keyword">var</span> transformedNode = cache.get(field);

  <span class="hljs-keyword">if</span> (transformedNode != <span class="hljs-literal">null</span> &amp;&amp; transformedNode.kind === <span class="hljs-string">'LinkedField'</span>) {
    <span class="hljs-keyword">return</span> transformedNode;
  }

  transformedNode = <span class="hljs-keyword">this</span>.traverse(field, state);

  <span class="hljs-keyword">if</span> (schema.isAbstractType(schema.getRawType(transformedNode.type)) &amp;&amp; !hasUnaliasedSelection(transformedNode, TYPENAME_KEY)) {
    transformedNode = _objectSpread(_objectSpread({}, transformedNode), {}, {
      <span class="hljs-attr">selections</span>: [state.typenameField].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(transformedNode.selections))
    });
  }

  cache.set(field, transformedNode);
  <span class="hljs-keyword">return</span> transformedNode;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: generateTypeNameTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 90 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-359" id="section-359"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError;

<span class="hljs-keyword">var</span> SCHEMA_EXTENSION = <span class="hljs-string">"\ndirective @inline on FRAGMENT_DEFINITION\n"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-360" id="section-360"></a>
</div>
<div class="dox">
<div class="summary">
<p>A transform that converts fragment spreads where the referenced fragment
is annotated with @inline to a InlineDataFragmentSpread.
InlineDataFragmentSpreads have the selections of the referenced fragment inlined.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inlineDataFragmentTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-361" id="section-361"></a>
</div>
<p>$FlowFixMe[prop-missing] - this visitor intentionally changes node types
$FlowFixMe[incompatible-call] - this visitor intentionally changes node types</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    FragmentSpread: visitFragmentSpread,
    <span class="hljs-attr">Fragment</span>: visitFragment
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragment</span>(<span class="hljs-params">fragment</span>) </span>{
  <span class="hljs-keyword">var</span> transformedFragment = <span class="hljs-keyword">this</span>.traverse(fragment);
  <span class="hljs-keyword">var</span> inlineDirective = transformedFragment.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'inline'</span>;
  });

  <span class="hljs-keyword">if</span> (inlineDirective == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> transformedFragment;
  }

  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, transformedFragment), {}, {
    <span class="hljs-attr">directives</span>: transformedFragment.directives.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> directive !== inlineDirective;
    }),
    <span class="hljs-attr">metadata</span>: _objectSpread(_objectSpread({}, transformedFragment.metadata || {}), {}, {
      <span class="hljs-attr">inlineData</span>: <span class="hljs-literal">true</span>
    })
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragmentSpread</span>(<span class="hljs-params">fragmentSpread</span>) </span>{
  <span class="hljs-keyword">var</span> transformedFragmentSpread = <span class="hljs-keyword">this</span>.traverse(fragmentSpread);
  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> fragment = context.get(transformedFragmentSpread.name);

  <span class="hljs-keyword">if</span> (!fragment || fragment.kind !== <span class="hljs-string">'Fragment'</span> || !fragment.directives.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'inline'</span>;
  })) {
    <span class="hljs-keyword">return</span> transformedFragmentSpread;
  }

  <span class="hljs-keyword">if</span> (fragment.argumentDefinitions.length &gt; <span class="hljs-number">0</span> || transformedFragmentSpread.args.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Variables are not yet supported inside @inline fragments.'</span>, [fragment.argumentDefinitions[<span class="hljs-number">0</span>].loc]);
  }

  <span class="hljs-keyword">if</span> (transformedFragmentSpread.directives.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Directives on fragment spreads for @inline fragments are not yet '</span> + <span class="hljs-string">'supported'</span>, [transformedFragmentSpread.loc]);
  }

  <span class="hljs-keyword">var</span> transformedFragment = <span class="hljs-keyword">this</span>.visit(fragment);
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineDataFragmentSpread'</span>,
    <span class="hljs-attr">loc</span>: transformedFragmentSpread.loc,
    <span class="hljs-attr">metadata</span>: transformedFragmentSpread.metadata,
    <span class="hljs-attr">name</span>: transformedFragmentSpread.name,
    <span class="hljs-attr">selections</span>: [{
      <span class="hljs-attr">directives</span>: [],
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineFragment'</span>,
      <span class="hljs-attr">loc</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
        <span class="hljs-attr">source</span>: transformedFragmentSpread.loc
      },
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">selections</span>: transformedFragment.selections,
      <span class="hljs-attr">typeCondition</span>: transformedFragment.type
    }]
  };
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">SCHEMA_EXTENSION</span>: SCHEMA_EXTENSION,
  <span class="hljs-attr">transform</span>: inlineDataFragmentTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 91 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-362" id="section-362"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-363" id="section-363"></a>
</div>
<div class="dox">
<div class="summary">
<p>A transform that inlines all fragments and removes them.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inlineFragmentsTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> visitFragmentSpread = fragmentSpreadVisitor(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>());
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">Fragment</span>: visitFragment,
    <span class="hljs-attr">FragmentSpread</span>: visitFragmentSpread
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragment</span>(<span class="hljs-params">fragment</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fragmentSpreadVisitor</span>(<span class="hljs-params">cache</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragmentSpread</span>(<span class="hljs-params">fragmentSpread</span>) </span>{
    <span class="hljs-keyword">var</span> traverseResult = cache.get(fragmentSpread);

    <span class="hljs-keyword">if</span> (traverseResult != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> traverseResult;
    }

    !(fragmentSpread.args.length === <span class="hljs-number">0</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'InlineFragmentsTransform: Cannot flatten fragment spread `%s` with '</span> + <span class="hljs-string">'arguments. Use the `ApplyFragmentArgumentTransform` before flattening'</span>, fragmentSpread.name) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> fragment = <span class="hljs-keyword">this</span>.getContext().getFragment(fragmentSpread.name, fragmentSpread.loc);
    <span class="hljs-keyword">var</span> result = {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineFragment'</span>,
      <span class="hljs-attr">directives</span>: fragmentSpread.directives,
      <span class="hljs-attr">loc</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
        <span class="hljs-attr">source</span>: fragmentSpread.loc
      },
      <span class="hljs-attr">metadata</span>: fragmentSpread.metadata,
      <span class="hljs-attr">selections</span>: fragment.selections,
      <span class="hljs-attr">typeCondition</span>: fragment.type
    };
    traverseResult = <span class="hljs-keyword">this</span>.traverse(result);
    cache.set(fragmentSpread, traverseResult);
    <span class="hljs-keyword">return</span> traverseResult;
  };
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: inlineFragmentsTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 92 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-364" id="section-364"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-365" id="section-365"></a>
</div>
<div class="dox">
<div class="summary">
<p>Attempts to join the argument definitions for a root fragment
and any unmasked fragment spreads reachable from that root fragment,
returning a combined list of arguments or throwing if the same
variable(s) are used in incompatible ways in different fragments.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">joinArgumentDefinitions</span>(<span class="hljs-params">schema, fragment, reachableArguments, directiveName</span>) </span>{
  <span class="hljs-keyword">var</span> joinedArgumentDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  fragment.argumentDefinitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prevArgDef</span>) </span>{
    joinedArgumentDefinitions.set(prevArgDef.name, prevArgDef);
  });
  reachableArguments.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nextArgDef</span>) </span>{
    <span class="hljs-keyword">var</span> prevArgDef = joinedArgumentDefinitions.get(nextArgDef.name);
    <span class="hljs-keyword">var</span> joinedArgDef = prevArgDef == <span class="hljs-literal">null</span> ? nextArgDef : joinArgumentDefinition(schema, prevArgDef, nextArgDef, directiveName);
    joinedArgumentDefinitions.set(joinedArgDef.name, joinedArgDef);
  });
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(joinedArgumentDefinitions.values());
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-366" id="section-366"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">joinArgumentDefinition</span>(<span class="hljs-params">schema, prevArgDef, nextArgDef, directiveName</span>) </span>{
  <span class="hljs-keyword">if</span> (prevArgDef.kind !== nextArgDef.kind) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Cannot combine global and local variables when applying '</span> + <span class="hljs-string">""</span>.concat(directiveName, <span class="hljs-string">"."</span>), [prevArgDef.loc, nextArgDef.loc]);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prevArgDef.kind === <span class="hljs-string">'LocalArgumentDefinition'</span> &amp;&amp; nextArgDef.kind === <span class="hljs-string">'LocalArgumentDefinition'</span> &amp;&amp; prevArgDef.defaultValue !== nextArgDef.defaultValue) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Cannot combine local variables with different defaultValues when '</span> + <span class="hljs-string">"applying "</span>.concat(directiveName, <span class="hljs-string">"."</span>), [prevArgDef.loc, nextArgDef.loc]);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isTypeSubTypeOf(nextArgDef.type, prevArgDef.type)) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-367" id="section-367"></a>
</div>
<p>prevArgDef is less strict than nextArgDef</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    <span class="hljs-keyword">return</span> nextArgDef;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isTypeSubTypeOf(prevArgDef.type, nextArgDef.type)) {
    <span class="hljs-keyword">return</span> prevArgDef;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">var</span> prevArgType = prevArgDef.type != <span class="hljs-literal">null</span> ? schema.getTypeString(prevArgDef.type) : <span class="hljs-string">'unknown'</span>;
    <span class="hljs-keyword">var</span> nextArgType = nextArgDef.type != <span class="hljs-literal">null</span> ? schema.getTypeString(nextArgDef.type) : <span class="hljs-string">'unknown'</span>;
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Cannot combine variables with incompatible types '</span> + <span class="hljs-string">""</span>.concat(prevArgType, <span class="hljs-string">" and "</span>).concat(nextArgType, <span class="hljs-string">" "</span>) + <span class="hljs-string">"when applying "</span>.concat(directiveName, <span class="hljs-string">"."</span>), [prevArgDef.loc, nextArgDef.loc]);
  }
}

<span class="hljs-built_in">module</span>.exports = joinArgumentDefinitions;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 93 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-368" id="section-368"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError,
    createCompilerError = _require.createCompilerError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">10</span>),
    RelayFeatureFlags = _require2.RelayFeatureFlags;

<span class="hljs-keyword">var</span> FLIGHT_FIELD_COMPONENT_ARGUMENT_TYPE = <span class="hljs-string">'String'</span>;
<span class="hljs-keyword">var</span> FLIGHT_FIELD_COMPONENT_ARGUMENT_NAME = <span class="hljs-string">'component'</span>;
<span class="hljs-keyword">var</span> FLIGHT_FIELD_PROPS_ARGUMENT_NAME = <span class="hljs-string">'props'</span>;
<span class="hljs-keyword">var</span> FLIGHT_FIELD_PROPS_TYPE = <span class="hljs-string">'ReactFlightProps'</span>;
<span class="hljs-keyword">var</span> FLIGHT_FIELD_RETURN_TYPE = <span class="hljs-string">'ReactFlightComponent'</span>;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-369" id="section-369"></a>
</div>
<div class="dox">
<div class="summary">
<p>Experimental transform for React Flight.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactFlightComponentTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> propsType = schema.getTypeFromString(FLIGHT_FIELD_PROPS_TYPE);
  propsType = propsType ? schema.asInputType(propsType) : <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> componentType = schema.getTypeFromString(FLIGHT_FIELD_RETURN_TYPE);
  componentType = componentType ? schema.asScalarFieldType(componentType) : <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (!RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD || propsType == <span class="hljs-literal">null</span> || componentType == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> context;
  }

  <span class="hljs-keyword">var</span> types = {
    <span class="hljs-attr">propsType</span>: propsType,
    <span class="hljs-attr">componentType</span>: componentType
  };
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">ScalarField</span>: visitScalarField,
    <span class="hljs-attr">LinkedField</span>: visitLinkedField,
    <span class="hljs-attr">InlineFragment</span>: visitInlineFragment
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">parentType</span>: node.type,
      <span class="hljs-attr">types</span>: types
    };
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitInlineFragment</span>(<span class="hljs-params">fragment, state</span>) </span>{
  <span class="hljs-keyword">var</span> _fragment$typeConditi;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(fragment, {
    <span class="hljs-attr">parentType</span>: (_fragment$typeConditi = fragment.typeCondition) !== <span class="hljs-literal">null</span> &amp;&amp; _fragment$typeConditi !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? _fragment$typeConditi : state.parentType,
    <span class="hljs-attr">types</span>: state.types
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitLinkedField</span>(<span class="hljs-params">field, state</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(field, {
    <span class="hljs-attr">parentType</span>: field.type,
    <span class="hljs-attr">types</span>: state.types
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitScalarField</span>(<span class="hljs-params">field, state</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-370" id="section-370"></a>
</div>
<p>use the return type to quickly determine if this is a flight field</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">this</span>.getContext().getSchema();

  <span class="hljs-keyword">if</span> (schema.getRawType(field.type) !== state.types.componentType) {
    <span class="hljs-keyword">return</span> field;
  } <span class="hljs-comment">// get the name of the component that provides this field</span>


  <span class="hljs-keyword">var</span> clientField = schema.getFieldByName(state.parentType, field.name);

  <span class="hljs-keyword">if</span> (clientField == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createCompilerError(<span class="hljs-string">"Definition not found for field '"</span>.concat(schema.getTypeString(state.parentType), <span class="hljs-string">"."</span>).concat(field.name, <span class="hljs-string">"'"</span>), [field.loc]);
  }

  <span class="hljs-keyword">var</span> componentDirective = clientField.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'react_flight_component'</span>;
  });
  <span class="hljs-keyword">var</span> componentNameArg = componentDirective === <span class="hljs-literal">null</span> || componentDirective === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> : componentDirective.args.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name === <span class="hljs-string">'name'</span>;
  });

  <span class="hljs-keyword">if</span> (componentNameArg == <span class="hljs-literal">null</span> || componentNameArg.value.kind !== <span class="hljs-string">'StringValue'</span> || <span class="hljs-keyword">typeof</span> componentNameArg.value.value !== <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">'Invalid Flight field, expected the schema extension to specify '</span> + <span class="hljs-string">"the component's module name with the '@react_flight_component' directive"</span>, [field.loc]);
  }

  <span class="hljs-keyword">var</span> componentName = componentNameArg.value.value; <span class="hljs-comment">// validate that the parent type has a `flight(component, props)` field</span>

  <span class="hljs-keyword">var</span> flightField = schema.getFieldByName(state.parentType, <span class="hljs-string">'flight'</span>);

  <span class="hljs-keyword">if</span> (flightField == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid Flight field, expected the parent type '"</span>.concat(schema.getTypeString(state.parentType), <span class="hljs-string">"' "</span>) + <span class="hljs-string">"to define a 'flight(component: String, props: ReactFlightProps): ReactFlightComponent' field"</span>, [field.loc]);
  }

  <span class="hljs-keyword">var</span> componentArg = flightField.args.get(FLIGHT_FIELD_COMPONENT_ARGUMENT_NAME);
  <span class="hljs-keyword">var</span> propsArg = flightField.args.get(FLIGHT_FIELD_PROPS_ARGUMENT_NAME);

  <span class="hljs-keyword">if</span> (componentArg == <span class="hljs-literal">null</span> || propsArg == <span class="hljs-literal">null</span> || schema.getRawType(componentArg.type) !== schema.getTypeFromString(FLIGHT_FIELD_COMPONENT_ARGUMENT_TYPE) || schema.getRawType(propsArg.type) !== state.types.propsType || schema.getRawType(flightField.type) !== state.types.componentType) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid Flight field, expected the parent type '"</span>.concat(schema.getTypeString(state.parentType), <span class="hljs-string">"' "</span>) + <span class="hljs-string">"to define a 'flight(component: String, props: ReactFlightProps): ReactFlightComponent' field"</span>, [field.loc]);
  }

  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, field), {}, {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'flight'</span>,
    <span class="hljs-attr">args</span>: [{
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
      <span class="hljs-attr">loc</span>: field.loc,
      <span class="hljs-attr">name</span>: FLIGHT_FIELD_COMPONENT_ARGUMENT_NAME,
      <span class="hljs-attr">type</span>: schema.getTypeFromString(FLIGHT_FIELD_COMPONENT_ARGUMENT_TYPE),
      <span class="hljs-attr">value</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Literal'</span>,
        <span class="hljs-attr">value</span>: componentName,
        <span class="hljs-attr">loc</span>: field.loc
      }
    }, {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
      <span class="hljs-attr">loc</span>: field.loc,
      <span class="hljs-attr">name</span>: FLIGHT_FIELD_PROPS_ARGUMENT_NAME,
      <span class="hljs-attr">type</span>: state.types.propsType,
      <span class="hljs-attr">value</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'ObjectValue'</span>,
        <span class="hljs-attr">fields</span>: field.args.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'ObjectFieldValue'</span>,
            <span class="hljs-attr">loc</span>: arg.loc,
            <span class="hljs-attr">name</span>: arg.name,
            <span class="hljs-attr">value</span>: arg.value
          };
        }),
        <span class="hljs-attr">loc</span>: field.loc
      }
    }],
    <span class="hljs-attr">metadata</span>: _objectSpread(_objectSpread({}, field.metadata || {}), {}, {
      <span class="hljs-attr">flight</span>: <span class="hljs-literal">true</span>
    }),
    <span class="hljs-attr">type</span>: state.types.componentType
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: reactFlightComponentTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 94 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-371" id="section-371"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> FetchableQueryGenerator = __webpack_require__(<span class="hljs-number">95</span>);

<span class="hljs-keyword">var</span> NodeQueryGenerator = __webpack_require__(<span class="hljs-number">96</span>);

<span class="hljs-keyword">var</span> QueryQueryGenerator = __webpack_require__(<span class="hljs-number">97</span>);

<span class="hljs-keyword">var</span> ViewerQueryGenerator = __webpack_require__(<span class="hljs-number">98</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError;

<span class="hljs-keyword">var</span> GENERATORS = [ViewerQueryGenerator, QueryQueryGenerator, NodeQueryGenerator, FetchableQueryGenerator];
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-372" id="section-372"></a>
</div>
<div class="dox">
<div class="summary">
<p>Builds a query to refetch the given fragment or throws if we have not way to
generate one.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildRefetchOperation</span>(<span class="hljs-params">schema, fragment, queryName</span>) </span>{
  <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(GENERATORS),
      _step;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
      <span class="hljs-keyword">var</span> generator = _step.value;
      <span class="hljs-keyword">var</span> refetchRoot = generator.buildRefetchOperation(schema, fragment, queryName);

      <span class="hljs-keyword">if</span> (refetchRoot != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> refetchRoot;
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator.f();
  }

  <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @refetchable on fragment '"</span>.concat(fragment.name, <span class="hljs-string">"', only "</span>) + <span class="hljs-string">'supported are fragments on:\n'</span> + GENERATORS.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">generator</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">" - "</span>.concat(generator.description);
  }).join(<span class="hljs-string">'\n'</span>), [fragment.loc]);
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">buildRefetchOperation</span>: buildRefetchOperation
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 95 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-373" id="section-373"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> SchemaUtils = __webpack_require__(<span class="hljs-number">9</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">21</span>),
    buildFragmentSpread = _require2.buildFragmentSpread,
    buildOperationArgumentDefinitions = _require2.buildOperationArgumentDefinitions;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildRefetchOperation</span>(<span class="hljs-params">schema, fragment, queryName</span>) </span>{
  <span class="hljs-keyword">var</span> fetchableIdentifierField = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (schema.isObject(fragment.type)) {
    <span class="hljs-keyword">var</span> objectType = schema.assertObjectType(fragment.type);
    fetchableIdentifierField = schema.getFetchableFieldName(objectType);
  }

  <span class="hljs-keyword">if</span> (fetchableIdentifierField == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> identifierField = schema.getFieldConfig(schema.expectField(fragment.type, fetchableIdentifierField));

  <span class="hljs-keyword">if</span> (!schema.isId(schema.getRawType(identifierField.type))) {
    <span class="hljs-keyword">var</span> typeName = schema.getTypeString(fragment.type);
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @refetchable on fragment '"</span>.concat(fragment.name, <span class="hljs-string">"', the type "</span>) + <span class="hljs-string">"'"</span>.concat(typeName, <span class="hljs-string">"' is @fetchable but the identifying field '"</span>).concat(fetchableIdentifierField, <span class="hljs-string">"' "</span>) + <span class="hljs-string">"does not have type 'ID'."</span>, [fragment.loc]);
  }

  <span class="hljs-keyword">var</span> queryType = schema.expectQueryType();
  <span class="hljs-keyword">var</span> fetchFieldName = <span class="hljs-string">"fetch__"</span>.concat(schema.getTypeString(fragment.type));
  <span class="hljs-keyword">var</span> fetchField = schema.getFieldConfig(schema.expectField(queryType, fetchFieldName));

  <span class="hljs-keyword">if</span> (!(fetchField != <span class="hljs-literal">null</span> &amp;&amp; schema.isObject(fetchField.type) &amp;&amp; schema.areEqualTypes(fetchField.type, fragment.type) &amp;&amp; schema.areEqualTypes(schema.getNullableType(fetchField.args[<span class="hljs-number">0</span>].type), schema.expectIdType()))) {
    <span class="hljs-keyword">var</span> _typeName = schema.getTypeString(fragment.type);

    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @refetchable on fragment '"</span>.concat(fragment.name, <span class="hljs-string">"', the type "</span>) + <span class="hljs-string">"'"</span>.concat(_typeName, <span class="hljs-string">"' is @fetchable but there is no corresponding '"</span>).concat(fetchFieldName, <span class="hljs-string">"'"</span>) + <span class="hljs-string">"field or it is invalid (expected '"</span>.concat(fetchFieldName, <span class="hljs-string">"(id: ID!): "</span>).concat(_typeName, <span class="hljs-string">"')."</span>), [fragment.loc]);
  } <span class="hljs-comment">// name and type of the node(_: ID) field parameter</span>


  <span class="hljs-keyword">var</span> idArgName = fetchField.args[<span class="hljs-number">0</span>].name;
  <span class="hljs-keyword">var</span> idArgType = fetchField.args[<span class="hljs-number">0</span>].type; <span class="hljs-comment">// name and type of the query variable</span>

  <span class="hljs-keyword">var</span> idVariableType = SchemaUtils.getNonNullIdInput(schema);
  <span class="hljs-keyword">var</span> idVariableName = <span class="hljs-string">'id'</span>;
  <span class="hljs-keyword">var</span> argumentDefinitions = buildOperationArgumentDefinitions(fragment.argumentDefinitions);
  <span class="hljs-keyword">var</span> idArgument = argumentDefinitions.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argDef</span>) </span>{
    <span class="hljs-keyword">return</span> argDef.name === idVariableName;
  });

  <span class="hljs-keyword">if</span> (idArgument != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @refetchable on fragment `"</span>.concat(fragment.name, <span class="hljs-string">"`, this "</span>) + <span class="hljs-string">'fragment already has an `$id` variable in scope.'</span>, [idArgument.loc]);
  }

  <span class="hljs-keyword">var</span> argumentDefinitionsWithId = [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(argumentDefinitions), [{
    <span class="hljs-attr">defaultValue</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'LocalArgumentDefinition'</span>,
    <span class="hljs-attr">loc</span>: {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
      <span class="hljs-attr">source</span>: fragment.loc
    },
    <span class="hljs-attr">name</span>: idVariableName,
    <span class="hljs-attr">type</span>: idVariableType
  }]);
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">identifierField</span>: fetchableIdentifierField,
    <span class="hljs-attr">path</span>: [fetchFieldName],
    <span class="hljs-attr">node</span>: {
      <span class="hljs-attr">argumentDefinitions</span>: argumentDefinitionsWithId,
      <span class="hljs-attr">directives</span>: [],
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Root'</span>,
      <span class="hljs-attr">loc</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
        <span class="hljs-attr">source</span>: fragment.loc
      },
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">name</span>: queryName,
      <span class="hljs-attr">operation</span>: <span class="hljs-string">'query'</span>,
      <span class="hljs-attr">selections</span>: [{
        <span class="hljs-attr">alias</span>: fetchFieldName,
        <span class="hljs-attr">args</span>: [{
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
          <span class="hljs-attr">loc</span>: {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
            <span class="hljs-attr">source</span>: fragment.loc
          },
          <span class="hljs-attr">name</span>: idArgName,
          <span class="hljs-attr">type</span>: schema.assertInputType(idArgType),
          <span class="hljs-attr">value</span>: {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'Variable'</span>,
            <span class="hljs-attr">loc</span>: {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
              <span class="hljs-attr">source</span>: fragment.loc
            },
            <span class="hljs-attr">variableName</span>: idVariableName,
            <span class="hljs-attr">type</span>: idVariableType
          }
        }],
        <span class="hljs-attr">connection</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">directives</span>: [],
        <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkedField'</span>,
        <span class="hljs-attr">loc</span>: {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
          <span class="hljs-attr">source</span>: fragment.loc
        },
        <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">name</span>: fetchFieldName,
        <span class="hljs-attr">selections</span>: [buildFragmentSpread(fragment)],
        <span class="hljs-attr">type</span>: fragment.type
      }],
      <span class="hljs-attr">type</span>: queryType
    },
    <span class="hljs-attr">transformedFragment</span>: enforceIDField(schema, fragment, fetchableIdentifierField)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enforceIDField</span>(<span class="hljs-params">schema, fragment, fetchableIdentifierField</span>) </span>{
  <span class="hljs-keyword">var</span> idSelection = fragment.selections.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">return</span> selection.kind === <span class="hljs-string">'ScalarField'</span> &amp;&amp; selection.name === fetchableIdentifierField &amp;&amp; selection.alias === fetchableIdentifierField &amp;&amp; schema.areEqualTypes(schema.getNullableType(selection.type), schema.expectIdType());
  });

  <span class="hljs-keyword">if</span> (idSelection) {
    <span class="hljs-keyword">return</span> fragment;
  }

  <span class="hljs-keyword">var</span> idField = SchemaUtils.generateIDField(schema, fragment.type); <span class="hljs-comment">// idField is uniquely owned here, safe to mutate</span>

  idField.alias = fetchableIdentifierField; <span class="hljs-comment">// idField is uniquely owned here, safe to mutate</span>

  idField.name = fetchableIdentifierField;
  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, fragment), {}, {
    <span class="hljs-attr">selections</span>: [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(fragment.selections), [idField])
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">description</span>: <span class="hljs-string">'@fetchable types'</span>,
  <span class="hljs-attr">buildRefetchOperation</span>: buildRefetchOperation
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 96 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-374" id="section-374"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> SchemaUtils = __webpack_require__(<span class="hljs-number">9</span>);

<span class="hljs-keyword">var</span> nullthrows = __webpack_require__(<span class="hljs-number">16</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">21</span>),
    buildFragmentSpread = _require2.buildFragmentSpread,
    buildOperationArgumentDefinitions = _require2.buildOperationArgumentDefinitions;

<span class="hljs-keyword">var</span> NODE_TYPE_NAME = <span class="hljs-string">'Node'</span>;
<span class="hljs-keyword">var</span> NODE_FIELD_NAME = <span class="hljs-string">'node'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildRefetchOperation</span>(<span class="hljs-params">schema, fragment, queryName</span>) </span>{
  <span class="hljs-keyword">var</span> eligible = schema.getTypeString(fragment.type) === NODE_TYPE_NAME || schema.isObject(fragment.type) &amp;&amp; schema.getInterfaces(schema.assertCompositeType(fragment.type)).some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">interfaceType</span>) </span>{
    <span class="hljs-keyword">return</span> schema.areEqualTypes(interfaceType, schema.expectTypeFromString(NODE_TYPE_NAME));
  }) || schema.isAbstractType(fragment.type) &amp;&amp; <span class="hljs-built_in">Array</span>.from(schema.getPossibleTypes(schema.assertAbstractType(fragment.type))).every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">possibleType</span>) </span>{
    <span class="hljs-keyword">return</span> schema.implementsInterface(schema.assertCompositeType(possibleType), schema.assertInterfaceType(schema.expectTypeFromString(NODE_TYPE_NAME)));
  });

  <span class="hljs-keyword">if</span> (!eligible) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> queryType = schema.expectQueryType();
  <span class="hljs-keyword">var</span> nodeType = schema.getTypeFromString(NODE_TYPE_NAME);
  <span class="hljs-keyword">var</span> nodeField = schema.getFieldConfig(schema.expectField(queryType, NODE_FIELD_NAME));

  <span class="hljs-keyword">if</span> (!(nodeType &amp;&amp; schema.isInterface(nodeType) &amp;&amp; schema.isInterface(nodeField.type) &amp;&amp; schema.areEqualTypes(nodeField.type, nodeType) &amp;&amp; nodeField.args.length === <span class="hljs-number">1</span> &amp;&amp; schema.areEqualTypes(schema.getNullableType(nodeField.args[<span class="hljs-number">0</span>].type), schema.expectIdType()) &amp;&amp; ( <span class="hljs-comment">// the fragment must be on Node or on a type that implements Node</span>
  schema.isObject(fragment.type) &amp;&amp; schema.getInterfaces(schema.assertCompositeType(fragment.type)).some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">interfaceType</span>) </span>{
    <span class="hljs-keyword">return</span> schema.areEqualTypes(interfaceType, nodeType);
  }) || schema.isAbstractType(fragment.type) &amp;&amp; <span class="hljs-built_in">Array</span>.from(schema.getPossibleTypes(schema.assertAbstractType(fragment.type))).every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">possibleType</span>) </span>{
    <span class="hljs-keyword">return</span> schema.getInterfaces(schema.assertCompositeType(possibleType)).some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">interfaceType</span>) </span>{
      <span class="hljs-keyword">return</span> schema.areEqualTypes(interfaceType, nodeType);
    });
  })))) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @refetchable on fragment '"</span>.concat(fragment.name, <span class="hljs-string">"', check "</span>) + <span class="hljs-string">'that your schema defines a `Node { id: ID }` interface and has a '</span> + <span class="hljs-string">'`node(id: ID): Node` field on the query type (the id argument may '</span> + <span class="hljs-string">'also be non-null).'</span>, [fragment.loc]);
  } <span class="hljs-comment">// name and type of the node(_: ID) field parameter</span>


  <span class="hljs-keyword">var</span> idArgName = nodeField.args[<span class="hljs-number">0</span>].name;
  <span class="hljs-keyword">var</span> idArgType = nodeField.args[<span class="hljs-number">0</span>].type; <span class="hljs-comment">// name and type of the query variable</span>

  <span class="hljs-keyword">var</span> idVariableType = SchemaUtils.getNonNullIdInput(schema);
  <span class="hljs-keyword">var</span> idVariableName = <span class="hljs-string">'id'</span>;
  <span class="hljs-keyword">var</span> argumentDefinitions = buildOperationArgumentDefinitions(fragment.argumentDefinitions);
  <span class="hljs-keyword">var</span> idArgument = argumentDefinitions.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argDef</span>) </span>{
    <span class="hljs-keyword">return</span> argDef.name === idVariableName;
  });

  <span class="hljs-keyword">if</span> (idArgument != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @refetchable on fragment `"</span>.concat(fragment.name, <span class="hljs-string">"`, this "</span>) + <span class="hljs-string">'fragment already has an `$id` variable in scope.'</span>, [idArgument.loc]);
  }

  <span class="hljs-keyword">var</span> argumentDefinitionsWithId = [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(argumentDefinitions), [{
    <span class="hljs-attr">defaultValue</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'LocalArgumentDefinition'</span>,
    <span class="hljs-attr">loc</span>: {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
      <span class="hljs-attr">source</span>: fragment.loc
    },
    <span class="hljs-attr">name</span>: idVariableName,
    <span class="hljs-attr">type</span>: idVariableType
  }]);
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">identifierField</span>: <span class="hljs-string">'id'</span>,
    <span class="hljs-attr">path</span>: [NODE_FIELD_NAME],
    <span class="hljs-attr">node</span>: {
      <span class="hljs-attr">argumentDefinitions</span>: argumentDefinitionsWithId,
      <span class="hljs-attr">directives</span>: [],
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Root'</span>,
      <span class="hljs-attr">loc</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
        <span class="hljs-attr">source</span>: fragment.loc
      },
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">name</span>: queryName,
      <span class="hljs-attr">operation</span>: <span class="hljs-string">'query'</span>,
      <span class="hljs-attr">selections</span>: [{
        <span class="hljs-attr">alias</span>: NODE_FIELD_NAME,
        <span class="hljs-attr">args</span>: [{
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Argument'</span>,
          <span class="hljs-attr">loc</span>: {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
            <span class="hljs-attr">source</span>: fragment.loc
          },
          <span class="hljs-attr">name</span>: idArgName,
          <span class="hljs-attr">type</span>: schema.assertInputType(idArgType),
          <span class="hljs-attr">value</span>: {
            <span class="hljs-attr">kind</span>: <span class="hljs-string">'Variable'</span>,
            <span class="hljs-attr">loc</span>: {
              <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
              <span class="hljs-attr">source</span>: fragment.loc
            },
            <span class="hljs-attr">variableName</span>: idVariableName,
            <span class="hljs-attr">type</span>: idVariableType
          }
        }],
        <span class="hljs-attr">connection</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">directives</span>: [],
        <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkedField'</span>,
        <span class="hljs-attr">loc</span>: {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
          <span class="hljs-attr">source</span>: fragment.loc
        },
        <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">name</span>: NODE_FIELD_NAME,
        <span class="hljs-attr">selections</span>: [buildFragmentSpread(fragment)],
        <span class="hljs-attr">type</span>: schema.assertLinkedFieldType(nodeType)
      }],
      <span class="hljs-attr">type</span>: queryType
    },
    <span class="hljs-attr">transformedFragment</span>: enforceIDField(schema, fragment)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enforceIDField</span>(<span class="hljs-params">schema, fragment</span>) </span>{
  <span class="hljs-keyword">var</span> idSelection = fragment.selections.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">return</span> selection.kind === <span class="hljs-string">'ScalarField'</span> &amp;&amp; selection.name === <span class="hljs-string">'id'</span> &amp;&amp; selection.alias === <span class="hljs-string">'id'</span> &amp;&amp; schema.areEqualTypes(schema.getNullableType(selection.type), schema.expectIdType());
  });

  <span class="hljs-keyword">if</span> (idSelection) {
    <span class="hljs-keyword">return</span> fragment;
  }

  <span class="hljs-keyword">var</span> idField = schema.getFieldByName(fragment.type, <span class="hljs-string">'id'</span>);
  <span class="hljs-keyword">var</span> nodeType = schema.assertCompositeType(nullthrows(schema.getTypeFromString(NODE_TYPE_NAME)));
  <span class="hljs-keyword">var</span> generatedIDSelection = idField ? SchemaUtils.generateIDField(schema, fragment.type) : {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'InlineFragment'</span>,
    <span class="hljs-attr">directives</span>: [],
    <span class="hljs-attr">loc</span>: {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Generated'</span>
    },
    <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">selections</span>: [SchemaUtils.generateIDField(schema, nodeType)],
    <span class="hljs-attr">typeCondition</span>: nodeType
  };
  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, fragment), {}, {
    <span class="hljs-attr">selections</span>: [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(fragment.selections), [generatedIDSelection])
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">description</span>: <span class="hljs-string">'the Node interface or types implementing the Node interface'</span>,
  <span class="hljs-attr">buildRefetchOperation</span>: buildRefetchOperation
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 97 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-375" id="section-375"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">21</span>),
    buildFragmentSpread = _require.buildFragmentSpread,
    buildOperationArgumentDefinitions = _require.buildOperationArgumentDefinitions;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildRefetchOperation</span>(<span class="hljs-params">schema, fragment, queryName</span>) </span>{
  <span class="hljs-keyword">var</span> queryType = schema.expectQueryType();

  <span class="hljs-keyword">if</span> (!schema.areEqualTypes(fragment.type, queryType)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">identifierField</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">path</span>: [],
    <span class="hljs-attr">node</span>: {
      <span class="hljs-attr">argumentDefinitions</span>: buildOperationArgumentDefinitions(fragment.argumentDefinitions),
      <span class="hljs-attr">directives</span>: [],
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Root'</span>,
      <span class="hljs-attr">loc</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
        <span class="hljs-attr">source</span>: fragment.loc
      },
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">name</span>: queryName,
      <span class="hljs-attr">operation</span>: <span class="hljs-string">'query'</span>,
      <span class="hljs-attr">selections</span>: [buildFragmentSpread(fragment)],
      <span class="hljs-attr">type</span>: queryType
    },
    <span class="hljs-attr">transformedFragment</span>: fragment
  };
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">description</span>: <span class="hljs-string">'the Query type'</span>,
  <span class="hljs-attr">buildRefetchOperation</span>: buildRefetchOperation
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 98 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-376" id="section-376"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">21</span>),
    buildFragmentSpread = _require2.buildFragmentSpread,
    buildOperationArgumentDefinitions = _require2.buildOperationArgumentDefinitions;

<span class="hljs-keyword">var</span> VIEWER_TYPE_NAME = <span class="hljs-string">'Viewer'</span>;
<span class="hljs-keyword">var</span> VIEWER_FIELD_NAME = <span class="hljs-string">'viewer'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildRefetchOperation</span>(<span class="hljs-params">schema, fragment, queryName</span>) </span>{
  <span class="hljs-keyword">if</span> (schema.getTypeString(fragment.type) !== VIEWER_TYPE_NAME) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  } <span class="hljs-comment">// Handle fragments on viewer</span>


  <span class="hljs-keyword">var</span> queryType = schema.expectQueryType();
  <span class="hljs-keyword">var</span> viewerType = schema.getTypeFromString(VIEWER_TYPE_NAME);
  <span class="hljs-keyword">var</span> viewerField = schema.getFieldConfig(schema.expectField(queryType, VIEWER_FIELD_NAME));
  <span class="hljs-keyword">var</span> viewerFieldType = schema.getNullableType(viewerField.type);

  <span class="hljs-keyword">if</span> (!(viewerType &amp;&amp; schema.isObject(viewerType) &amp;&amp; schema.isObject(viewerFieldType) &amp;&amp; schema.areEqualTypes(viewerFieldType, viewerType) &amp;&amp; viewerField.args.length === <span class="hljs-number">0</span> &amp;&amp; schema.areEqualTypes(fragment.type, viewerType))) {
    <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid use of @refetchable on fragment '"</span>.concat(fragment.name, <span class="hljs-string">"', check "</span>) + <span class="hljs-string">"that your schema defines a 'Viewer' object type and has a "</span> + <span class="hljs-string">"'viewer: Viewer' field on the query type."</span>, [fragment.loc]);
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">identifierField</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">path</span>: [VIEWER_FIELD_NAME],
    <span class="hljs-attr">node</span>: {
      <span class="hljs-attr">argumentDefinitions</span>: buildOperationArgumentDefinitions(fragment.argumentDefinitions),
      <span class="hljs-attr">directives</span>: [],
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Root'</span>,
      <span class="hljs-attr">loc</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
        <span class="hljs-attr">source</span>: fragment.loc
      },
      <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">name</span>: queryName,
      <span class="hljs-attr">operation</span>: <span class="hljs-string">'query'</span>,
      <span class="hljs-attr">selections</span>: [{
        <span class="hljs-attr">alias</span>: VIEWER_FIELD_NAME,
        <span class="hljs-attr">args</span>: [],
        <span class="hljs-attr">connection</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">directives</span>: [],
        <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'LinkedField'</span>,
        <span class="hljs-attr">loc</span>: {
          <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
          <span class="hljs-attr">source</span>: fragment.loc
        },
        <span class="hljs-attr">metadata</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">name</span>: VIEWER_FIELD_NAME,
        <span class="hljs-attr">selections</span>: [buildFragmentSpread(fragment)],
        <span class="hljs-attr">type</span>: schema.assertLinkedFieldType(viewerField.type)
      }],
      <span class="hljs-attr">type</span>: queryType
    },
    <span class="hljs-attr">transformedFragment</span>: fragment
  };
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">description</span>: <span class="hljs-string">'the Viewer type'</span>,
  <span class="hljs-attr">buildRefetchOperation</span>: buildRefetchOperation
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 99 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-377" id="section-377"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> t = __webpack_require__(<span class="hljs-number">25</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">48</span>),
    exactObjectTypeAnnotation = _require.exactObjectTypeAnnotation,
    readOnlyArrayOfType = _require.readOnlyArrayOfType;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInputObjectTypeIdentifier</span>(<span class="hljs-params">schema, typeID</span>) </span>{
  <span class="hljs-keyword">return</span> schema.getTypeString(typeID);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformScalarType</span>(<span class="hljs-params">schema, type, state, objectProps</span>) </span>{
  <span class="hljs-keyword">if</span> (schema.isNonNull(type)) {
    <span class="hljs-keyword">return</span> transformNonNullableScalarType(schema, schema.getNullableType(type), state, objectProps);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> t.nullableTypeAnnotation(transformNonNullableScalarType(schema, type, state, objectProps));
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformNonNullableScalarType</span>(<span class="hljs-params">schema, type, state, objectProps</span>) </span>{
  <span class="hljs-keyword">if</span> (schema.isList(type)) {
    <span class="hljs-keyword">return</span> readOnlyArrayOfType(transformScalarType(schema, schema.getListItemType(type), state, objectProps));
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isObject(type) || schema.isUnion(type) || schema.isInterface(type)) {
    <span class="hljs-keyword">return</span> objectProps;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isScalar(type)) {
    <span class="hljs-keyword">return</span> transformGraphQLScalarType(schema.getTypeString(type), state);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isEnum(type)) {
    <span class="hljs-keyword">return</span> transformGraphQLEnumType(schema, schema.assertEnumType(type), state);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Could not convert from GraphQL type "</span>.concat(<span class="hljs-built_in">String</span>(type)));
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformGraphQLScalarType</span>(<span class="hljs-params">typeName, state</span>) </span>{
  <span class="hljs-keyword">var</span> customType = state.customScalars[typeName];

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> customType === <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">return</span> customType(t);
  }

  <span class="hljs-keyword">switch</span> (customType !== <span class="hljs-literal">null</span> &amp;&amp; customType !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? customType : typeName) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'ID'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'String'</span>:
      <span class="hljs-keyword">return</span> t.stringTypeAnnotation();

    <span class="hljs-keyword">case</span> <span class="hljs-string">'Float'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'Int'</span>:
      <span class="hljs-keyword">return</span> t.numberTypeAnnotation();

    <span class="hljs-keyword">case</span> <span class="hljs-string">'Boolean'</span>:
      <span class="hljs-keyword">return</span> t.booleanTypeAnnotation();

    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> customType == <span class="hljs-literal">null</span> ? t.anyTypeAnnotation() : t.genericTypeAnnotation(t.identifier(customType));
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformGraphQLEnumType</span>(<span class="hljs-params">schema, type, state</span>) </span>{
  state.usedEnums[schema.getTypeString(type)] = type;
  <span class="hljs-keyword">return</span> t.genericTypeAnnotation(t.identifier(schema.getTypeString(type)));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformInputType</span>(<span class="hljs-params">schema, type, state</span>) </span>{
  <span class="hljs-keyword">if</span> (schema.isNonNull(type)) {
    <span class="hljs-keyword">return</span> transformNonNullableInputType(schema, schema.getNullableType(type), state);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> t.nullableTypeAnnotation(transformNonNullableInputType(schema, type, state));
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformNonNullableInputType</span>(<span class="hljs-params">schema, type, state</span>) </span>{
  <span class="hljs-keyword">if</span> (schema.isList(type)) {
    <span class="hljs-keyword">return</span> readOnlyArrayOfType(transformInputType(schema, schema.getListItemType(type), state));
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isScalar(type)) {
    <span class="hljs-keyword">return</span> transformGraphQLScalarType(schema.getTypeString(type), state);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isEnum(type)) {
    <span class="hljs-keyword">return</span> transformGraphQLEnumType(schema, schema.assertEnumType(type), state);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (schema.isInputObject(type)) {
    <span class="hljs-keyword">var</span> typeIdentifier = getInputObjectTypeIdentifier(schema, type);

    <span class="hljs-keyword">if</span> (state.generatedInputObjectTypes[typeIdentifier]) {
      <span class="hljs-keyword">return</span> t.genericTypeAnnotation(t.identifier(typeIdentifier));
    }

    state.generatedInputObjectTypes[typeIdentifier] = <span class="hljs-string">'pending'</span>;
    <span class="hljs-keyword">var</span> fields = schema.getFields(schema.assertInputObjectType(type));
    <span class="hljs-keyword">var</span> props = fields.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fieldID</span>) </span>{
      <span class="hljs-keyword">var</span> fieldType = schema.getFieldType(fieldID);
      <span class="hljs-keyword">var</span> fieldName = schema.getFieldName(fieldID);
      <span class="hljs-keyword">var</span> property = t.objectTypeProperty(t.identifier(fieldName), transformInputType(schema, fieldType, state));

      <span class="hljs-keyword">if</span> (state.optionalInputFields.indexOf(fieldName) &gt;= <span class="hljs-number">0</span> || !schema.isNonNull(fieldType)) {
        property.optional = <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">return</span> property;
    });
    state.generatedInputObjectTypes[typeIdentifier] = exactObjectTypeAnnotation(props);
    <span class="hljs-keyword">return</span> t.genericTypeAnnotation(t.identifier(typeIdentifier));
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Could not convert from GraphQL type "</span>.concat(schema.getTypeString(type)));
  }
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transformInputType</span>: transformInputType,
  <span class="hljs-attr">transformScalarType</span>: transformScalarType
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 100 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/generator"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 101 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-378" id="section-378"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipClientExtensionTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">Fragment</span>: visitFragment,
    <span class="hljs-attr">FragmentSpread</span>: vistFragmentSpread,
    <span class="hljs-attr">ClientExtension</span>: visitClientExtension
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitFragment</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();

  <span class="hljs-keyword">if</span> (context.getSchema().isServerType(node.type)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(node);
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">vistFragmentSpread</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> fragment = context.getFragment(node.name, node.loc);
  <span class="hljs-keyword">var</span> isServer = context.getSchema().isServerType(fragment.type);
  <span class="hljs-keyword">return</span> isServer ? node : <span class="hljs-literal">null</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitClientExtension</span>(<span class="hljs-params">node, state</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: skipClientExtensionTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 102 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-379" id="section-379"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-380" id="section-380"></a>
</div>
<div class="dox">
<div class="summary">
<p>A transform that removes field <code>handles</code>. Intended for use when e.g.
printing queries to send to a GraphQL server.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipHandleFieldTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">LinkedField</span>: visitField,
    <span class="hljs-attr">ScalarField</span>: visitField
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitField</span>(<span class="hljs-params">field</span>) </span>{
  <span class="hljs-keyword">var</span> transformedNode = <span class="hljs-keyword">this</span>.traverse(field);

  <span class="hljs-keyword">if</span> (transformedNode.handles) {
    <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, transformedNode), {}, {
      <span class="hljs-attr">handles</span>: <span class="hljs-literal">null</span>
    });
  }

  <span class="hljs-keyword">return</span> transformedNode;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: skipHandleFieldTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 103 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-381" id="section-381"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> IMap = __webpack_require__(<span class="hljs-number">14</span>).Map;

<span class="hljs-keyword">var</span> partitionArray = __webpack_require__(<span class="hljs-number">15</span>);

<span class="hljs-keyword">var</span> getIdentifierForSelection = __webpack_require__(<span class="hljs-number">39</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-382" id="section-382"></a>
</div>
<div class="dox">
<div class="summary">
<p>A transform that removes redundant fields and fragment spreads. Redundancy is
defined in this context as any selection that is guaranteed to already be
fetched by an ancestor selection. This can occur in two cases:</p>
</div>
<div class="body">
<ol>
<li>Simple duplicates at the same level of the document can always be skipped:</li>
</ol>
<pre><code>fragment Foo on FooType {
  id
  id
  ...Bar
  ...Bar
}
</code></pre>
<p>Becomes</p>
<pre><code>fragment Foo on FooType {
  id
  ...Bar
}
</code></pre>
<ol start="2">
<li>Inline fragments and conditions introduce the possibility for duplication
at different levels of the tree. Whenever a selection is fetched in a parent,
it is redundant to also fetch it in a child:</li>
</ol>
<pre><code>fragment Foo on FooType {
  id
  ... on OtherType {
    id # 1
  }
  ... on FooType @include(if: $cond) {
    id # 2
  }
}
</code></pre>
<p>Becomes:</p>
<pre><code>fragment Foo on FooType {
  id
}
</code></pre>
<p>In this example:</p>
<ul>
<li>1 can be skipped because <code>id</code> is already fetched by the parent. Even
though the type is different (FooType/OtherType), the inline fragment
cannot match without the outer fragment matching so the outer <code>id</code> is
guaranteed to already be fetched.</li>
<li>2 can be skipped for similar reasons: it doesn't matter if the condition
holds, <code>id</code> is already fetched by the parent regardless.</li>
</ul>
<p>This transform also handles more complicated cases in which selections are
nested:</p>
<pre><code>fragment Foo on FooType {
  a {
    bb
  }
  ... on OtherType {
    a {
      bb # 1
      cc
    }
  }
 }
</code></pre>
<p>Becomes</p>
<pre><code>fragment Foo on FooType {
  a {
    bb
  }
  ... on OtherType {
    a {
      cc
    }
  }
 }
</code></pre>
<p>1 can be skipped because it is already fetched at the outer level.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipRedundantNodesTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">Root</span>: visitNode,
    <span class="hljs-attr">SplitOperation</span>: visitNode,
    <span class="hljs-attr">Fragment</span>: visitNode
  });
}

<span class="hljs-keyword">var</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitNode</span>(<span class="hljs-params">node</span>) </span>{
  cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">return</span> transformNode(context.getSchema(), node, <span class="hljs-keyword">new</span> IMap()).node;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-383" id="section-383"></a>
</div>
<div class="dox">
<div class="summary">
<p>The most straightforward approach would be two passes: one to record the
structure of the document, one to prune duplicates. This implementation uses
a single pass. Selections are sorted with fields first, &quot;conditionals&quot;
(inline fragments &amp; conditions) last. This means that all fields that are
guaranteed to be fetched are encountered prior to any duplicates that may be
fetched within a conditional.</p>
</div>
<div class="body">
<p>Because selections fetched within a conditional are not guaranteed to be
fetched in the parent, a fork of the selection map is created when entering a
conditional. The sort ensures that guaranteed fields have already been seen
prior to the clone.</p>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformNode</span>(<span class="hljs-params">schema, node, selectionMap</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-384" id="section-384"></a>
</div>
<p>This will optimize a traversal of the same subselections.
If it's the same node, and selectionMap is empty
result of transformNode has to be the same.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> isEmptySelectionMap = selectionMap.size === <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> result;

  <span class="hljs-keyword">if</span> (isEmptySelectionMap) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-385" id="section-385"></a>
</div>
<p>$FlowFixMe[escaped-generic]</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    result = cache.get(node);

    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> result;
    }
  }

  <span class="hljs-keyword">var</span> selections = [];
  sortSelections(node.selections).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">var</span> identifier = getIdentifierForSelection(schema, selection);

    <span class="hljs-keyword">switch</span> (selection.kind) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'ScalarField'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'FragmentSpread'</span>:
        {
          <span class="hljs-keyword">if</span> (!selectionMap.has(identifier)) {
            selections.push(selection);
            selectionMap = selectionMap.set(identifier, <span class="hljs-literal">null</span>);
          }

          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Defer'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Stream'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'ModuleImport'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'ClientExtension'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineDataFragmentSpread'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'LinkedField'</span>:
        {
          <span class="hljs-keyword">var</span> transformed = transformNode(schema, selection, selectionMap.get(identifier) || <span class="hljs-keyword">new</span> IMap());

          <span class="hljs-keyword">if</span> (transformed.node) {
            selections.push(transformed.node);
            selectionMap = selectionMap.set(identifier, transformed.selectionMap);
          }

          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineFragment'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Condition'</span>:
        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-386" id="section-386"></a>
</div>
<p>Fork the selection map to prevent conditional selections from
affecting the outer &quot;guaranteed&quot; selections.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">var</span> _transformed = transformNode(schema, selection, selectionMap.get(identifier) || selectionMap);

          <span class="hljs-keyword">if</span> (_transformed.node) {
            selections.push(_transformed.node);
            selectionMap = selectionMap.set(identifier, _transformed.selectionMap);
          }

          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-attr">default</span>:
        selection;
         <span class="hljs-literal">true</span> ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'SkipRedundantNodesTransform: Unexpected node kind `%s`.'</span>, selection.kind) : <span class="hljs-literal">undefined</span> : <span class="hljs-literal">undefined</span>;
    }
  });
  <span class="hljs-keyword">var</span> nextNode = selections.length ? _objectSpread(_objectSpread({}, node), {}, {
    <span class="hljs-attr">selections</span>: selections
  }) : <span class="hljs-literal">null</span>;
  result = {
    <span class="hljs-attr">selectionMap</span>: selectionMap,
    <span class="hljs-attr">node</span>: nextNode
  };

  <span class="hljs-keyword">if</span> (isEmptySelectionMap) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-387" id="section-387"></a>
</div>
<p>$FlowFixMe[escaped-generic]</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    cache.set(node, result);
  }

  <span class="hljs-keyword">return</span> result;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-388" id="section-388"></a>
</div>
<div class="dox">
<div class="summary">
<p>Sort inline fragments and conditions after other selections.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortSelections</span>(<span class="hljs-params">selections</span>) </span>{
  <span class="hljs-keyword">var</span> isScalarOrLinkedField = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isScalarOrLinkedField</span>(<span class="hljs-params">selection</span>) </span>{
    <span class="hljs-keyword">return</span> selection.kind === <span class="hljs-string">'ScalarField'</span> || selection.kind === <span class="hljs-string">'LinkedField'</span>;
  };

  <span class="hljs-keyword">var</span> _partitionArray = partitionArray(selections, isScalarOrLinkedField),
      scalarsAndLinkedFields = _partitionArray[<span class="hljs-number">0</span>],
      rest = _partitionArray[<span class="hljs-number">1</span>];

  <span class="hljs-keyword">return</span> [].concat((<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(scalarsAndLinkedFields), (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(rest));
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: skipRedundantNodesTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 104 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-389" id="section-389"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipNode</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-390" id="section-390"></a>
</div>
<div class="dox">
<div class="summary">
<p>A transform that removes field <code>splitOperations</code>. Intended for use when e.g.
printing queries to send to a GraphQL server.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipSplitOperationTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">SplitOperation</span>: skipNode
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: skipSplitOperationTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 105 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-391" id="section-391"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> FAIL = <span class="hljs-string">'fail'</span>;
<span class="hljs-keyword">var</span> PASS = <span class="hljs-string">'pass'</span>;
<span class="hljs-keyword">var</span> VARIABLE = <span class="hljs-string">'variable'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-392" id="section-392"></a>
</div>
<div class="dox">
<div class="summary">
<p>A tranform that removes unreachable IR nodes from all documents in a corpus.
The following nodes are removed:</p>
<ul>
<li>Any node with <code>@include(if: false)</code></li>
<li>Any node with <code>@skip(if: true)</code></li>
<li>Any node with empty <code>selections</code></li>
</ul>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipUnreachableNodeTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> fragments = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">var</span> nextContext = IRTransformer.transform(context, {
    <span class="hljs-attr">Root</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Root</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> transformNode(context, fragments, node);
    },
    <span class="hljs-attr">SplitOperation</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SplitOperation</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> transformNode(context, fragments, node);
    },
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-393" id="section-393"></a>
</div>
<p>Fragments are included below where referenced.
Unreferenced fragments are not included.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">    Fragment: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fragment</span>(<span class="hljs-params">id</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  });
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(fragments.values()).reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, fragment</span>) </span>{
    <span class="hljs-keyword">return</span> fragment ? ctx.add(fragment) : ctx;
  }, nextContext);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformNode</span>(<span class="hljs-params">context, fragments, node</span>) </span>{
  <span class="hljs-keyword">var</span> queue = (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(node.selections);
  <span class="hljs-keyword">var</span> selections;

  <span class="hljs-keyword">while</span> (queue.length) {
    <span class="hljs-keyword">var</span> selection = queue.shift();
    <span class="hljs-keyword">var</span> nextSelection = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">switch</span> (selection.kind) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'Condition'</span>:
        <span class="hljs-keyword">var</span> match = testCondition(selection);

        <span class="hljs-keyword">if</span> (match === PASS) {
          queue.unshift.apply(queue, (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(selection.selections));
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (match === VARIABLE) {
          nextSelection = transformNode(context, fragments, selection);
        }

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'FragmentSpread'</span>:
        {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-394" id="section-394"></a>
</div>
<p>Skip fragment spreads if the referenced fragment is empty</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">if</span> (!fragments.has(selection.name)) {
            <span class="hljs-keyword">var</span> fragment = context.getFragment(selection.name);
            <span class="hljs-keyword">var</span> nextFragment = transformNode(context, fragments, fragment);
            fragments.set(selection.name, nextFragment);
          }

          <span class="hljs-keyword">if</span> (fragments.get(selection.name)) {
            nextSelection = selection;
          }

          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ClientExtension'</span>:
        nextSelection = transformNode(context, fragments, selection);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ModuleImport'</span>:
        nextSelection = transformNode(context, fragments, selection);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'LinkedField'</span>:
        nextSelection = transformNode(context, fragments, selection);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineFragment'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-395" id="section-395"></a>
</div>
<p>TODO combine with the LinkedField case when flow supports this</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        nextSelection = transformNode(context, fragments, selection);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Defer'</span>:
        nextSelection = transformNode(context, fragments, selection);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'Stream'</span>:
        nextSelection = transformNode(context, fragments, selection);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ScalarField'</span>:
        nextSelection = selection;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineDataFragmentSpread'</span>:
         <span class="hljs-literal">true</span> ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'SkipUnreachableNodeTransform: Did not expect an '</span> + <span class="hljs-string">'InlineDataFragmentSpread here. Only expecting '</span> + <span class="hljs-string">'InlineDataFragmentSpread in reader ASTs and this transform to '</span> + <span class="hljs-string">'run only on normalization ASTs.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-literal">undefined</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-396" id="section-396"></a>
</div>
<p>fallthrough</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
      <span class="hljs-attr">default</span>:
        selection.kind;
         <span class="hljs-literal">true</span> ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'SkipUnreachableNodeTransform: Unexpected selection kind `%s`.'</span>, selection.kind) : <span class="hljs-literal">undefined</span> : <span class="hljs-literal">undefined</span>;
    }

    <span class="hljs-keyword">if</span> (nextSelection) {
      selections = selections || [];
      selections.push(nextSelection);
    }
  }

  <span class="hljs-keyword">if</span> (selections) {
    <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, node), {}, {
      <span class="hljs-attr">selections</span>: selections
    });
  }

  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-397" id="section-397"></a>
</div>
<div class="dox">
<div class="summary">
<p>Determines whether a condition statically passes/fails or is unknown
(variable).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testCondition</span>(<span class="hljs-params">condition</span>) </span>{
  <span class="hljs-keyword">if</span> (condition.condition.kind === <span class="hljs-string">'Variable'</span>) {
    <span class="hljs-keyword">return</span> VARIABLE;
  }

  <span class="hljs-keyword">return</span> condition.condition.value === condition.passingValue ? PASS : FAIL;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: skipUnreachableNodeTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 106 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-398" id="section-398"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> inferRootArgumentDefinitions = __webpack_require__(<span class="hljs-number">20</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-399" id="section-399"></a>
</div>
<div class="dox">
<div class="summary">
<p>Refines the argument definitions for operations to remove unused arguments
due to statically pruned conditional branches (e.g. because of overriding
a variable used in <code>@include()</code> to be false).</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">skipUnusedVariablesTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> contextWithUsedArguments = inferRootArgumentDefinitions(context);
  <span class="hljs-keyword">return</span> context.withMutations(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctx</span>) </span>{
    <span class="hljs-keyword">var</span> nextContext = ctx;

    <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(nextContext.documents()),
        _step;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">var</span> _loop = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_loop</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> node = _step.value;

        <span class="hljs-keyword">if</span> (node.kind !== <span class="hljs-string">'Root'</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-string">"continue"</span>;
        }

        <span class="hljs-keyword">var</span> usedArguments = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(contextWithUsedArguments.getRoot(node.name).argumentDefinitions.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argDef</span>) </span>{
          <span class="hljs-keyword">return</span> argDef.name;
        })); <span class="hljs-comment">// Remove unused argument definitions</span>

        <span class="hljs-keyword">var</span> usedArgumentDefinitions = node.argumentDefinitions.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argDef</span>) </span>{
          <span class="hljs-keyword">return</span> usedArguments.has(argDef.name);
        });

        <span class="hljs-keyword">if</span> (usedArgumentDefinitions.length !== node.argumentDefinitions.length) {
          nextContext = nextContext.replace(_objectSpread(_objectSpread({}, node), {}, {
            <span class="hljs-attr">argumentDefinitions</span>: usedArgumentDefinitions
          }));
        }
      };

      <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
        <span class="hljs-keyword">var</span> _ret = _loop();

        <span class="hljs-keyword">if</span> (_ret === <span class="hljs-string">"continue"</span>) <span class="hljs-keyword">continue</span>;
      }
    } <span class="hljs-keyword">catch</span> (err) {
      _iterator.e(err);
    } <span class="hljs-keyword">finally</span> {
      _iterator.f();
    }

    <span class="hljs-keyword">return</span> nextContext;
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: skipUnusedVariablesTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 107 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-400" id="section-400"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

<span class="hljs-keyword">var</span> getNormalizationOperationName = __webpack_require__(<span class="hljs-number">43</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-401" id="section-401"></a>
</div>
<div class="dox">
<div class="summary">
<p>This transform creates a SplitOperation root for every ModuleImport.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">splitMatchTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> splitOperations = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
  <span class="hljs-keyword">var</span> transformedContext = IRTransformer.transform(context, {
    <span class="hljs-attr">LinkedField</span>: visitLinkedField,
    <span class="hljs-attr">InlineFragment</span>: visitInlineFragment,
    <span class="hljs-attr">ModuleImport</span>: visitModuleImport
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">parentType</span>: node.type,
      <span class="hljs-attr">splitOperations</span>: splitOperations
    };
  });
  <span class="hljs-keyword">return</span> transformedContext.addAll(<span class="hljs-built_in">Array</span>.from(splitOperations.values()));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitLinkedField</span>(<span class="hljs-params">field, state</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(field, {
    <span class="hljs-attr">parentType</span>: field.type,
    <span class="hljs-attr">splitOperations</span>: state.splitOperations
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitInlineFragment</span>(<span class="hljs-params">fragment, state</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.traverse(fragment, {
    <span class="hljs-attr">parentType</span>: fragment.typeCondition,
    <span class="hljs-attr">splitOperations</span>: state.splitOperations
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitModuleImport</span>(<span class="hljs-params">node, state</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-402" id="section-402"></a>
</div>
<p>It's possible for the same fragment to be selected in multiple usages
of @module: skip processing a node if its SplitOperation has already
been generated</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> normalizationName = getNormalizationOperationName(node.name);
  <span class="hljs-keyword">var</span> createdSplitOperation = state.splitOperations.get(normalizationName);

  <span class="hljs-keyword">if</span> (createdSplitOperation) {
    createdSplitOperation.parentSources.add(node.sourceDocument);
    <span class="hljs-keyword">return</span> node;
  }

  <span class="hljs-keyword">var</span> transformedNode = <span class="hljs-keyword">this</span>.traverse(node, state);
  <span class="hljs-keyword">var</span> splitOperation = {
    <span class="hljs-attr">kind</span>: <span class="hljs-string">'SplitOperation'</span>,
    <span class="hljs-attr">name</span>: normalizationName,
    <span class="hljs-attr">selections</span>: transformedNode.selections,
    <span class="hljs-attr">loc</span>: {
      <span class="hljs-attr">kind</span>: <span class="hljs-string">'Derived'</span>,
      <span class="hljs-attr">source</span>: node.loc
    },
    <span class="hljs-attr">parentSources</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([node.sourceDocument]),
    <span class="hljs-attr">metadata</span>: {
      <span class="hljs-attr">derivedFrom</span>: transformedNode.name
    },
    <span class="hljs-attr">type</span>: state.parentType
  };
  state.splitOperations.set(normalizationName, splitOperation);
  <span class="hljs-keyword">return</span> transformedNode;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: splitMatchTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 108 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-403" id="section-403"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ownKeys</span>(<span class="hljs-params">object, enumerableOnly</span>) </span>{ <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(object); <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertySymbols) { <span class="hljs-keyword">var</span> symbols = <span class="hljs-built_in">Object</span>.getOwnPropertySymbols(object); <span class="hljs-keyword">if</span> (enumerableOnly) symbols = symbols.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sym</span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } <span class="hljs-keyword">return</span> keys; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_objectSpread</span>(<span class="hljs-params">target</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) { <span class="hljs-keyword">var</span> source = <span class="hljs-built_in">arguments</span>[i] != <span class="hljs-literal">null</span> ? <span class="hljs-built_in">arguments</span>[i] : {}; <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) { ownKeys(<span class="hljs-built_in">Object</span>(source), <span class="hljs-literal">true</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(target, key, source[key]); }); } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors) { <span class="hljs-built_in">Object</span>.defineProperties(target, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(source)); } <span class="hljs-keyword">else</span> { ownKeys(<span class="hljs-built_in">Object</span>(source)).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{ <span class="hljs-built_in">Object</span>.defineProperty(target, key, <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, key)); }); } } <span class="hljs-keyword">return</span> target; }

<span class="hljs-keyword">var</span> IRTransformer = __webpack_require__(<span class="hljs-number">3</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-404" id="section-404"></a>
</div>
<p>The purpose of this directive is to add GraphQL type inform for fields in
the operation selection in order to use in in RelayMockPayloadGenerator
to generate better mock values, and expand the API of MockResolvers</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> SCHEMA_EXTENSION = <span class="hljs-string">'directive @relay_test_operation on QUERY | MUTATION | SUBSCRIPTION'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testOperationDirective</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">return</span> IRTransformer.transform(context, {
    <span class="hljs-attr">Fragment</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fragment</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> node;
    },
    <span class="hljs-attr">Root</span>: visitRoot,
    <span class="hljs-attr">SplitOperation</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SplitOperation</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">return</span> node;
    }
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTypeDetails</span>(<span class="hljs-params">schema, fieldType</span>) </span>{
  <span class="hljs-keyword">var</span> nullableType = schema.getNullableType(fieldType);
  <span class="hljs-keyword">var</span> isNullable = !schema.isNonNull(fieldType);
  <span class="hljs-keyword">var</span> isPlural = schema.isList(nullableType);
  <span class="hljs-keyword">var</span> type = schema.getRawType(nullableType);
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">enumValues</span>: schema.isEnum(type) ? schema.getEnumValues(schema.assertEnumType(type)) : <span class="hljs-literal">null</span>,
    <span class="hljs-attr">nullable</span>: isNullable,
    <span class="hljs-attr">plural</span>: isPlural,
    <span class="hljs-attr">type</span>: schema.getTypeString(type)
  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitRoot</span>(<span class="hljs-params">node</span>) </span>{
  <span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">this</span>.getContext().getSchema();
  <span class="hljs-keyword">var</span> testDirective = node.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
    <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'relay_test_operation'</span>;
  });

  <span class="hljs-keyword">if</span> (testDirective == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> node;
  }

  <span class="hljs-keyword">var</span> queue = [{
    <span class="hljs-attr">selections</span>: node.selections,
    <span class="hljs-attr">path</span>: <span class="hljs-literal">null</span>
  }];
  <span class="hljs-keyword">var</span> selectionsTypeInfo = {};

  <span class="hljs-keyword">var</span> _loop = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_loop</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> _queue$pop = queue.pop(),
        currentSelections = _queue$pop.selections,
        path = _queue$pop.path;

    currentSelections.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selection</span>) </span>{
      <span class="hljs-keyword">switch</span> (selection.kind) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'FragmentSpread'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-405" id="section-405"></a>
</div>
<p>We don't expect to have fragment spreads at this point (it's operations only transform step)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'ScalarField'</span>:
          {
            <span class="hljs-keyword">var</span> nextPath = path === <span class="hljs-literal">null</span> ? selection.alias : <span class="hljs-string">""</span>.concat(path, <span class="hljs-string">"."</span>).concat(selection.alias);
            selectionsTypeInfo[nextPath] = getTypeDetails(schema, selection.type);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">'LinkedField'</span>:
          {
            <span class="hljs-keyword">var</span> _nextPath = path === <span class="hljs-literal">null</span> ? selection.alias : <span class="hljs-string">""</span>.concat(path, <span class="hljs-string">"."</span>).concat(selection.alias);

            selectionsTypeInfo[_nextPath] = getTypeDetails(schema, selection.type);
            queue.push({
              <span class="hljs-attr">selections</span>: selection.selections,
              <span class="hljs-attr">path</span>: _nextPath
            });
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">'Condition'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'Defer'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineDataFragmentSpread'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'InlineFragment'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'ModuleImport'</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">'Stream'</span>:
          queue.push({
            <span class="hljs-attr">selections</span>: selection.selections,
            <span class="hljs-attr">path</span>: path
          });
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">'ClientExtension'</span>:
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-406" id="section-406"></a>
</div>
<p>Clinet extensions are not part of the schema. We should not generate type info.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
          selection;
          <span class="hljs-keyword">break</span>;
      }
    });
  };

  <span class="hljs-keyword">while</span> (queue.length &gt; <span class="hljs-number">0</span>) {
    _loop();
  } <span class="hljs-comment">// Sort selectionsTypeInfo</span>


  <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(selectionsTypeInfo).sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>{
    <span class="hljs-keyword">return</span> a &lt; b ? <span class="hljs-number">-1</span> : a &gt; b ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
  });
  <span class="hljs-keyword">var</span> sortedSelectionsTypeInfo = {};
  keys.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>{
    sortedSelectionsTypeInfo[key] = selectionsTypeInfo[key];
  });
  <span class="hljs-keyword">return</span> _objectSpread(_objectSpread({}, node), {}, {
    <span class="hljs-attr">directives</span>: node.directives.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> directive !== testDirective;
    }),
    <span class="hljs-attr">metadata</span>: _objectSpread(_objectSpread({}, node.metadata || {}), {}, {
      <span class="hljs-attr">relayTestingSelectionTypeInfo</span>: sortedSelectionsTypeInfo
    })
  });
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">SCHEMA_EXTENSION</span>: SCHEMA_EXTENSION,
  <span class="hljs-attr">transform</span>: testOperationDirective
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 109 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-407" id="section-407"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> inferRootArgumentDefinitions = __webpack_require__(<span class="hljs-number">20</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError,
    eachWithCombinedError = _require.eachWithCombinedError;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-408" id="section-408"></a>
</div>
<div class="dox">
<div class="summary">
<p>Validates that all global variables used in operations are defined at the
root. This isn't a real transform as it returns the original context, but
has to happen before other transforms strip certain variable usages.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateGlobalVariablesTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> contextWithUsedArguments = inferRootArgumentDefinitions(context);
  eachWithCombinedError(context.documents(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">if</span> (node.kind !== <span class="hljs-string">'Root'</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> nodeWithUsedArguments = contextWithUsedArguments.getRoot(node.name);
    <span class="hljs-keyword">var</span> definedArguments = argumentDefinitionsToMap(node.argumentDefinitions);
    <span class="hljs-keyword">var</span> usedArguments = argumentDefinitionsToMap(nodeWithUsedArguments.argumentDefinitions); <span class="hljs-comment">// All used arguments must be defined</span>

    <span class="hljs-keyword">var</span> undefinedVariables = [];

    <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(usedArguments.values()),
        _step;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
        <span class="hljs-keyword">var</span> argDef = _step.value;

        <span class="hljs-keyword">if</span> (!definedArguments.has(argDef.name)) {
          undefinedVariables.push(argDef);
        }
      }
    } <span class="hljs-keyword">catch</span> (err) {
      _iterator.e(err);
    } <span class="hljs-keyword">finally</span> {
      _iterator.f();
    }

    <span class="hljs-keyword">if</span> (undefinedVariables.length !== <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Operation '"</span>.concat(node.name, <span class="hljs-string">"' references undefined variable(s):\n"</span>).concat(undefinedVariables.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argDef</span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"- $"</span>.concat(argDef.name, <span class="hljs-string">": "</span>).concat(context.getSchema().getTypeString(argDef.type));
      }).join(<span class="hljs-string">'\n'</span>), <span class="hljs-string">"."</span>), undefinedVariables.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">argDef</span>) </span>{
        <span class="hljs-keyword">return</span> argDef.loc;
      }));
    }
  });
  <span class="hljs-keyword">return</span> context;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">argumentDefinitionsToMap</span>(<span class="hljs-params">argDefs</span>) </span>{
  <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-keyword">var</span> _iterator2 = _createForOfIteratorHelper(argDefs),
      _step2;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      <span class="hljs-keyword">var</span> argDef = _step2.value;
      map.set(argDef.name, argDef);
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator2.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator2.f();
  }

  <span class="hljs-keyword">return</span> map;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: validateGlobalVariablesTransform
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 110 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-409" id="section-409"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> IRValidator = __webpack_require__(<span class="hljs-number">37</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">30</span>),
    getFieldDefinitionStrict = _require2.getFieldDefinitionStrict;

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-410" id="section-410"></a>
</div>
<div class="dox">
<div class="summary">
<p>Validate required arguments are provided after transforms filling in arguments</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateRequiredArguments</span>(<span class="hljs-params">context</span>) </span>{
  IRValidator.validate(context, {
    <span class="hljs-attr">Directive</span>: visitDirective,
    <span class="hljs-attr">InlineFragment</span>: visitInlineFragment,
    <span class="hljs-attr">LinkedField</span>: visitField,
    <span class="hljs-attr">ScalarField</span>: visitField <span class="hljs-comment">// FragmentSpread validation is done in ApplyFragmentArgumentTransform</span>

  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">rootNode</span>: node,
      <span class="hljs-attr">parentType</span>: node.type
    };
  });
  <span class="hljs-keyword">return</span> context;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitDirective</span>(<span class="hljs-params">node, _ref</span>) </span>{
  <span class="hljs-keyword">var</span> rootNode = _ref.rootNode;
  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> directiveDef = context.getSchema().getDirective(node.name);

  <span class="hljs-keyword">if</span> (directiveDef == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  }

  validateRequiredArgumentsOnNode(context.getSchema(), node, directiveDef.args, rootNode);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitInlineFragment</span>(<span class="hljs-params">fragment, _ref2</span>) </span>{
  <span class="hljs-keyword">var</span> rootNode = _ref2.rootNode;
  <span class="hljs-keyword">this</span>.traverse(fragment, {
    <span class="hljs-attr">rootNode</span>: rootNode,
    <span class="hljs-attr">parentType</span>: fragment.typeCondition
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visitField</span>(<span class="hljs-params">node, _ref3</span>) </span>{
  <span class="hljs-keyword">var</span> parentType = _ref3.parentType,
      rootNode = _ref3.rootNode;
  <span class="hljs-keyword">var</span> context = <span class="hljs-keyword">this</span>.getContext();
  <span class="hljs-keyword">var</span> schema = context.getSchema();
  <span class="hljs-keyword">var</span> definition = getFieldDefinitionStrict(schema, parentType, node.name);

  <span class="hljs-keyword">if</span> (definition == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">var</span> isLegacyFatInterface = node.directives.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">directive</span>) </span>{
      <span class="hljs-keyword">return</span> directive.name === <span class="hljs-string">'fixme_fat_interface'</span>;
    });

    <span class="hljs-keyword">if</span> (!isLegacyFatInterface) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Unknown field '"</span>.concat(node.name, <span class="hljs-string">"' on type "</span>) + <span class="hljs-string">"'"</span>.concat(schema.getTypeString(parentType), <span class="hljs-string">"'."</span>), [node.loc]);
    }
  } <span class="hljs-keyword">else</span> {
    validateRequiredArgumentsOnNode(schema, node, schema.getFieldConfig(definition).args, rootNode);
  }

  <span class="hljs-keyword">this</span>.traverse(node, {
    <span class="hljs-attr">rootNode</span>: rootNode,
    <span class="hljs-attr">parentType</span>: node.type
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateRequiredArgumentsOnNode</span>(<span class="hljs-params">schema, node, definitionArgs, rootNode</span>) </span>{
  <span class="hljs-keyword">var</span> nodeArgsSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(node.args.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
    <span class="hljs-keyword">return</span> arg.name;
  }));

  <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(definitionArgs),
      _step;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
      <span class="hljs-keyword">var</span> arg = _step.value;

      <span class="hljs-keyword">if</span> (arg.defaultValue == <span class="hljs-literal">null</span> &amp;&amp; schema.isNonNull(arg.type) &amp;&amp; !nodeArgsSet.has(arg.name)) {
        <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Required argument '"</span>.concat(arg.name, <span class="hljs-string">": "</span>).concat(schema.getTypeString(arg.type), <span class="hljs-string">"' "</span>) + <span class="hljs-string">"is missing on '"</span>.concat(node.name, <span class="hljs-string">"' in '"</span>).concat(rootNode.name, <span class="hljs-string">"'."</span>), [node.loc, rootNode.loc]);
      }
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator.f();
  }
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: validateRequiredArguments
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 111 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-411" id="section-411"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_createForOfIteratorHelper</span>(<span class="hljs-params">o, allowArrayLike</span>) </span>{ <span class="hljs-keyword">var</span> it; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"undefined"</span> || o[<span class="hljs-built_in">Symbol</span>.iterator] == <span class="hljs-literal">null</span>) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; <span class="hljs-keyword">typeof</span> o.length === <span class="hljs-string">"number"</span>) { <span class="hljs-keyword">if</span> (it) o = it; <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{}; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: F, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">if</span> (i &gt;= o.length) <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> }; <span class="hljs-keyword">return</span> { <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>: o[i++] }; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e</span>) </span>{ <span class="hljs-keyword">throw</span> _e; }, <span class="hljs-attr">f</span>: F }; } <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."</span>); } <span class="hljs-keyword">var</span> normalCompletion = <span class="hljs-literal">true</span>, didErr = <span class="hljs-literal">false</span>, err; <span class="hljs-keyword">return</span> { <span class="hljs-attr">s</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">s</span>(<span class="hljs-params"></span>) </span>{ it = o[<span class="hljs-built_in">Symbol</span>.iterator](); }, <span class="hljs-attr">n</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">n</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">var</span> step = it.next(); normalCompletion = step.done; <span class="hljs-keyword">return</span> step; }, <span class="hljs-attr">e</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">e</span>(<span class="hljs-params">_e2</span>) </span>{ didErr = <span class="hljs-literal">true</span>; err = _e2; }, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">try</span> { <span class="hljs-keyword">if</span> (!normalCompletion &amp;&amp; it[<span class="hljs-string">"return"</span>] != <span class="hljs-literal">null</span>) it[<span class="hljs-string">"return"</span>](); } <span class="hljs-keyword">finally</span> { <span class="hljs-keyword">if</span> (didErr) <span class="hljs-keyword">throw</span> err; } } }; }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_unsupportedIterableToArray</span>(<span class="hljs-params">o, minLen</span>) </span>{ <span class="hljs-keyword">if</span> (!o) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> o === <span class="hljs-string">"string"</span>) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">Object</span>.prototype.toString.call(o).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Object"</span> &amp;&amp; o.constructor) n = o.constructor.name; <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Map"</span> || n === <span class="hljs-string">"Set"</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(o); <span class="hljs-keyword">if</span> (n === <span class="hljs-string">"Arguments"</span> || <span class="hljs-regexp">/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/</span>.test(n)) <span class="hljs-keyword">return</span> _arrayLikeToArray(o, minLen); }

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_arrayLikeToArray</span>(<span class="hljs-params">arr, len</span>) </span>{ <span class="hljs-keyword">if</span> (len == <span class="hljs-literal">null</span> || len &gt; arr.length) len = arr.length; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len); i &lt; len; i++) { arr2[i] = arr[i]; } <span class="hljs-keyword">return</span> arr2; }

<span class="hljs-keyword">var</span> inferRootArgumentDefinitions = __webpack_require__(<span class="hljs-number">20</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">1</span>),
    createUserError = _require.createUserError,
    eachWithCombinedError = _require.eachWithCombinedError;

<span class="hljs-keyword">var</span> SCHEMA_EXTENSION = <span class="hljs-string">'directive @DEPRECATED__relay_ignore_unused_variables_error on QUERY | MUTATION | SUBSCRIPTION'</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-412" id="section-412"></a>
</div>
<div class="dox">
<div class="summary">
<p>Validates that there are no unused variables in the operation.
former `graphql-js`` NoUnusedVariablesRule</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateUnusedVariablesTransform</span>(<span class="hljs-params">context</span>) </span>{
  <span class="hljs-keyword">var</span> contextWithUsedArguments = inferRootArgumentDefinitions(context);
  eachWithCombinedError(context.documents(), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
    <span class="hljs-keyword">if</span> (node.kind !== <span class="hljs-string">'Root'</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> rootArgumentLocations = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(node.argumentDefinitions.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>{
      <span class="hljs-keyword">return</span> [arg.name, arg.loc];
    }));
    <span class="hljs-keyword">var</span> nodeWithUsedArguments = contextWithUsedArguments.getRoot(node.name);
    <span class="hljs-keyword">var</span> usedArguments = argumentDefinitionsToMap(nodeWithUsedArguments.argumentDefinitions);

    <span class="hljs-keyword">var</span> _iterator = _createForOfIteratorHelper(usedArguments.keys()),
        _step;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">for</span> (_iterator.s(); !(_step = _iterator.n()).done;) {
        <span class="hljs-keyword">var</span> usedArgumentName = _step.value;
        rootArgumentLocations[<span class="hljs-string">"delete"</span>](usedArgumentName);
      }
    } <span class="hljs-keyword">catch</span> (err) {
      _iterator.e(err);
    } <span class="hljs-keyword">finally</span> {
      _iterator.f();
    }

    <span class="hljs-keyword">var</span> ignoreErrorDirective = node.directives.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_ref</span>) </span>{
      <span class="hljs-keyword">var</span> name = _ref.name;
      <span class="hljs-keyword">return</span> name === <span class="hljs-string">'DEPRECATED__relay_ignore_unused_variables_error'</span>;
    });

    <span class="hljs-keyword">if</span> (rootArgumentLocations.size &gt; <span class="hljs-number">0</span> &amp;&amp; !ignoreErrorDirective) {
      <span class="hljs-keyword">var</span> isPlural = rootArgumentLocations.size &gt; <span class="hljs-number">1</span>;
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Variable"</span>.concat(isPlural ? <span class="hljs-string">'s'</span> : <span class="hljs-string">''</span>, <span class="hljs-string">" '$"</span>).concat(<span class="hljs-built_in">Array</span>.from(rootArgumentLocations.keys()).join(<span class="hljs-string">"', '$"</span>), <span class="hljs-string">"' "</span>).concat(isPlural ? <span class="hljs-string">'are'</span> : <span class="hljs-string">'is'</span>, <span class="hljs-string">" never used in operation '"</span>).concat(node.name, <span class="hljs-string">"'."</span>), <span class="hljs-built_in">Array</span>.from(rootArgumentLocations.values()));
    }

    <span class="hljs-keyword">if</span> (rootArgumentLocations.size === <span class="hljs-number">0</span> &amp;&amp; ignoreErrorDirective) {
      <span class="hljs-keyword">throw</span> createUserError(<span class="hljs-string">"Invalid usage of '@DEPRECATED__relay_ignore_unused_variables_error.'"</span> + <span class="hljs-string">"No unused variables found in the query '"</span>.concat(node.name, <span class="hljs-string">"'"</span>), [ignoreErrorDirective.loc]);
    }
  });
  <span class="hljs-keyword">return</span> context;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">argumentDefinitionsToMap</span>(<span class="hljs-params">argDefs</span>) </span>{
  <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

  <span class="hljs-keyword">var</span> _iterator2 = _createForOfIteratorHelper(argDefs),
      _step2;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">for</span> (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      <span class="hljs-keyword">var</span> argDef = _step2.value;
      map.set(argDef.name, argDef);
    }
  } <span class="hljs-keyword">catch</span> (err) {
    _iterator2.e(err);
  } <span class="hljs-keyword">finally</span> {
    _iterator2.f();
  }

  <span class="hljs-keyword">return</span> map;
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">transform</span>: validateUnusedVariablesTransform,
  <span class="hljs-attr">SCHEMA_EXTENSION</span>: SCHEMA_EXTENSION
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 112 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-413" id="section-413"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> RelayFlowGenerator = __webpack_require__(<span class="hljs-number">46</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">113</span>),
    find = _require.find;

<span class="hljs-keyword">var</span> _require2 = __webpack_require__(<span class="hljs-number">115</span>),
    formatGeneratedCommonjsModule = _require2.formatGeneratedCommonjsModule,
    formatGeneratedESModule = _require2.formatGeneratedESModule;

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">inputExtensions</span>: [<span class="hljs-string">'js'</span>, <span class="hljs-string">'jsx'</span>],
    <span class="hljs-attr">outputExtension</span>: <span class="hljs-string">'js'</span>,
    <span class="hljs-attr">typeGenerator</span>: RelayFlowGenerator,
    <span class="hljs-attr">formatModule</span>: options &amp;&amp; options.eagerESModules ? formatGeneratedESModule : formatGeneratedCommonjsModule,
    <span class="hljs-attr">findGraphQLTags</span>: find
  };
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 113 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-414" id="section-414"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>);

<span class="hljs-keyword">var</span> babylon = __webpack_require__(<span class="hljs-number">114</span>);

<span class="hljs-keyword">var</span> util = __webpack_require__(<span class="hljs-number">49</span>);

</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-415" id="section-415"></a>
</div>
<p>Attempt to be as inclusive as possible of source text.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript"><span class="hljs-keyword">var</span> BABYLON_OPTIONS = {
  <span class="hljs-attr">allowImportExportEverywhere</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">allowReturnOutsideFunction</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">allowSuperOutsideMethod</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">sourceType</span>: <span class="hljs-string">'module'</span>,
  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">'asyncGenerators'</span>, <span class="hljs-string">'classProperties'</span>, [<span class="hljs-string">'decorators'</span>, {
    <span class="hljs-attr">decoratorsBeforeExport</span>: <span class="hljs-literal">true</span>
  }], <span class="hljs-string">'doExpressions'</span>, <span class="hljs-string">'dynamicImport'</span>, <span class="hljs-string">'exportExtensions'</span>, [<span class="hljs-string">'flow'</span>, {
    <span class="hljs-attr">enums</span>: <span class="hljs-literal">true</span>
  }], <span class="hljs-string">'functionBind'</span>, <span class="hljs-string">'functionSent'</span>, <span class="hljs-string">'jsx'</span>, <span class="hljs-string">'nullishCoalescingOperator'</span>, <span class="hljs-string">'objectRestSpread'</span>, <span class="hljs-string">'optionalChaining'</span>, <span class="hljs-string">'optionalCatchBinding'</span>],
  <span class="hljs-attr">strictMode</span>: <span class="hljs-literal">false</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">text</span>) </span>{
  <span class="hljs-keyword">var</span> result = []; <span class="hljs-comment">// $FlowFixMe Discovered when typing babel/parser</span>

  <span class="hljs-keyword">var</span> ast = babylon.parse(text, BABYLON_OPTIONS);
  <span class="hljs-keyword">var</span> visitors = {
    <span class="hljs-attr">TaggedTemplateExpression</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TaggedTemplateExpression</span>(<span class="hljs-params">node</span>) </span>{
      <span class="hljs-keyword">if</span> (isGraphQLTag(node.tag)) {
        result.push({
          <span class="hljs-attr">keyName</span>: <span class="hljs-literal">null</span>,
          <span class="hljs-attr">template</span>: node.quasi.quasis[<span class="hljs-number">0</span>].value.raw,
          <span class="hljs-attr">sourceLocationOffset</span>: getSourceLocationOffset(node.quasi)
        });
      }
    }
  };
  visit(ast, visitors);
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-keyword">var</span> IGNORED_KEYS = {
  <span class="hljs-attr">comments</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">end</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">leadingComments</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">loc</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">start</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">trailingComments</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-literal">true</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isGraphQLTag</span>(<span class="hljs-params">tag</span>) </span>{
  <span class="hljs-keyword">return</span> tag.type === <span class="hljs-string">'Identifier'</span> &amp;&amp; tag.name === <span class="hljs-string">'graphql'</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTemplateNode</span>(<span class="hljs-params">quasi</span>) </span>{
  <span class="hljs-keyword">var</span> quasis = quasi.quasis;
  !(quasis &amp;&amp; quasis.length === <span class="hljs-number">1</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'FindGraphQLTags: Substitutions are not allowed in graphql tags.'</span>) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> quasis[<span class="hljs-number">0</span>];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSourceLocationOffset</span>(<span class="hljs-params">quasi</span>) </span>{
  <span class="hljs-keyword">var</span> loc = getTemplateNode(quasi).loc.start;
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">line</span>: loc.line,
    <span class="hljs-attr">column</span>: loc.column + <span class="hljs-number">1</span> <span class="hljs-comment">// babylon is 0-indexed, graphql expects 1-indexed</span>

  };
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invariant</span>(<span class="hljs-params">condition, msg</span>) </span>{
  <span class="hljs-keyword">if</span> (!condition) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">arguments</span>.length, args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(_len &gt; <span class="hljs-number">2</span> ? _len - <span class="hljs-number">2</span> : <span class="hljs-number">0</span>), _key = <span class="hljs-number">2</span>; _key &lt; _len; _key++) {
      args[_key - <span class="hljs-number">2</span>] = <span class="hljs-built_in">arguments</span>[_key];
    }

    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(util.format.apply(util, [msg].concat(args)));
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span>(<span class="hljs-params">node, visitors</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-416" id="section-416"></a>
</div>
<p>$FlowFixMe Discovered when typing babel</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> fn = visitors[node.type];

  <span class="hljs-keyword">if</span> (fn != <span class="hljs-literal">null</span>) {
    fn(node);
    <span class="hljs-keyword">return</span>;
  }

  traverse(node, visitors);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">traverse</span>(<span class="hljs-params">node, visitors</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> node) {
    <span class="hljs-keyword">if</span> (IGNORED_KEYS[key]) {
      <span class="hljs-keyword">continue</span>;
    }

    <span class="hljs-keyword">var</span> prop = node[key];

    <span class="hljs-keyword">if</span> (prop &amp;&amp; <span class="hljs-keyword">typeof</span> prop === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> prop.type === <span class="hljs-string">'string'</span>) {
      visit(prop, visitors);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(prop)) {
      prop.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
        <span class="hljs-keyword">if</span> (item &amp;&amp; <span class="hljs-keyword">typeof</span> item === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-keyword">typeof</span> item.type === <span class="hljs-string">'string'</span>) {
          visit(item, visitors);
        }
      });
    }
  }
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">find</span>: Profiler.instrument(find, <span class="hljs-string">'FindGraphQLTags.find'</span>)
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 114 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@babel/parser"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 115 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-417" id="section-417"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> formatGeneratedModule = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatGeneratedModule</span>(<span class="hljs-params">_ref</span>) </span>{
  <span class="hljs-keyword">var</span> moduleName = _ref.moduleName,
      documentType = _ref.documentType,
      docText = _ref.docText,
      concreteText = _ref.concreteText,
      typeText = _ref.typeText,
      hash = _ref.hash,
      sourceHash = _ref.sourceHash;
  <span class="hljs-keyword">var</span> documentTypeImport = documentType ? <span class="hljs-string">"import type { "</span>.concat(documentType, <span class="hljs-string">" } from 'relay-runtime';"</span>) : <span class="hljs-string">''</span>;
  <span class="hljs-keyword">var</span> docTextComment = docText != <span class="hljs-literal">null</span> ? <span class="hljs-string">'\n/*\n'</span> + docText.trim() + <span class="hljs-string">'\n*/\n'</span> : <span class="hljs-string">''</span>;
  <span class="hljs-keyword">var</span> hashText = hash != <span class="hljs-literal">null</span> ? <span class="hljs-string">"\n * "</span>.concat(hash) : <span class="hljs-string">''</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-string">"/**\n * "</span>.concat(<span class="hljs-string">'@'</span>, <span class="hljs-string">"flow"</span>, hashText, <span class="hljs-string">"\n */\n\n/* eslint-disable */\n\n'use strict';\n\n/*::\n"</span>).concat(documentTypeImport, <span class="hljs-string">"\n"</span>).concat(typeText || <span class="hljs-string">''</span>, <span class="hljs-string">"\n*/\n\n"</span>).concat(docTextComment, <span class="hljs-string">"\nconst node/*: "</span>).concat(documentType || <span class="hljs-string">'empty'</span>, <span class="hljs-string">"*/ = "</span>).concat(concreteText, <span class="hljs-string">";\n// prettier-ignore\n(node/*: any*/).hash = '"</span>).concat(sourceHash, <span class="hljs-string">"';\n"</span>);
};

<span class="hljs-keyword">var</span> formatGeneratedCommonjsModule = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatGeneratedCommonjsModule</span>(<span class="hljs-params">options</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.concat(formatGeneratedModule(options), <span class="hljs-string">"\nmodule.exports = node;\n"</span>);
};

<span class="hljs-keyword">var</span> formatGeneratedESModule = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatGeneratedESModule</span>(<span class="hljs-params">options</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>.concat(formatGeneratedModule(options), <span class="hljs-string">"\nexport default node;\n"</span>);
};

exports.formatGeneratedCommonjsModule = formatGeneratedCommonjsModule;
exports.formatGeneratedESModule = formatGeneratedESModule;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 116 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-418" id="section-418"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _toConsumableArray2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">4</span>));

<span class="hljs-keyword">var</span> ASTCache = __webpack_require__(<span class="hljs-number">27</span>);

<span class="hljs-keyword">var</span> GraphQL = __webpack_require__(<span class="hljs-number">7</span>);

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>);

<span class="hljs-keyword">var</span> fs = __webpack_require__(<span class="hljs-number">12</span>);

<span class="hljs-keyword">var</span> invariant = __webpack_require__(<span class="hljs-number">5</span>);

<span class="hljs-keyword">var</span> path = __webpack_require__(<span class="hljs-number">8</span>);

<span class="hljs-keyword">var</span> _require = __webpack_require__(<span class="hljs-number">117</span>),
    memoizedFind = _require.memoizedFind;

<span class="hljs-keyword">var</span> parseGraphQL = Profiler.instrument(GraphQL.parse, <span class="hljs-string">'GraphQL.parse'</span>);

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tagFinder, getFileFilter</span>) </span>{
  <span class="hljs-keyword">var</span> memoizedTagFinder = memoizedFind.bind(<span class="hljs-literal">null</span>, tagFinder);

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseFile</span>(<span class="hljs-params">baseDir, file</span>) </span>{
    <span class="hljs-keyword">var</span> result = parseFileWithSources(baseDir, file);

    <span class="hljs-keyword">if</span> (result) {
      <span class="hljs-keyword">return</span> result.document;
    }
  } <span class="hljs-comment">// Throws an error if parsing the file fails</span>


  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseFileWithSources</span>(<span class="hljs-params">baseDir, file</span>) </span>{
    <span class="hljs-keyword">var</span> filePath = path.join(baseDir, file.relPath);
    <span class="hljs-keyword">var</span> text = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">try</span> {
      text = fs.readFileSync(filePath, <span class="hljs-string">'utf8'</span>);
    } <span class="hljs-keyword">catch</span> (_unused) {
       <span class="hljs-literal">true</span> ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelaySourceModuleParser: Files should be filtered before passed to the '</span> + <span class="hljs-string">'parser, got unfiltered file `%s`.'</span>, file.relPath) : <span class="hljs-literal">undefined</span> : <span class="hljs-literal">undefined</span>;
    }

    <span class="hljs-keyword">var</span> astDefinitions = [];
    <span class="hljs-keyword">var</span> sources = [];
    memoizedTagFinder(text, baseDir, file).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">template</span>) </span>{
      <span class="hljs-keyword">var</span> source = <span class="hljs-keyword">new</span> GraphQL.Source(template, file.relPath);
      <span class="hljs-keyword">var</span> ast = parseGraphQL(source);
      !ast.definitions.length ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelaySourceModuleParser: Expected GraphQL text to contain at least one '</span> + <span class="hljs-string">'definition (fragment, mutation, query, subscription), got `%s`.'</span>, template) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
      sources.push(source.body);
      astDefinitions.push.apply(astDefinitions, (<span class="hljs-number">0</span>, _toConsumableArray2[<span class="hljs-string">"default"</span>])(ast.definitions));
    });
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">document</span>: {
        <span class="hljs-attr">kind</span>: <span class="hljs-string">'Document'</span>,
        <span class="hljs-attr">definitions</span>: astDefinitions
      },
      <span class="hljs-attr">sources</span>: sources
    };
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getParser</span>(<span class="hljs-params">baseDir</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ASTCache({
      <span class="hljs-attr">baseDir</span>: baseDir,
      <span class="hljs-attr">parse</span>: parseFile
    });
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defaultGetFileFilter</span>(<span class="hljs-params">baseDir</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">file</span>) </span>{
      <span class="hljs-keyword">var</span> filePath = path.join(baseDir, file.relPath);
      <span class="hljs-keyword">var</span> text = <span class="hljs-string">''</span>;

      <span class="hljs-keyword">try</span> {
        text = fs.readFileSync(filePath, <span class="hljs-string">'utf8'</span>);
      } <span class="hljs-keyword">catch</span> (_unused2) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-419" id="section-419"></a>
</div>
<p>eslint-disable no-console</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">"RelaySourceModuleParser: Unable to read the file \""</span>.concat(filePath, <span class="hljs-string">"\". Looks like it was removed."</span>));
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">return</span> text.indexOf(<span class="hljs-string">'graphql'</span>) &gt;= <span class="hljs-number">0</span>;
    };
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">getParser</span>: getParser,
    <span class="hljs-attr">getFileFilter</span>: getFileFilter !== <span class="hljs-literal">null</span> &amp;&amp; getFileFilter !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? getFileFilter : defaultGetFileFilter,
    <span class="hljs-attr">parseFile</span>: parseFile,
    <span class="hljs-attr">parseFileWithSources</span>: parseFileWithSources
  };
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 117 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-420" id="section-420"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> RelayCompilerCache = __webpack_require__(<span class="hljs-number">118</span>);

<span class="hljs-keyword">var</span> getModuleName = __webpack_require__(<span class="hljs-number">120</span>);

<span class="hljs-keyword">var</span> graphql = __webpack_require__(<span class="hljs-number">7</span>);

<span class="hljs-keyword">var</span> path = __webpack_require__(<span class="hljs-number">8</span>);

<span class="hljs-keyword">var</span> util = __webpack_require__(<span class="hljs-number">49</span>);

<span class="hljs-keyword">var</span> cache = <span class="hljs-keyword">new</span> RelayCompilerCache(<span class="hljs-string">'RelayFindGraphQLTags'</span>, <span class="hljs-string">'v1'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoizedFind</span>(<span class="hljs-params">tagFinder, text, baseDir, file</span>) </span>{
  !file.exists ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayFindGraphQLTags: Called with non-existent file `%s`'</span>, file.relPath) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> cache.getOrCompute(file.hash, find.bind(<span class="hljs-literal">null</span>, tagFinder, text, path.join(baseDir, file.relPath)));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">tagFinder, text, absPath</span>) </span>{
  <span class="hljs-keyword">var</span> tags = tagFinder(text, absPath);
  <span class="hljs-keyword">var</span> moduleName = getModuleName(absPath);
  tags.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tag</span>) </span>{
    <span class="hljs-keyword">return</span> validateTemplate(tag, moduleName, absPath);
  });
  <span class="hljs-keyword">return</span> tags.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">tag</span>) </span>{
    <span class="hljs-keyword">return</span> tag.template;
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validateTemplate</span>(<span class="hljs-params">_ref, moduleName, filePath</span>) </span>{
  <span class="hljs-keyword">var</span> template = _ref.template,
      keyName = _ref.keyName,
      sourceLocationOffset = _ref.sourceLocationOffset;
  <span class="hljs-keyword">var</span> ast = graphql.parse(<span class="hljs-keyword">new</span> graphql.Source(template, filePath, sourceLocationOffset));
  ast.definitions.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">def</span>) </span>{
    <span class="hljs-keyword">if</span> (def.kind === <span class="hljs-string">'OperationDefinition'</span>) {
      !(def.name != <span class="hljs-literal">null</span>) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayFindGraphQLTags: In module `%s`, an operation requires a name.'</span>, moduleName, def.kind) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> definitionName = def.name.value;
      <span class="hljs-keyword">var</span> operationNameParts = definitionName.match(<span class="hljs-regexp">/^(.*)(Mutation|Query|Subscription)$/</span>);
      !(operationNameParts &amp;&amp; definitionName.startsWith(moduleName)) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayFindGraphQLTags: Operation names in graphql tags must be prefixed '</span> + <span class="hljs-string">'with the module name and end in "Mutation", "Query", or '</span> + <span class="hljs-string">'"Subscription". Got `%s` in module `%s`.'</span>, definitionName, moduleName) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (def.kind === <span class="hljs-string">'FragmentDefinition'</span>) {
      <span class="hljs-keyword">var</span> _definitionName = def.name.value;

      <span class="hljs-keyword">if</span> (keyName != <span class="hljs-literal">null</span>) {
        !(_definitionName === moduleName + <span class="hljs-string">'_'</span> + keyName) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayFindGraphQLTags: Container fragment names must be '</span> + <span class="hljs-string">'`&lt;ModuleName&gt;_&lt;propName&gt;`. Got `%s`, expected `%s`.'</span>, _definitionName, moduleName + <span class="hljs-string">'_'</span> + keyName) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> {
        !_definitionName.startsWith(moduleName) ?  <span class="hljs-literal">true</span> ? invariant(<span class="hljs-literal">false</span>, <span class="hljs-string">'RelayFindGraphQLTags: Fragment names in graphql tags must be prefixed '</span> + <span class="hljs-string">'with the module name. Got `%s` in module `%s`.'</span>, _definitionName, moduleName) : <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
      }
    }
  });
} <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Not sure why this is defined here rather than imported, is it so that it doesnt get stripped in prod?</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invariant</span>(<span class="hljs-params">condition, msg</span>) </span>{
  <span class="hljs-keyword">if</span> (!condition) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">arguments</span>.length, args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(_len &gt; <span class="hljs-number">2</span> ? _len - <span class="hljs-number">2</span> : <span class="hljs-number">0</span>), _key = <span class="hljs-number">2</span>; _key &lt; _len; _key++) {
      args[_key - <span class="hljs-number">2</span>] = <span class="hljs-built_in">arguments</span>[_key];
    }

    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(util.format.apply(util, [msg].concat(args)));
  }
}

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">find</span>: find,
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-421" id="section-421"></a>
</div>
<p>Exported for testing only.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  memoizedFind: memoizedFind
};

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 118 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-422" id="section-422"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> _interopRequireDefault = __webpack_require__(<span class="hljs-number">0</span>);

<span class="hljs-keyword">var</span> _defineProperty2 = _interopRequireDefault(__webpack_require__(<span class="hljs-number">2</span>));

<span class="hljs-keyword">var</span> Profiler = __webpack_require__(<span class="hljs-number">6</span>);

<span class="hljs-keyword">var</span> crypto = __webpack_require__(<span class="hljs-number">13</span>);

<span class="hljs-keyword">var</span> fs = __webpack_require__(<span class="hljs-number">12</span>);

<span class="hljs-keyword">var</span> os = __webpack_require__(<span class="hljs-number">119</span>);

<span class="hljs-keyword">var</span> path = __webpack_require__(<span class="hljs-number">8</span>);
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-423" id="section-423"></a>
</div>
<div class="dox">
<div class="summary">
<p>A file backed cache. Values are JSON encoded on disk, so only JSON
serializable values should be used.</p>
</div>
<div class="body">
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> RelayCompilerCache = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-424" id="section-424"></a>
</div>
<div class="dox">
<div class="summary">
</div>
<div class="body">
</div>
<div class="details">
<div class="dox_tag_title">Params</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">name</span>
<span>Human readable identifier for the cache
</span>
</div>
<div class="dox_tag_detail">
<span class="dox_tag_name">cacheBreaker</span>
<span>This should be changed in order to invalidate existing                     caches.
</span>
</div>
</div>
</div>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RelayCompilerCache</span>(<span class="hljs-params">name, cacheBreaker</span>) </span>{
    (<span class="hljs-number">0</span>, _defineProperty2[<span class="hljs-string">"default"</span>])(<span class="hljs-keyword">this</span>, <span class="hljs-string">"_dir"</span>, <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">this</span>._name = name;
    <span class="hljs-keyword">this</span>._cacheBreaker = cacheBreaker;
  }

  <span class="hljs-keyword">var</span> _proto = RelayCompilerCache.prototype;

  _proto._getFile = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_getFile</span>(<span class="hljs-params">key</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._dir == <span class="hljs-literal">null</span>) {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-425" id="section-425"></a>
</div>
<p>Include username in the cache dir to avoid issues with directories being
owned by a different user.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">      <span class="hljs-keyword">var</span> username = os.userInfo().username;
      <span class="hljs-keyword">var</span> cacheID = crypto.createHash(<span class="hljs-string">'md5'</span>).update(<span class="hljs-keyword">this</span>._cacheBreaker).update(username).digest(<span class="hljs-string">'hex'</span>);
      <span class="hljs-keyword">var</span> dir = path.join(os.tmpdir(), <span class="hljs-string">""</span>.concat(<span class="hljs-keyword">this</span>._name, <span class="hljs-string">"-"</span>).concat(cacheID));

      <span class="hljs-keyword">if</span> (!fs.existsSync(dir)) {
        <span class="hljs-keyword">try</span> {
          fs.mkdirSync(dir);
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-keyword">if</span> (error.code !== <span class="hljs-string">'EEXIST'</span>) {
            <span class="hljs-keyword">throw</span> error;
          }
        }
      }

      <span class="hljs-keyword">this</span>._dir = dir;
    }

    <span class="hljs-keyword">return</span> path.join(<span class="hljs-keyword">this</span>._dir, key);
  };

  _proto.getOrCompute = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOrCompute</span>(<span class="hljs-params">key, compute</span>) </span>{
    <span class="hljs-keyword">var</span> _this = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">return</span> Profiler.run(<span class="hljs-string">'RelayCompilerCache.getOrCompute'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> cacheFile = _this._getFile(key);

      <span class="hljs-keyword">if</span> (fs.existsSync(cacheFile)) {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(fs.readFileSync(cacheFile, <span class="hljs-string">'utf8'</span>));
        } <span class="hljs-keyword">catch</span> (_unused) {<span class="hljs-comment">// ignore</span>
        }
      }

      <span class="hljs-keyword">var</span> value = compute();

      <span class="hljs-keyword">try</span> {
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-426" id="section-426"></a>
</div>
<p>$FlowFixMe[incompatible-call] JSON.stringify can return undefined</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">        fs.writeFileSync(cacheFile, <span class="hljs-built_in">JSON</span>.stringify(value), <span class="hljs-string">'utf8'</span>);
      } <span class="hljs-keyword">catch</span> (_unused2) {<span class="hljs-comment">// ignore</span>
      }

      <span class="hljs-keyword">return</span> value;
    });
  };

  <span class="hljs-keyword">return</span> RelayCompilerCache;
}();

<span class="hljs-built_in">module</span>.exports = RelayCompilerCache;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 119 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"os"</span>);

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 120 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports, __webpack_require__</span>) </span>{

<span class="hljs-meta">"use strict"</span>;
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-427" id="section-427"></a>
</div>
<div class="dox">
<div class="summary">
<p>Copyright (c) Facebook, Inc. and its affiliates.</p>
</div>
<div class="body">
<p>This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.</p>
</div>
<div class="details">
</div>
</div>
flowlint ambiguous-object-type:error

        </td>
        <td class="code highlight">
          <pre class="javascript">

<span class="hljs-keyword">var</span> path = __webpack_require__(<span class="hljs-number">8</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getModuleName</span>(<span class="hljs-params">filePath</span>) </span>{
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-428" id="section-428"></a>
</div>
<p>index.js -&gt; index
index.js.flow -&gt; index.js</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">  <span class="hljs-keyword">var</span> filename = path.basename(filePath, path.extname(filePath)); <span class="hljs-comment">// index.js -&gt; index (when extension has multiple segments)</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-429" id="section-429"></a>
</div>
<p>index.react -&gt; index (when extension has multiple segments)</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  filename = filename.replace(<span class="hljs-regexp">/(\.(?!ios|android)[_a-zA-Z0-9\\-]+)+/g</span>, <span class="hljs-string">''</span>); <span class="hljs-comment">// /path/to/button/index.js -&gt; button</span>

  <span class="hljs-keyword">var</span> moduleName = filename === <span class="hljs-string">'index'</span> ? path.basename(path.dirname(filePath)) : filename; <span class="hljs-comment">// foo-bar -&gt; fooBar</span>
</pre>
        </td>
      </tr>
    
      <tr>
        <td class="docs">
          <div class="pilwrap">
  <a class="pilcrow" href="#section-430" id="section-430"></a>
</div>
<p>Relay compatibility mode splits on _, so we can't use that here.</p>

        </td>
        <td class="code highlight">
          <pre class="javascript">
  moduleName = moduleName.replace(<span class="hljs-regexp">/[^a-zA-Z0-9]+(\w?)/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match, next</span>) </span>{
    <span class="hljs-keyword">return</span> next.toUpperCase();
  });
  <span class="hljs-keyword">return</span> moduleName;
}

<span class="hljs-built_in">module</span>.exports = getModuleName;

<span class="hljs-comment">/***/</span> }),
<span class="hljs-comment">/* 121 */</span>
<span class="hljs-comment">/***/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">module, exports</span>) </span>{

<span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">"glob"</span>);

<span class="hljs-comment">/***/</span> })
<span class="hljs-comment">/******/</span> ]);
</pre>
        </td>
      </tr>
    
  </tbody>
</table>

  </div>
</body>
</html>
